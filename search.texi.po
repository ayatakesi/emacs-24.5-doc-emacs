# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-25 01:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: search.texi.orig:5
#, no-wrap
msgid "Search"
msgstr ""

#. type: chapter
#: search.texi.orig:6
#, no-wrap
msgid "Searching and Replacement"
msgstr ""

#. type: cindex
#: search.texi.orig:7
#, no-wrap
msgid "searching"
msgstr ""

#. type: cindex
#: search.texi.orig:8
#, no-wrap
msgid "finding strings within text"
msgstr ""

#. type: Plain text
#: search.texi.orig:14
msgid ""
"Like other editors, Emacs has commands to search for occurrences of a "
"string.  Emacs also has commands to replace occurrences of a string with a "
"different string.  There are also commands that do the same thing, but "
"search for patterns instead of fixed strings."
msgstr ""

#. type: Plain text
#: search.texi.orig:19
msgid ""
"You can also search multiple files under the control of a tags table "
"(@pxref{Tags Search}) or through the Dired @kbd{A} command (@pxref{Operating "
"on Files}), or ask the @code{grep} program to do it (@pxref{Grep "
"Searching})."
msgstr ""

#. type: section
#: search.texi.orig:32 search.texi.orig:34 search.texi.orig:35
#, no-wrap
msgid "Incremental Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Search happens as you type the string."
msgstr ""

#. type: section
#: search.texi.orig:32 search.texi.orig:439 search.texi.orig:440
#, no-wrap
msgid "Nonincremental Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Specify entire string and then search."
msgstr ""

#. type: section
#: search.texi.orig:32 search.texi.orig:467 search.texi.orig:468
#, no-wrap
msgid "Word Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Search for sequence of words."
msgstr ""

#. type: section
#: search.texi.orig:32 search.texi.orig:517 search.texi.orig:518
#, no-wrap
msgid "Symbol Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Search for a source code symbol."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:564
#, no-wrap
msgid "Regexp Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Search for match for a regexp."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:639
#, no-wrap
msgid "Regexps"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Syntax of regular expressions."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:849
#, no-wrap
msgid "Regexp Backslash"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Regular expression constructs starting with `\\'."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:1015
#, no-wrap
msgid "Regexp Example"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "A complex regular expression explained."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:1033
#, no-wrap
msgid "Search Case"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "To ignore case while searching, or not."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:1071
#, no-wrap
msgid "Replace"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Search, and replace some or all matches."
msgstr ""

#. type: node
#: search.texi.orig:32 search.texi.orig:1409
#, no-wrap
msgid "Other Repeating Search"
msgstr ""

#. type: menuentry
#: search.texi.orig:32
msgid "Operating on all matches for some regexp."
msgstr ""

#. type: cindex
#: search.texi.orig:36
#, no-wrap
msgid "incremental search"
msgstr ""

#. type: cindex
#: search.texi.orig:37
#, no-wrap
msgid "isearch"
msgstr ""

#. type: Plain text
#: search.texi.orig:46
msgid ""
"The principal search command in Emacs is @dfn{incremental}: it begins "
"searching as soon as you type the first character of the search string.  As "
"you type in the search string, Emacs shows you where the string (as you have "
"typed it so far) would be found.  When you have typed enough characters to "
"identify the place you want, you can stop.  Depending on what you plan to do "
"next, you may or may not need to terminate the search explicitly with "
"@key{RET}."
msgstr ""

#. type: kindex
#: search.texi.orig:48 search.texi.orig:69 search.texi.orig:75
#, no-wrap
msgid "C-s"
msgstr ""

#. type: table
#: search.texi.orig:50
msgid "Incremental search forward (@code{isearch-forward})."
msgstr ""

#. type: item
#: search.texi.orig:50 search.texi.orig:71 search.texi.orig:118 search.texi.orig:1359
#, no-wrap
msgid "C-r"
msgstr ""

#. type: table
#: search.texi.orig:52
msgid "Incremental search backward (@code{isearch-backward})."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:65
#, no-wrap
msgid "Basic Isearch"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "Basic incremental search commands."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:125
#, no-wrap
msgid "Repeat Isearch"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "Searching for the same string again."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:182
#, no-wrap
msgid "Error in Isearch"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "When your string is not found."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:216
#, no-wrap
msgid "Special Isearch"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "Special input in incremental search."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:317
#, no-wrap
msgid "Isearch Yank"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid ""
"Commands that grab text into the search string or else edit the search "
"string."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:360
#, no-wrap
msgid "Not Exiting Isearch"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "Prefix argument and scrolling commands."
msgstr ""

#. type: node
#: search.texi.orig:63 search.texi.orig:415
#, no-wrap
msgid "Isearch Minibuffer"
msgstr ""

#. type: menuentry
#: search.texi.orig:63
msgid "Incremental search of the minibuffer history."
msgstr ""

#. type: subsection
#: search.texi.orig:66
#, no-wrap
msgid "Basics of Incremental Search"
msgstr ""

#. type: table
#: search.texi.orig:71
msgid "Begin incremental search (@code{isearch-forward})."
msgstr ""

#. type: table
#: search.texi.orig:73
msgid "Begin reverse incremental search (@code{isearch-backward})."
msgstr ""

#. type: findex
#: search.texi.orig:76
#, no-wrap
msgid "isearch-forward"
msgstr ""

#. type: Plain text
#: search.texi.orig:80
msgid ""
"@kbd{C-s} (@code{isearch-forward}) starts a forward incremental search.  It "
"reads characters from the keyboard, and moves point just past the end of the "
"next occurrence of those characters in the buffer."
msgstr ""

#. type: Plain text
#: search.texi.orig:87
msgid ""
"For instance, if you type @kbd{C-s} and then @kbd{F}, that puts the cursor "
"after the first @samp{F} that occurs in the buffer after the starting "
"point.  Then if you then type @kbd{O}, the cursor moves to just after the "
"first @samp{FO}; the @samp{F} in that @samp{FO} might not be the first "
"@samp{F} previously found.  After another @kbd{O}, the cursor moves to just "
"after the first @samp{FOO}."
msgstr ""

#. type: cindex
#: search.texi.orig:88
#, no-wrap
msgid "faces for highlighting search matches"
msgstr ""

#. type: cindex
#: search.texi.orig:89
#, no-wrap
msgid "isearch face"
msgstr ""

#. type: Plain text
#: search.texi.orig:94
msgid ""
"At each step, Emacs highlights the @dfn{current match}---the buffer text "
"that matches the search string---using the @code{isearch} face "
"(@pxref{Faces}).  The current search string is also displayed in the echo "
"area."
msgstr ""

#. type: Plain text
#: search.texi.orig:97
msgid ""
"If you make a mistake typing the search string, type @key{DEL}.  Each "
"@key{DEL} cancels the last character of the search string."
msgstr ""

#. type: Plain text
#: search.texi.orig:108
msgid ""
"When you are satisfied with the place you have reached, type @key{RET}.  "
"This stops searching, leaving the cursor where the search brought it.  Also, "
"any command not specially meaningful in searches stops the searching and is "
"then executed.  Thus, typing @kbd{C-a} exits the search and then moves to "
"the beginning of the line.  @key{RET} is necessary only if the next command "
"you want to type is a printing character, @key{DEL}, @key{RET}, or another "
"character that is special within searches (@kbd{C-q}, @kbd{C-w}, @kbd{C-r}, "
"@kbd{C-s}, @kbd{C-y}, @kbd{M-y}, @kbd{M-r}, @kbd{M-c}, @kbd{M-e}, and some "
"others described below)."
msgstr ""

#. type: Plain text
#: search.texi.orig:111
msgid ""
"As a special exception, entering @key{RET} when the search string is empty "
"launches nonincremental search (@pxref{Nonincremental Search})."
msgstr ""

#. type: Plain text
#: search.texi.orig:117
msgid ""
"When you exit the incremental search, it adds the original value of point to "
"the mark ring, without activating the mark; you can thus use @kbd{C-u "
"C-@key{SPC}} to return to where you were before beginning the search.  "
"@xref{Mark Ring}.  It only does this if the mark was not already active."
msgstr ""

#. type: findex
#: search.texi.orig:119
#, no-wrap
msgid "isearch-backward"
msgstr ""

#. type: Plain text
#: search.texi.orig:124
msgid ""
"To search backwards, use @kbd{C-r} (@code{isearch-backward}) instead of "
"@kbd{C-s} to start the search.  A backward search finds matches that end "
"before the starting point, just as a forward search finds matches that begin "
"after it."
msgstr ""

#. type: subsection
#: search.texi.orig:126
#, no-wrap
msgid "Repeating Incremental Search"
msgstr ""

#. type: Plain text
#: search.texi.orig:135
msgid ""
"Suppose you search forward for @samp{FOO} and find a match, but not the one "
"you expected to find: the @samp{FOO} you were aiming for occurs later in the "
"buffer.  In this event, type another @kbd{C-s} to move to the next "
"occurrence of the search string.  You can repeat this any number of times.  "
"If you overshoot, you can cancel some @kbd{C-s} characters with @key{DEL}.  "
"Similarly, each @kbd{C-r} in a backward incremental search repeats the "
"backward search."
msgstr ""

#. type: cindex
#: search.texi.orig:136
#, no-wrap
msgid "lazy search highlighting"
msgstr ""

#. type: vindex
#: search.texi.orig:137
#, no-wrap
msgid "isearch-lazy-highlight"
msgstr ""

#. type: Plain text
#: search.texi.orig:146
msgid ""
"If you pause for a little while during incremental search, Emacs highlights "
"all the other possible matches for the search string that are present on the "
"screen.  This helps you anticipate where you can get to by typing @kbd{C-s} "
"or @kbd{C-r} to repeat the search.  The other matches are highlighted "
"differently from the current match, using the customizable face "
"@code{lazy-highlight} (@pxref{Faces}).  If you don't like this feature, you "
"can disable it by setting @code{isearch-lazy-highlight} to @code{nil}."
msgstr ""

#. type: Plain text
#: search.texi.orig:154
msgid ""
"After exiting a search, you can search for the same string again by typing "
"just @kbd{C-s C-s}.  The first @kbd{C-s} is the key that invokes incremental "
"search, and the second @kbd{C-s} means ``search again''.  Similarly, "
"@kbd{C-r C-r} searches backward for the last search string.  In determining "
"the last search string, it doesn't matter whether the string was searched "
"for with @kbd{C-s} or @kbd{C-r}."
msgstr ""

#. type: Plain text
#: search.texi.orig:159
msgid ""
"If you are searching forward but you realize you were looking for something "
"before the starting point, type @kbd{C-r} to switch to a backward search, "
"leaving the search string unchanged.  Similarly, @kbd{C-s} in a backward "
"search switches to a forward search."
msgstr ""

#. type: Plain text
#: search.texi.orig:168
msgid ""
"If a search is failing and you ask to repeat it by typing another @kbd{C-s}, "
"it starts again from the beginning of the buffer.  Repeating a failing "
"reverse search with @kbd{C-r} starts again from the end.  This is called "
"@dfn{wrapping around}, and @samp{Wrapped} appears in the search prompt once "
"this has happened.  If you keep on going past the original starting point of "
"the search, it changes to @samp{Overwrapped}, which means that you are "
"revisiting matches that you have already seen."
msgstr ""

#. type: cindex
#: search.texi.orig:169
#, no-wrap
msgid "search ring"
msgstr ""

#. type: kindex
#: search.texi.orig:170
#, no-wrap
msgid "M-n @r{(Incremental search)}"
msgstr ""

#. type: kindex
#: search.texi.orig:171
#, no-wrap
msgid "M-p @r{(Incremental search)}"
msgstr ""

#. type: Plain text
#: search.texi.orig:176
msgid ""
"To reuse earlier search strings, use the @dfn{search ring}.  The commands "
"@kbd{M-p} and @kbd{M-n} move through the ring to pick a search string to "
"reuse.  These commands leave the selected search ring element in the "
"minibuffer, where you can edit it."
msgstr ""

#. type: kindex
#: search.texi.orig:177
#, no-wrap
msgid "M-e @r{(Incremental search)}"
msgstr ""

#. type: Plain text
#: search.texi.orig:181
msgid ""
"To edit the current search string in the minibuffer without replacing it "
"with items from the search ring, type @kbd{M-e}.  Type @key{RET}, @kbd{C-s} "
"or @kbd{C-r} to finish editing the string and search for it."
msgstr ""

#. type: subsection
#: search.texi.orig:183
#, no-wrap
msgid "Errors in Incremental Search"
msgstr ""

#. type: Plain text
#: search.texi.orig:192
msgid ""
"If your string is not found at all, the echo area says @samp{Failing "
"I-Search}, and the cursor moves past the place where Emacs found as much of "
"your string as it could.  Thus, if you search for @samp{FOOT}, and there is "
"no @samp{FOOT}, you might see the cursor after the @samp{FOO} in "
"@samp{FOOL}.  In the echo area, the part of the search string that failed to "
"match is highlighted using the face @code{isearch-fail}."
msgstr ""

#. type: Plain text
#: search.texi.orig:201
msgid ""
"At this point, there are several things you can do.  If your string was "
"mistyped, you can use @key{DEL} to erase some of it and correct it.  If you "
"like the place you have found, you can type @key{RET} to remain there.  Or "
"you can type @kbd{C-g}, which removes from the search string the characters "
"that could not be found (the @samp{T} in @samp{FOOT}), leaving those that "
"were found (the @samp{FOO} in @samp{FOOT}).  A second @kbd{C-g} at that "
"point cancels the search entirely, returning point to where it was when the "
"search started."
msgstr ""

#. type: cindex
#: search.texi.orig:202
#, no-wrap
msgid "quitting (in search)"
msgstr ""

#. type: kindex
#: search.texi.orig:203
#, no-wrap
msgid "C-g @r{(Incremental search)}"
msgstr ""

#. type: Plain text
#: search.texi.orig:215
msgid ""
"The quit command, @kbd{C-g}, does special things during searches; just what "
"it does depends on the status of the search.  If the search has found what "
"you specified and is waiting for input, @kbd{C-g} cancels the entire search, "
"moving the cursor back to where you started the search.  If @kbd{C-g} is "
"typed when there are characters in the search string that have not been "
"found---because Emacs is still searching for them, or because it has failed "
"to find them---then the search string characters which have not been found "
"are discarded from the search string.  With them gone, the search is now "
"successful and waiting for more input, so a second @kbd{C-g} will cancel the "
"entire search."
msgstr ""

#. type: subsection
#: search.texi.orig:217
#, no-wrap
msgid "Special Input for Incremental Search"
msgstr ""

#. type: Plain text
#: search.texi.orig:221
msgid ""
"Some of the characters you type during incremental search have special "
"effects."
msgstr ""

#. type: cindex
#: search.texi.orig:222
#, no-wrap
msgid "lax space matching"
msgstr ""

#. type: kindex
#: search.texi.orig:223
#, no-wrap
msgid "M-s SPC @r{(Incremental search)}"
msgstr ""

#. type: kindex
#: search.texi.orig:224
#, no-wrap
msgid "SPC @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:225
#, no-wrap
msgid "isearch-toggle-lax-whitespace"
msgstr ""

#. type: vindex
#: search.texi.orig:226
#, no-wrap
msgid "search-whitespace-regexp"
msgstr ""

#. type: Plain text
#: search.texi.orig:236
msgid ""
"By default, incremental search performs @dfn{lax space matching}: each "
"space, or sequence of spaces, matches any sequence of one or more spaces in "
"the text.  Hence, @samp{foo bar} matches @samp{foo bar}, @samp{foo bar}, "
"@samp{foo bar}, and so on (but not @samp{foobar}).  More precisely, Emacs "
"matches each sequence of space characters in the search string to a regular "
"expression specified by the variable @code{search-whitespace-regexp}.  For "
"example, to make spaces match sequences of newlines as well as spaces, set "
"it to @samp{\"[[:space:]\\n]+\"}."
msgstr ""

#. type: Plain text
#: search.texi.orig:241
msgid ""
"To toggle lax space matching, type @kbd{M-s @key{SPC}} "
"(@code{isearch-toggle-lax-whitespace}).  To disable this feature entirely, "
"change @code{search-whitespace-regexp} to @code{nil}; then each space in the "
"search string matches exactly one space."
msgstr ""

#. type: Plain text
#: search.texi.orig:247
msgid ""
"If the search string you entered contains only lower-case letters, the "
"search is case-insensitive; as long as an upper-case letter exists in the "
"search string, the search becomes case-sensitive.  If you delete the "
"upper-case character from the search string, it ceases to have this effect.  "
"@xref{Search Case}."
msgstr ""

#. type: cindex
#: search.texi.orig:248
#, no-wrap
msgid "invisible text, searching for"
msgstr ""

#. type: kindex
#: search.texi.orig:249
#, no-wrap
msgid "M-s i @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:250
#, no-wrap
msgid "isearch-toggle-invisible"
msgstr ""

#. type: Plain text
#: search.texi.orig:253
msgid ""
"To toggle whether or not invisible text is searched, type @kbd{M-s i} "
"(@code{isearch-toggle-invisible}).  @xref{Outline Search}."
msgstr ""

#. type: Plain text
#: search.texi.orig:255
msgid "To search for a newline character, type @kbd{C-j}."
msgstr ""

#. type: Plain text
#: search.texi.orig:258
msgid ""
"To search for non-@acronym{ASCII} characters, use one of the following "
"methods:"
msgstr ""

#. type: itemize
#: search.texi.orig:266
msgid ""
"Type @kbd{C-q}, followed by a non-graphic character or a sequence of octal "
"digits.  This adds a character to the search string, similar to inserting "
"into a buffer using @kbd{C-q} (@pxref{Inserting Text}).  For example, "
"@kbd{C-q C-s} during incremental search adds the @samp{control-S} character "
"to the search string."
msgstr ""

#. type: itemize
#: search.texi.orig:271
msgid ""
"Type @kbd{C-x 8 @key{RET}}, followed by a Unicode name or code-point.  This "
"adds the specified character into the search string, similar to the usual "
"@code{insert-char} command (@pxref{Inserting Text})."
msgstr ""

#. type: itemize
#: search.texi.orig:283
msgid ""
"Use an input method (@pxref{Input Methods}).  If an input method is enabled "
"in the current buffer when you start the search, you can use it in the "
"search string also.  While typing the search string, you can toggle the "
"input method with @kbd{C-\\} (@code{isearch-toggle-input-method}).  You can "
"also turn on a non-default input method with @kbd{C-^} "
"(@code{isearch-toggle-specified-input-method}), which prompts for the name "
"of the input method.  When an input method is active during incremental "
"search, the search prompt includes the input method mnemonic, like this:"
msgstr ""

#. type: example
#: search.texi.orig:286
#, no-wrap
msgid "I-search [@var{im}]:\n"
msgstr ""

#. type: findex
#: search.texi.orig:289
#, no-wrap
msgid "isearch-toggle-input-method"
msgstr ""

#. type: findex
#: search.texi.orig:290
#, no-wrap
msgid "isearch-toggle-specified-input-method"
msgstr ""

#. type: itemize
#: search.texi.orig:294
msgid ""
"where @var{im} is the mnemonic of the active input method.  Any input method "
"you enable during incremental search remains enabled in the current buffer "
"afterwards."
msgstr ""

#. type: kindex
#: search.texi.orig:296
#, no-wrap
msgid "M-% @r{(Incremental search)}"
msgstr ""

#. type: Plain text
#: search.texi.orig:301
msgid ""
"Typing @kbd{M-%} in incremental search invokes @code{query-replace} or "
"@code{query-replace-regexp} (depending on search mode) with the current "
"search string used as the string to replace.  A negative prefix argument "
"means to replace backward.  @xref{Query Replace}."
msgstr ""

#. type: kindex
#: search.texi.orig:302
#, no-wrap
msgid "M-TAB @r{(Incremental search)}"
msgstr ""

#. type: Plain text
#: search.texi.orig:310
msgid ""
"Typing @kbd{M-@key{TAB}} in incremental search invokes "
"@code{isearch-complete}, which attempts to complete the search string using "
"the search ring as a list of completion alternatives.  @xref{Completion}.  "
"In many operating systems, the @kbd{M-@key{TAB}} key sequence is captured by "
"the window manager; you then need to rebind @code{isearch-complete} to "
"another key sequence if you want to use it (@pxref{Rebinding})."
msgstr ""

#. type: vindex
#: search.texi.orig:311
#, no-wrap
msgid "isearch-mode-map"
msgstr ""

#. type: Plain text
#: search.texi.orig:316
msgid ""
"When incremental search is active, you can type @kbd{C-h C-h} to access "
"interactive help options, including a list of special key bindings.  These "
"key bindings are part of the keymap @code{isearch-mode-map} "
"(@pxref{Keymaps})."
msgstr ""

#. type: subsection
#: search.texi.orig:318
#, no-wrap
msgid "Isearch Yanking"
msgstr ""

#. type: kindex
#: search.texi.orig:320
#, no-wrap
msgid "C-y @r{(Incremental search)}"
msgstr ""

#. type: kindex
#: search.texi.orig:321
#, no-wrap
msgid "M-y @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:322
#, no-wrap
msgid "isearch-yank-kill"
msgstr ""

#. type: findex
#: search.texi.orig:323
#, no-wrap
msgid "isearch-yank-pop"
msgstr ""

#. type: Plain text
#: search.texi.orig:330
msgid ""
"Within incremental search, @kbd{C-y} (@code{isearch-yank-kill})  appends the "
"current kill to the search string.  @kbd{M-y} (@code{isearch-yank-pop}), if "
"called after @kbd{C-y}, replaces that appended text with an earlier kill, "
"similar to the usual @kbd{M-y} (@code{yank-pop}) command (@pxref{Yanking}).  "
"@kbd{Mouse-2} appends the current X selection (@pxref{Primary Selection})."
msgstr ""

#. type: kindex
#: search.texi.orig:331
#, no-wrap
msgid "C-w @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:332
#, no-wrap
msgid "isearch-yank-word-or-char"
msgstr ""

#. type: Plain text
#: search.texi.orig:337
msgid ""
"@kbd{C-w} (@code{isearch-yank-word-or-char}) appends the next character or "
"word at point to the search string.  This is an easy way to search for "
"another occurrence of the text at point.  (The decision of whether to copy a "
"character or a word is heuristic.)"
msgstr ""

#. type: kindex
#: search.texi.orig:338
#, no-wrap
msgid "M-s C-e @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:339
#, no-wrap
msgid "isearch-yank-line"
msgstr ""

#. type: Plain text
#: search.texi.orig:344
msgid ""
"Similarly, @kbd{M-s C-e} (@code{isearch-yank-line}) appends the rest of the "
"current line to the search string.  If point is already at the end of a "
"line, it appends the next line.  With a prefix argument @var{n}, it appends "
"the next @var{n} lines."
msgstr ""

#. type: Plain text
#: search.texi.orig:348
msgid ""
"If the search is currently case-insensitive, both @kbd{C-w} and @kbd{M-s "
"C-e} convert the text they copy to lower case, so that the search remains "
"case-insensitive."
msgstr ""

#. type: kindex
#: search.texi.orig:349
#, no-wrap
msgid "C-M-w @r{(Incremental search)}"
msgstr ""

#. type: kindex
#: search.texi.orig:350
#, no-wrap
msgid "C-M-y @r{(Incremental search)}"
msgstr ""

#. type: findex
#: search.texi.orig:351
#, no-wrap
msgid "isearch-del-char"
msgstr ""

#. type: findex
#: search.texi.orig:352
#, no-wrap
msgid "isearch-yank-char"
msgstr ""

#. type: Plain text
#: search.texi.orig:359
msgid ""
"@kbd{C-M-w} (@code{isearch-del-char}) deletes the last character from the "
"search string, and @kbd{C-M-y} (@code{isearch-yank-char})  appends the "
"character after point to the search string.  An alternative method to add "
"the character after point is to enter the minibuffer with @kbd{M-e} "
"(@pxref{Repeat Isearch}) and type @kbd{C-f} at the end of the search string "
"in the minibuffer."
msgstr ""

#. type: subsection
#: search.texi.orig:361
#, no-wrap
msgid "Not Exiting Incremental Search"
msgstr ""

#. type: Plain text
#: search.texi.orig:366
msgid ""
"This subsection describes two categories of commands which you can type "
"without exiting the current incremental search, even though they are not "
"themselves part of incremental search."
msgstr ""

#. type: item
#: search.texi.orig:368
#, no-wrap
msgid "Prefix Arguments"
msgstr ""

#. type: vindex
#: search.texi.orig:369
#, no-wrap
msgid "isearch-allow-prefix"
msgstr ""

#. type: table
#: search.texi.orig:373
msgid ""
"In incremental search, when you enter a prefix argument (@pxref{Arguments}), "
"by default it will apply either to the next action in the search or to the "
"command that exits the search."
msgstr ""

#. type: table
#: search.texi.orig:377
msgid ""
"In previous versions of Emacs, entering a prefix argument always terminated "
"the search.  You can revert to this behavior by setting the variable "
"@code{isearch-allow-prefix} to @code{nil}."
msgstr ""

#. type: table
#: search.texi.orig:380
msgid ""
"When @code{isearch-allow-scroll} is non-@code{nil} (see below), prefix "
"arguments always have the default behavior described above."
msgstr ""

#. type: item
#: search.texi.orig:381
#, no-wrap
msgid "Scrolling Commands"
msgstr ""

#. type: vindex
#: search.texi.orig:382
#, no-wrap
msgid "isearch-allow-scroll"
msgstr ""

#. type: table
#: search.texi.orig:391
msgid ""
"Normally, scrolling commands exit incremental search.  If you change the "
"variable @code{isearch-allow-scroll} to a non-@code{nil} value, that enables "
"the use of the scroll-bar, as well as keyboard scrolling commands like "
"@kbd{C-v}, @kbd{M-v}, and @kbd{C-l} (@pxref{Scrolling}).  This applies only "
"to calling these commands via their bound key sequences---typing @kbd{M-x} "
"will still exit the search.  You can give prefix arguments to these commands "
"in the usual way.  This feature won't let you scroll the current match out "
"of visibility, however."
msgstr ""

#. type: table
#: search.texi.orig:398
msgid ""
"The @code{isearch-allow-scroll} feature also affects some other commands, "
"such as @kbd{C-x 2} (@code{split-window-below}) and @kbd{C-x ^} "
"(@code{enlarge-window}), which don't exactly scroll but do affect where the "
"text appears on the screen.  It applies to any command whose name has a "
"non-@code{nil} @code{isearch-scroll} property.  So you can control which "
"commands are affected by changing these properties."
msgstr ""

#. type: table
#: search.texi.orig:403
msgid ""
"For example, to make @kbd{C-h l} usable within an incremental search in all "
"future Emacs sessions, use @kbd{C-h c} to find what command it runs "
"(@pxref{Key Help}), which is @code{view-lossage}.  Then you can put the "
"following line in your init file (@pxref{Init File}):"
msgstr ""

#. type: example
#: search.texi.orig:406
#, no-wrap
msgid "(put 'view-lossage 'isearch-scroll t)\n"
msgstr ""

#. type: table
#: search.texi.orig:413
msgid ""
"This feature can be applied to any command that doesn't permanently change "
"point, the buffer contents, the match data, the current buffer, or the "
"selected window and frame.  The command must not itself attempt an "
"incremental search."
msgstr ""

#. type: subsection
#: search.texi.orig:416
#, no-wrap
msgid "Searching the Minibuffer"
msgstr ""

#. type: cindex
#: search.texi.orig:417
#, no-wrap
msgid "minibuffer history, searching"
msgstr ""

#. type: Plain text
#: search.texi.orig:423
msgid ""
"If you start an incremental search while the minibuffer is active, Emacs "
"searches the contents of the minibuffer.  Unlike searching an ordinary "
"buffer, the search string is not shown in the echo area, because that is "
"used to display the minibuffer."
msgstr ""

#. type: Plain text
#: search.texi.orig:432
msgid ""
"If an incremental search fails in the minibuffer, it tries searching the "
"minibuffer history.  @xref{Minibuffer History}.  You can visualize the "
"minibuffer and its history as a series of ``pages'', with the earliest "
"history element on the first page and the current minibuffer on the last "
"page.  A forward search, @kbd{C-s}, searches forward to later pages; a "
"reverse search, @kbd{C-r}, searches backwards to earlier pages.  Like in "
"ordinary buffer search, a failing search can wrap around, going from the "
"last page to the first page or vice versa."
msgstr ""

#. type: Plain text
#: search.texi.orig:438
msgid ""
"When the current match is on a history element, that history element is "
"pulled into the minibuffer.  If you exit the incremental search normally "
"(e.g., by typing @key{RET}), it remains in the minibuffer afterwards.  "
"Canceling the search, with @kbd{C-g}, restores the contents of the "
"minibuffer when you began the search."
msgstr ""

#. type: cindex
#: search.texi.orig:441
#, no-wrap
msgid "nonincremental search"
msgstr ""

#. type: Plain text
#: search.texi.orig:445
msgid ""
"Emacs also has conventional nonincremental search commands, which require "
"you to type the entire search string before searching begins."
msgstr ""

#. type: item
#: search.texi.orig:447
#, no-wrap
msgid "C-s @key{RET} @var{string} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:449
msgid "Search for @var{string}."
msgstr ""

#. type: item
#: search.texi.orig:449
#, no-wrap
msgid "C-r @key{RET} @var{string} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:451
msgid "Search backward for @var{string}."
msgstr ""

#. type: Plain text
#: search.texi.orig:457
msgid ""
"To start a nonincremental search, first type @kbd{C-s @key{RET}}.  This "
"enters the minibuffer to read the search string; terminate the string with "
"@key{RET}, and then the search takes place.  If the string is not found, the "
"search command signals an error."
msgstr ""

#. type: findex
#: search.texi.orig:458
#, no-wrap
msgid "search-forward"
msgstr ""

#. type: findex
#: search.texi.orig:459
#, no-wrap
msgid "search-backward"
msgstr ""

#. type: Plain text
#: search.texi.orig:466
msgid ""
"When you type @kbd{C-s @key{RET}}, the @kbd{C-s} invokes incremental search "
"as usual.  That command is specially programmed to invoke the command for "
"nonincremental search, @code{search-forward}, if the string you specify is "
"empty.  (Such an empty argument would otherwise be useless.)  @kbd{C-r "
"@key{RET}} does likewise, invoking the command @code{search-backward}."
msgstr ""

#. type: cindex
#: search.texi.orig:469
#, no-wrap
msgid "word search"
msgstr ""

#. type: Plain text
#: search.texi.orig:479
msgid ""
"A @dfn{word search} finds a sequence of words without regard to the type of "
"punctuation between them.  For instance, if you enter a search string that "
"consists of two words separated by a single space, the search matches any "
"sequence of those two words separated by one or more spaces, newlines, or "
"other punctuation characters.  This is particularly useful for searching "
"text documents, because you don't have to worry whether the words you are "
"looking for are separated by newlines or spaces."
msgstr ""

#. type: kindex
#: search.texi.orig:481 search.texi.orig:491
#, no-wrap
msgid "M-s w"
msgstr ""

#. type: table
#: search.texi.orig:485
msgid ""
"If incremental search is active, toggle word search mode "
"(@code{isearch-toggle-word}); otherwise, begin an incremental forward word "
"search (@code{isearch-forward-word})."
msgstr ""

#. type: item
#: search.texi.orig:485
#, no-wrap
msgid "M-s w @key{RET} @var{words} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:487
msgid "Search for @var{words}, using a forward nonincremental word search."
msgstr ""

#. type: item
#: search.texi.orig:487
#, no-wrap
msgid "M-s w C-r @key{RET} @var{words} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:489
msgid "Search backward for @var{words}, using a nonincremental word search."
msgstr ""

#. type: findex
#: search.texi.orig:492
#, no-wrap
msgid "isearch-forward-word"
msgstr ""

#. type: Plain text
#: search.texi.orig:500
msgid ""
"To begin a forward incremental word search, type @kbd{M-s w}.  If "
"incremental search is not already active, this runs the command "
"@code{isearch-forward-word}.  If incremental search is already active "
"(whether a forward or backward search), @kbd{M-s w} switches to a word "
"search while keeping the direction of the search and the current search "
"string unchanged.  You can toggle word search back off by typing @kbd{M-s w} "
"again."
msgstr ""

#. type: findex
#: search.texi.orig:501
#, no-wrap
msgid "word-search-forward"
msgstr ""

#. type: findex
#: search.texi.orig:502
#, no-wrap
msgid "word-search-backward"
msgstr ""

#. type: Plain text
#: search.texi.orig:507
msgid ""
"To begin a nonincremental word search, type @kbd{M-s w @key{RET}} for a "
"forward search, or @kbd{M-s w C-r @key{RET}} for a backward search.  These "
"run the commands @code{word-search-forward} and @code{word-search-backward} "
"respectively."
msgstr ""

#. type: Plain text
#: search.texi.orig:516
msgid ""
"Incremental and nonincremental word searches differ slightly in the way they "
"find a match.  In a nonincremental word search, each word in the search "
"string must exactly match a whole word.  In an incremental word search, the "
"matching is more lax: while you are typing the search string, its first and "
"last words need not match whole words.  This is so that the matching can "
"proceed incrementally as you type.  This additional laxity does not apply to "
"the lazy highlight, which always matches whole words."
msgstr ""

#. type: cindex
#: search.texi.orig:519
#, no-wrap
msgid "symbol search"
msgstr ""

#. type: Plain text
#: search.texi.orig:529
msgid ""
"A @dfn{symbol search} is much like an ordinary search, except that the "
"boundaries of the search must match the boundaries of a symbol.  The meaning "
"of @dfn{symbol} in this context depends on the major mode, and usually "
"refers to a source code token, such as a Lisp symbol in Emacs Lisp mode.  "
"For instance, if you perform an incremental symbol search for the Lisp "
"symbol @code{forward-word}, it would not match @code{isearch-forward-word}.  "
"This feature is thus mainly useful for searching source code."
msgstr ""

#. type: kindex
#: search.texi.orig:531 search.texi.orig:544
#, no-wrap
msgid "M-s _"
msgstr ""

#. type: table
#: search.texi.orig:535
msgid ""
"If incremental search is active, toggle symbol search mode "
"(@code{isearch-toggle-symbol}); otherwise, begin an incremental forward "
"symbol search (@code{isearch-forward-symbol})."
msgstr ""

#. type: kindex
#: search.texi.orig:535 search.texi.orig:545
#, no-wrap
msgid "M-s ."
msgstr ""

#. type: table
#: search.texi.orig:538
msgid ""
"Start a symbol incremental search forward with the symbol found near point "
"added to the search string initially."
msgstr ""

#. type: item
#: search.texi.orig:538
#, no-wrap
msgid "M-s _ @key{RET} @var{symbol} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:540
msgid "Search forward for @var{symbol}, nonincrementally."
msgstr ""

#. type: item
#: search.texi.orig:540
#, no-wrap
msgid "M-s _ C-r @key{RET} @var{symbol} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:542
msgid "Search backward for @var{symbol}, nonincrementally."
msgstr ""

#. type: findex
#: search.texi.orig:546
#, no-wrap
msgid "isearch-forward-symbol"
msgstr ""

#. type: findex
#: search.texi.orig:547
#, no-wrap
msgid "isearch-forward-symbol-at-point"
msgstr ""

#. type: Plain text
#: search.texi.orig:557
msgid ""
"To begin a forward incremental symbol search, type @kbd{M-s _} (or @kbd{M-s "
".} if the symbol to search is near point).  If incremental search is not "
"already active, this runs the command @code{isearch-forward-symbol}.  If "
"incremental search is already active, @kbd{M-s _} switches to a symbol "
"search, preserving the direction of the search and the current search "
"string; you can disable symbol search by typing @kbd{M-s _} again.  In "
"incremental symbol search, only the beginning of the search string is "
"required to match the beginning of a symbol."
msgstr ""

#. type: Plain text
#: search.texi.orig:563
msgid ""
"To begin a nonincremental symbol search, type @kbd{M-s _ @key{RET}} for a "
"forward search, or @kbd{M-s _ C-r @key{RET}} or a backward search.  In "
"nonincremental symbol searches, the beginning and end of the search string "
"are required to match the beginning and end of a symbol, respectively."
msgstr ""

#. type: section
#: search.texi.orig:565
#, no-wrap
msgid "Regular Expression Search"
msgstr ""

#. type: cindex
#: search.texi.orig:566
#, no-wrap
msgid "regexp search"
msgstr ""

#. type: cindex
#: search.texi.orig:567
#, no-wrap
msgid "search for a regular expression"
msgstr ""

#. type: Plain text
#: search.texi.orig:574
msgid ""
"A @dfn{regular expression} (or @dfn{regexp} for short) is a pattern that "
"denotes a class of alternative strings to match.  Emacs provides both "
"incremental and nonincremental ways to search for a match for a regexp.  The "
"syntax of regular expressions is explained in the next section."
msgstr ""

#. type: kindex
#: search.texi.orig:576 search.texi.orig:582
#, no-wrap
msgid "C-M-s"
msgstr ""

#. type: table
#: search.texi.orig:578
msgid "Begin incremental regexp search (@code{isearch-forward-regexp})."
msgstr ""

#. type: kindex
#: search.texi.orig:578 search.texi.orig:584
#, no-wrap
msgid "C-M-r"
msgstr ""

#. type: table
#: search.texi.orig:580
msgid "Begin reverse incremental regexp search (@code{isearch-backward-regexp})."
msgstr ""

#. type: findex
#: search.texi.orig:583
#, no-wrap
msgid "isearch-forward-regexp"
msgstr ""

#. type: findex
#: search.texi.orig:585
#, no-wrap
msgid "isearch-backward-regexp"
msgstr ""

#. type: Plain text
#: search.texi.orig:597
msgid ""
"Incremental search for a regexp is done by typing @kbd{C-M-s} "
"(@code{isearch-forward-regexp}), by invoking @kbd{C-s} with a prefix "
"argument (whose value does not matter), or by typing @kbd{M-r} within a "
"forward incremental search.  This command reads a search string "
"incrementally just like @kbd{C-s}, but it treats the search string as a "
"regexp rather than looking for an exact match against the text in the "
"buffer.  Each time you add text to the search string, you make the regexp "
"longer, and the new regexp is searched for.  To search backward for a "
"regexp, use @kbd{C-M-r} (@code{isearch-backward-regexp}), @kbd{C-r} with a "
"prefix argument, or @kbd{M-r} within a backward incremental search."
msgstr ""

#. type: Plain text
#: search.texi.orig:605
msgid ""
"All of the special key sequences in an ordinary incremental search do "
"similar things in an incremental regexp search.  For instance, typing "
"@kbd{C-s} immediately after starting the search retrieves the last "
"incremental search regexp used and searches forward for it.  Incremental "
"regexp and non-regexp searches have independent defaults.  They also have "
"separate search rings, which you can access with @kbd{M-p} and @kbd{M-n}."
msgstr ""

#. type: Plain text
#: search.texi.orig:613
msgid ""
"Unlike ordinary incremental search, incremental regexp search do not use lax "
"space matching by default.  To toggle this feature use @kbd{M-s @key{SPC}} "
"(@code{isearch-toggle-lax-whitespace}).  Then any @key{SPC} typed in "
"incremental regexp search will match any sequence of one or more whitespace "
"characters.  The variable @code{search-whitespace-regexp} specifies the "
"regexp for the lax space matching.  @xref{Special Isearch}."
msgstr ""

#. type: Plain text
#: search.texi.orig:619
msgid ""
"In some cases, adding characters to the regexp in an incremental regexp "
"search can make the cursor move back and start again.  For example, if you "
"have searched for @samp{foo} and you add @samp{\\|bar}, the cursor backs up "
"in case the first @samp{bar} precedes the first @samp{foo}.  @xref{Regexps}."
msgstr ""

#. type: Plain text
#: search.texi.orig:626
msgid ""
"Forward and backward regexp search are not symmetrical, because regexp "
"matching in Emacs always operates forward, starting with the beginning of "
"the regexp.  Thus, forward regexp search scans forward, trying a forward "
"match at each possible starting position.  Backward regexp search scans "
"backward, trying a forward match at each possible starting position.  These "
"search methods are not mirror images."
msgstr ""

#. type: findex
#: search.texi.orig:627
#, no-wrap
msgid "re-search-forward"
msgstr ""

#. type: findex
#: search.texi.orig:628
#, no-wrap
msgid "re-search-backward"
msgstr ""

#. type: Plain text
#: search.texi.orig:633
msgid ""
"Nonincremental search for a regexp is done with the commands "
"@code{re-search-forward} and @code{re-search-backward}.  You can invoke "
"these with @kbd{M-x}, or by way of incremental regexp search with @kbd{C-M-s "
"@key{RET}} and @kbd{C-M-r @key{RET}}."
msgstr ""

#. type: Plain text
#: search.texi.orig:638
msgid ""
"If you use the incremental regexp search commands with a prefix argument, "
"they perform ordinary string search, like @code{isearch-forward} and "
"@code{isearch-backward}.  @xref{Incremental Search}."
msgstr ""

#. type: section
#: search.texi.orig:640
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr ""

#. type: cindex
#: search.texi.orig:641
#, no-wrap
msgid "syntax of regexps"
msgstr ""

#. type: cindex
#: search.texi.orig:642
#, no-wrap
msgid "regular expression"
msgstr ""

#. type: cindex
#: search.texi.orig:643
#, no-wrap
msgid "regexp"
msgstr ""

#. type: Plain text
#: search.texi.orig:649
msgid ""
"This manual describes regular expression features that users typically use.  "
"@xref{Regular Expressions,,, elisp, The Emacs Lisp Reference Manual}, for "
"additional features used mainly in Lisp programs."
msgstr ""

#. type: Plain text
#: search.texi.orig:660
msgid ""
"Regular expressions have a syntax in which a few characters are special "
"constructs and the rest are @dfn{ordinary}.  An ordinary character matches "
"that same character and nothing else.  The special characters are "
"@samp{$^.*+?[\\}.  The character @samp{]} is special if it ends a character "
"alternative (see later).  The character @samp{-} is special inside a "
"character alternative.  Any other character appearing in a regular "
"expression is ordinary, unless a @samp{\\} precedes it.  (When you use "
"regular expressions in a Lisp program, each @samp{\\} must be doubled, see "
"the example near the end of this section.)"
msgstr ""

#. type: Plain text
#: search.texi.orig:668
msgid ""
"For example, @samp{f} is not a special character, so it is ordinary, and "
"therefore @samp{f} is a regular expression that matches the string @samp{f} "
"and no other string.  (It does @emph{not} match the string @samp{ff}.)  "
"Likewise, @samp{o} is a regular expression that matches only @samp{o}.  "
"(When case distinctions are being ignored, these regexps also match @samp{F} "
"and @samp{O}, but we consider this a generalization of ``the same string'', "
"rather than an exception.)"
msgstr ""

#. type: Plain text
#: search.texi.orig:677
msgid ""
"Any two regular expressions @var{a} and @var{b} can be concatenated.  The "
"result is a regular expression which matches a string if @var{a} matches "
"some amount of the beginning of that string and @var{b} matches the rest of "
"the string.  For example, concatenating the regular expressions @samp{f} and "
"@samp{o} gives the regular expression @samp{fo}, which matches only the "
"string @samp{fo}.  Still trivial.  To do something nontrivial, you need to "
"use one of the special characters.  Here is a list of them."
msgstr ""

#. type: item
#: search.texi.orig:679
#, no-wrap
msgid "@kbd{.}@: @r{(Period)}"
msgstr ""

#. type: table
#: search.texi.orig:684
msgid ""
"is a special character that matches any single character except a newline.  "
"For example, the regular expressions @samp{a.b} matches any three-character "
"string that begins with @samp{a} and ends with @samp{b}."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:685
#, no-wrap
msgid "*"
msgstr ""

#. type: table
#: search.texi.orig:690
msgid ""
"is not a construct by itself; it is a postfix operator that means to match "
"the preceding regular expression repetitively any number of times, as many "
"times as possible.  Thus, @samp{o*} matches any number of @samp{o}s, "
"including no @samp{o}s."
msgstr ""

#. type: table
#: search.texi.orig:694
msgid ""
"@samp{*} always applies to the @emph{smallest} possible preceding "
"expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating "
"@samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr ""

#. type: table
#: search.texi.orig:705
msgid ""
"The matcher processes a @samp{*} construct by matching, immediately, as many "
"repetitions as can be found.  Then it continues with the rest of the "
"pattern.  If that fails, backtracking occurs, discarding some of the matches "
"of the @samp{*}-modified construct in case that makes it possible to match "
"the rest of the pattern.  For example, in matching @samp{ca*ar} against the "
"string @samp{caaar}, the @samp{a*} first tries to match all three @samp{a}s; "
"but the rest of the pattern is @samp{ar} and there is only @samp{r} left to "
"match, so this try fails.  The next alternative is for @samp{a*} to match "
"only two @samp{a}s.  With this choice, the rest of the regexp matches "
"successfully."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:706
#, no-wrap
msgid "+"
msgstr ""

#. type: table
#: search.texi.orig:711
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression at least once.  Thus, @samp{ca+r} matches the strings "
"@samp{car} and @samp{caaaar} but not the string @samp{cr}, whereas "
"@samp{ca*r} matches all three strings."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:712
#, no-wrap
msgid "?"
msgstr ""

#. type: table
#: search.texi.orig:716
msgid ""
"is a postfix operator, similar to @samp{*} except that it can match the "
"preceding expression either once or not at all.  Thus, @samp{ca?r} matches "
"@samp{car} or @samp{cr}, and nothing else."
msgstr ""

#. type: item
#: search.texi.orig:717
#, no-wrap
msgid "@kbd{*?}, @kbd{+?}, @kbd{??}"
msgstr ""

#. type: cindex
#: search.texi.orig:718
#, no-wrap
msgid "non-greedy regexp matching"
msgstr ""

#. type: table
#: search.texi.orig:723
msgid ""
"are non-@dfn{greedy} variants of the operators above.  The normal operators "
"@samp{*}, @samp{+}, @samp{?} match as much as they can, as long as the "
"overall regexp can still match.  With a following @samp{?}, they will match "
"as little as possible."
msgstr ""

#. type: table
#: search.texi.orig:729
msgid ""
"Thus, both @samp{ab*} and @samp{ab*?} can match the string @samp{a} and the "
"string @samp{abbbb}; but if you try to match them both against the text "
"@samp{abbb}, @samp{ab*} will match it all (the longest valid match), while "
"@samp{ab*?} will match just @samp{a} (the shortest valid match)."
msgstr ""

#. type: table
#: search.texi.orig:736
msgid ""
"Non-greedy operators match the shortest possible string starting at a given "
"starting point; in a forward search, though, the earliest possible starting "
"point for match is always the one chosen.  Thus, if you search for "
"@samp{a.*?$} against the text @samp{abbab} followed by a newline, it matches "
"the whole string.  Since it @emph{can} match starting at the first @samp{a}, "
"it does."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:737
#, no-wrap
msgid "\\@{@var{n}\\@}"
msgstr ""

#. type: table
#: search.texi.orig:742
msgid ""
"is a postfix operator specifying @var{n} repetitions---that is, the "
"preceding regular expression must match exactly @var{n} times in a row.  For "
"example, @samp{x\\@{4\\@}} matches the string @samp{xxxx} and nothing else."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:743
#, no-wrap
msgid "\\@{@var{n},@var{m}\\@}"
msgstr ""

#. type: table
#: search.texi.orig:751
msgid ""
"is a postfix operator specifying between @var{n} and @var{m} "
"repetitions---that is, the preceding regular expression must match at least "
"@var{n} times, but no more than @var{m} times.  If @var{m} is omitted, then "
"there is no upper limit, but the preceding regular expression must match at "
"least @var{n} times.@* @samp{\\@{0,1\\@}} is equivalent to @samp{?}. @* "
"@samp{\\@{0,\\@}} is equivalent to @samp{*}. @* @samp{\\@{1,\\@}} is "
"equivalent to @samp{+}."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:752
#, no-wrap
msgid "[ @dots{} ]"
msgstr ""

#. type: table
#: search.texi.orig:755
msgid ""
"is a @dfn{character set}, beginning with @samp{[} and terminated by "
"@samp{]}."
msgstr ""

#. type: table
#: search.texi.orig:762
msgid ""
"In the simplest case, the characters between the two brackets are what this "
"set can match.  Thus, @samp{[ad]} matches either one @samp{a} or one "
"@samp{d}, and @samp{[ad]*} matches any string composed of just @samp{a}s and "
"@samp{d}s (including the empty string).  It follows that @samp{c[ad]*r} "
"matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr ""

#. type: table
#: search.texi.orig:769
msgid ""
"You can also include character ranges in a character set, by writing the "
"starting and ending characters with a @samp{-} between them.  Thus, "
"@samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be "
"intermixed freely with individual characters, as in @samp{[a-z$%.]}, which "
"matches any lower-case @acronym{ASCII} letter or @samp{$}, @samp{%} or "
"period."
msgstr ""

#. type: table
#: search.texi.orig:776
msgid ""
"You can also include certain special @dfn{character classes} in a character "
"set.  A @samp{[:} and balancing @samp{:]} enclose a character class inside a "
"character alternative.  For instance, @samp{[[:alnum:]]} matches any letter "
"or digit.  @xref{Char Classes,,, elisp, The Emacs Lisp Reference Manual}, "
"for a list of character classes."
msgstr ""

#. type: table
#: search.texi.orig:782
msgid ""
"To include a @samp{]} in a character set, you must make it the first "
"character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.  To "
"include a @samp{-}, write @samp{-} as the first or last character of the "
"set, or put it after a range.  Thus, @samp{[]-]} matches both @samp{]} and "
"@samp{-}."
msgstr ""

#. type: table
#: search.texi.orig:785
msgid ""
"To include @samp{^} in a set, put it anywhere but at the beginning of the "
"set.  (At the beginning, it complements the set---see below.)"
msgstr ""

#. type: table
#: search.texi.orig:790
msgid ""
"When you use a range in case-insensitive search, you should write both ends "
"of the range in upper case, or both in lower case, or both should be "
"non-letters.  The behavior of a mixed-case range such as @samp{A-z} is "
"somewhat ill-defined, and it may change in future Emacs versions."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:791
#, no-wrap
msgid "[^ @dots{} ]"
msgstr ""

#. type: table
#: search.texi.orig:795
msgid ""
"@samp{[^} begins a @dfn{complemented character set}, which matches any "
"character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches all "
"characters @emph{except} @acronym{ASCII} letters and digits."
msgstr ""

#. type: table
#: search.texi.orig:799
msgid ""
"@samp{^} is not special in a character set unless it is the first "
"character.  The character following the @samp{^} is treated as if it were "
"first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr ""

#. type: table
#: search.texi.orig:803
msgid ""
"A complemented character set can match a newline, unless newline is "
"mentioned as one of the characters not to match.  This is in contrast to the "
"handling of regexps in programs such as @code{grep}."
msgstr ""

#. type: item
#: search.texi.orig:804 search.texi.orig:1354
#, no-wrap
msgid "^"
msgstr ""

#. type: table
#: search.texi.orig:809
msgid ""
"is a special character that matches the empty string, but only at the "
"beginning of a line in the text being matched.  Otherwise it fails to match "
"anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at the "
"beginning of a line."
msgstr ""

#. type: table
#: search.texi.orig:813
msgid ""
"For historical compatibility reasons, @samp{^} can be used with this meaning "
"only at the beginning of the regular expression, or after @samp{\\(} or "
"@samp{\\|}."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:814
#, no-wrap
msgid "$"
msgstr ""

#. type: table
#: search.texi.orig:817
msgid ""
"is similar to @samp{^} but matches only at the end of a line.  Thus, "
"@samp{x+$} matches a string of one @samp{x} or more at the end of a line."
msgstr ""

#. type: table
#: search.texi.orig:821
msgid ""
"For historical compatibility reasons, @samp{$} can be used with this meaning "
"only at the end of the regular expression, or before @samp{\\)} or "
"@samp{\\|}."
msgstr ""

#. type: kbd{#1}
#: search.texi.orig:822
#, no-wrap
msgid "\\"
msgstr ""

#. type: table
#: search.texi.orig:825
msgid ""
"has two functions: it quotes the special characters (including @samp{\\}), "
"and it introduces additional special constructs."
msgstr ""

#. type: table
#: search.texi.orig:829
msgid ""
"Because @samp{\\} quotes special characters, @samp{\\$} is a regular "
"expression that matches only @samp{$}, and @samp{\\[} is a regular "
"expression that matches only @samp{[}, and so on."
msgstr ""

#. type: table
#: search.texi.orig:832
msgid ""
"See the following section for the special constructs that begin with "
"@samp{\\}."
msgstr ""

#. type: Plain text
#: search.texi.orig:840
msgid ""
"Note: for historical compatibility, special characters are treated as "
"ordinary ones if they are in contexts where their special meanings make no "
"sense.  For example, @samp{*foo} treats @samp{*} as ordinary since there is "
"no preceding expression on which the @samp{*} can act.  It is poor practice "
"to depend on this behavior; it is better to quote the special character "
"anyway, regardless of where it appears."
msgstr ""

#. type: Plain text
#: search.texi.orig:848
msgid ""
"As a @samp{\\} is not special inside a character alternative, it can never "
"remove the special meaning of @samp{-} or @samp{]}.  So you should not quote "
"these characters when they have no special meaning either.  This would not "
"clarify anything, since backslashes can legitimately precede these "
"characters where they @emph{have} special meaning, as in @samp{[^\\]} "
"(@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single "
"character except a backslash."
msgstr ""

#. type: section
#: search.texi.orig:850
#, no-wrap
msgid "Backslash in Regular Expressions"
msgstr ""

#. type: Plain text
#: search.texi.orig:857
msgid ""
"For the most part, @samp{\\} followed by any character matches only that "
"character.  However, there are several exceptions: two-character sequences "
"starting with @samp{\\} that have special meanings.  The second character in "
"the sequence is always an ordinary character when used on its own.  Here is "
"a table of @samp{\\} constructs."
msgstr ""

#. type: item
#: search.texi.orig:859
#, no-wrap
msgid "\\|"
msgstr ""

#. type: table
#: search.texi.orig:864
msgid ""
"specifies an alternative.  Two regular expressions @var{a} and @var{b} with "
"@samp{\\|} in between form an expression that matches some text if either "
"@var{a} matches it or @var{b} matches it.  It works by trying to match "
"@var{a}, and if that fails, by trying to match @var{b}."
msgstr ""

#. type: table
#: search.texi.orig:867
msgid ""
"Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other "
"string."
msgstr ""

#. type: table
#: search.texi.orig:871
msgid ""
"@samp{\\|} applies to the largest possible surrounding expressions.  Only a "
"surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of "
"@samp{\\|}."
msgstr ""

#. type: table
#: search.texi.orig:873
msgid "Full backtracking capability exists to handle multiple uses of @samp{\\|}."
msgstr ""

#. type: item
#: search.texi.orig:874
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr ""

#. type: table
#: search.texi.orig:876
msgid "is a grouping construct that serves three purposes:"
msgstr ""

#. type: enumerate
#: search.texi.orig:881
msgid ""
"To enclose a set of @samp{\\|} alternatives for other operations.  Thus, "
"@samp{\\(foo\\|bar\\)x} matches either @samp{foox} or @samp{barx}."
msgstr ""

#. type: enumerate
#: search.texi.orig:887
msgid ""
"To enclose a complicated expression for the postfix operators @samp{*}, "
"@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches "
"@samp{bananana}, etc., with any (zero or more) number of @samp{na} strings."
msgstr ""

#. type: enumerate
#: search.texi.orig:890
msgid "To record a matched substring for future reference."
msgstr ""

#. type: table
#: search.texi.orig:897
msgid ""
"This last application is not a consequence of the idea of a parenthetical "
"grouping; it is a separate feature that is assigned as a second meaning to "
"the same @samp{\\( @dots{} \\)} construct.  In practice there is usually no "
"conflict between the two meanings; when there is a conflict, you can use a "
"``shy'' group."
msgstr ""

#. type: item
#: search.texi.orig:898
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr ""

#. type: cindex
#: search.texi.orig:899
#, no-wrap
msgid "shy group, in regexp"
msgstr ""

#. type: table
#: search.texi.orig:905
msgid ""
"specifies a ``shy'' group that does not record the matched substring; you "
"can't refer back to it with @samp{\\@var{d}}.  This is useful in "
"mechanically combining regular expressions, so that you can add groups for "
"syntactic purposes without interfering with the numbering of the groups that "
"are meant to be referred to."
msgstr ""

#. type: item
#: search.texi.orig:906
#, no-wrap
msgid "\\@var{d}"
msgstr ""

#. type: cindex
#: search.texi.orig:907
#, no-wrap
msgid "back reference, in regexp"
msgstr ""

#. type: table
#: search.texi.orig:911
msgid ""
"matches the same text that matched the @var{d}th occurrence of a @samp{\\( "
"@dots{} \\)} construct.  This is called a @dfn{back reference}."
msgstr ""

#. type: table
#: search.texi.orig:917
msgid ""
"After the end of a @samp{\\( @dots{} \\)} construct, the matcher remembers "
"the beginning and end of the text matched by that construct.  Then, later on "
"in the regular expression, you can use @samp{\\} followed by the digit "
"@var{d} to mean ``match the same text matched the @var{d}th time by the "
"@samp{\\( @dots{} \\)} construct''."
msgstr ""

#. type: table
#: search.texi.orig:923
msgid ""
"The strings matching the first nine @samp{\\( @dots{} \\)} constructs "
"appearing in a regular expression are assigned numbers 1 through 9 in the "
"order that the open-parentheses appear in the regular expression.  So you "
"can use @samp{\\1} through @samp{\\9} to refer to the text matched by the "
"corresponding @samp{\\( @dots{} \\)} constructs."
msgstr ""

#. type: table
#: search.texi.orig:928
msgid ""
"For example, @samp{\\(.*\\)\\1} matches any newline-free string that is "
"composed of two identical halves.  The @samp{\\(.*\\)} matches the first "
"half, which may be anything, but the @samp{\\1} that follows must match the "
"same exact text."
msgstr ""

#. type: table
#: search.texi.orig:932
msgid ""
"If a particular @samp{\\( @dots{} \\)} construct matches more than once "
"(which can easily happen if it is followed by @samp{*}), only the last match "
"is recorded."
msgstr ""

#. type: item
#: search.texi.orig:933
#, no-wrap
msgid "\\`"
msgstr ""

#. type: table
#: search.texi.orig:936
msgid ""
"matches the empty string, but only at the beginning of the string or buffer "
"(or its accessible portion) being matched against."
msgstr ""

#. type: item
#: search.texi.orig:937
#, no-wrap
msgid "\\'"
msgstr ""

#. type: table
#: search.texi.orig:940
msgid ""
"matches the empty string, but only at the end of the string or buffer (or "
"its accessible portion) being matched against."
msgstr ""

#. type: item
#: search.texi.orig:941
#, no-wrap
msgid "\\="
msgstr ""

#. type: table
#: search.texi.orig:943
msgid "matches the empty string, but only at point."
msgstr ""

#. type: item
#: search.texi.orig:944
#, no-wrap
msgid "\\b"
msgstr ""

#. type: table
#: search.texi.orig:949
msgid ""
"matches the empty string, but only at the beginning or end of a word.  Thus, "
"@samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  "
"@samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr ""

#. type: table
#: search.texi.orig:952
msgid ""
"@samp{\\b} matches at the beginning or end of the buffer regardless of what "
"text appears next to it."
msgstr ""

#. type: item
#: search.texi.orig:953
#, no-wrap
msgid "\\B"
msgstr ""

#. type: table
#: search.texi.orig:956
msgid "matches the empty string, but @emph{not} at the beginning or end of a word."
msgstr ""

#. type: item
#: search.texi.orig:957
#, no-wrap
msgid "\\<"
msgstr ""

#. type: table
#: search.texi.orig:961
msgid ""
"matches the empty string, but only at the beginning of a word.  @samp{\\<} "
"matches at the beginning of the buffer only if a word-constituent character "
"follows."
msgstr ""

#. type: item
#: search.texi.orig:962
#, no-wrap
msgid "\\>"
msgstr ""

#. type: table
#: search.texi.orig:966
msgid ""
"matches the empty string, but only at the end of a word.  @samp{\\>} matches "
"at the end of the buffer only if the contents end with a word-constituent "
"character."
msgstr ""

#. type: item
#: search.texi.orig:967
#, no-wrap
msgid "\\w"
msgstr ""

#. type: table
#: search.texi.orig:971
msgid ""
"matches any word-constituent character.  The syntax table determines which "
"characters these are.  @xref{Syntax Tables,, Syntax Tables, elisp, The Emacs "
"Lisp Reference Manual}."
msgstr ""

#. type: item
#: search.texi.orig:972
#, no-wrap
msgid "\\W"
msgstr ""

#. type: table
#: search.texi.orig:974
msgid "matches any character that is not a word-constituent."
msgstr ""

#. type: item
#: search.texi.orig:975
#, no-wrap
msgid "\\_<"
msgstr ""

#. type: table
#: search.texi.orig:981
msgid ""
"matches the empty string, but only at the beginning of a symbol.  A symbol "
"is a sequence of one or more symbol-constituent characters.  A "
"symbol-constituent character is a character whose syntax is either @samp{w} "
"or @samp{_}.  @samp{\\_<} matches at the beginning of the buffer only if a "
"symbol-constituent character follows."
msgstr ""

#. type: item
#: search.texi.orig:982
#, no-wrap
msgid "\\_>"
msgstr ""

#. type: table
#: search.texi.orig:986
msgid ""
"matches the empty string, but only at the end of a symbol.  @samp{\\_>} "
"matches at the end of the buffer only if the contents end with a "
"symbol-constituent character."
msgstr ""

#. type: item
#: search.texi.orig:987
#, no-wrap
msgid "\\s@var{c}"
msgstr ""

#. type: table
#: search.texi.orig:993
msgid ""
"matches any character whose syntax is @var{c}.  Here @var{c} is a character "
"that designates a particular syntax class: thus, @samp{w} for word "
"constituent, @samp{-} or @samp{ } for whitespace, @samp{.} for ordinary "
"punctuation, etc.  @xref{Syntax Tables,, Syntax Tables, elisp, The Emacs "
"Lisp Reference Manual}."
msgstr ""

#. type: item
#: search.texi.orig:994
#, no-wrap
msgid "\\S@var{c}"
msgstr ""

#. type: table
#: search.texi.orig:996
msgid "matches any character whose syntax is not @var{c}."
msgstr ""

#. type: cindex
#: search.texi.orig:997
#, no-wrap
msgid "categories of characters"
msgstr ""

#. type: cindex
#: search.texi.orig:998
#, no-wrap
msgid "characters which belong to a specific language"
msgstr ""

#. type: findex
#: search.texi.orig:999
#, no-wrap
msgid "describe-categories"
msgstr ""

#. type: item
#: search.texi.orig:1000
#, no-wrap
msgid "\\c@var{c}"
msgstr ""

#. type: table
#: search.texi.orig:1005
msgid ""
"matches any character that belongs to the category @var{c}.  For example, "
"@samp{\\cc} matches Chinese characters, @samp{\\cg} matches Greek "
"characters, etc.  For the description of the known categories, type @kbd{M-x "
"describe-categories @key{RET}}."
msgstr ""

#. type: item
#: search.texi.orig:1006
#, no-wrap
msgid "\\C@var{c}"
msgstr ""

#. type: table
#: search.texi.orig:1009
msgid "matches any character that does @emph{not} belong to category @var{c}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1014
msgid ""
"The constructs that pertain to words and syntax are controlled by the "
"setting of the syntax table.  @xref{Syntax Tables,, Syntax Tables, elisp, "
"The Emacs Lisp Reference Manual}."
msgstr ""

#. type: section
#: search.texi.orig:1016
#, no-wrap
msgid "Regular Expression Example"
msgstr ""

#. type: Plain text
#: search.texi.orig:1021
msgid ""
"Here is an example of a regexp---similar to the regexp that Emacs uses, by "
"default, to recognize the end of a sentence, not including the following "
"space (i.e., the variable @code{sentence-end-base}):"
msgstr ""

#. type: verbatim
#: search.texi.orig:1025
#, no-wrap
msgid "[.?!][]\\\"')}]*\n"
msgstr ""

#. type: Plain text
#: search.texi.orig:1032
msgid ""
"This contains two parts in succession: a character set matching period, "
"@samp{?}, or @samp{!}, and a character set matching close-brackets, quotes, "
"or parentheses, repeated zero or more times."
msgstr ""

#. type: section
#: search.texi.orig:1034
#, no-wrap
msgid "Searching and Case"
msgstr ""

#. type: Plain text
#: search.texi.orig:1042
msgid ""
"Searches in Emacs normally ignore the case of the text they are searching "
"through, if you specify the text in lower case.  Thus, if you specify "
"searching for @samp{foo}, then @samp{Foo} and @samp{foo} also match.  "
"Regexps, and in particular character sets, behave likewise: @samp{[ab]} "
"matches @samp{a} or @samp{A} or @samp{b} or @samp{B}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1048
msgid ""
"An upper-case letter anywhere in the incremental search string makes the "
"search case-sensitive.  Thus, searching for @samp{Foo} does not find "
"@samp{foo} or @samp{FOO}.  This applies to regular expression search as well "
"as to string search.  The effect ceases if you delete the upper-case letter "
"from the search string."
msgstr ""

#. type: vindex
#: search.texi.orig:1049
#, no-wrap
msgid "case-fold-search"
msgstr ""

#. type: Plain text
#: search.texi.orig:1057
msgid ""
"If you set the variable @code{case-fold-search} to @code{nil}, then all "
"letters must match exactly, including case.  This is a per-buffer variable; "
"altering the variable normally affects only the current buffer, unless you "
"change its default value.  @xref{Locals}.  This variable applies to "
"nonincremental searches also, including those performed by the replace "
"commands (@pxref{Replace}) and the minibuffer history matching commands "
"(@pxref{Minibuffer History})."
msgstr ""

#. type: Plain text
#: search.texi.orig:1064
msgid ""
"Typing @kbd{M-c} within an incremental search toggles the case sensitivity "
"of that search.  The effect does not extend beyond the current incremental "
"search to the next one, but it does override the effect of adding or "
"removing an upper-case letter in the current search."
msgstr ""

#. type: Plain text
#: search.texi.orig:1070
msgid ""
"Several related variables control case-sensitivity of searching and matching "
"for specific commands or activities.  For instance, "
"@code{tags-case-fold-search} controls case sensitivity for @code{find-tag}.  "
"To find these variables, do @kbd{M-x apropos-variable @key{RET} "
"case-fold-search @key{RET}}."
msgstr ""

#. type: section
#: search.texi.orig:1072
#, no-wrap
msgid "Replacement Commands"
msgstr ""

#. type: cindex
#: search.texi.orig:1073
#, no-wrap
msgid "replacement"
msgstr ""

#. type: cindex
#: search.texi.orig:1074
#, no-wrap
msgid "search-and-replace commands"
msgstr ""

#. type: cindex
#: search.texi.orig:1075
#, no-wrap
msgid "string substitution"
msgstr ""

#. type: cindex
#: search.texi.orig:1076
#, no-wrap
msgid "global substitution"
msgstr ""

#. type: Plain text
#: search.texi.orig:1082
msgid ""
"Emacs provides several commands for performing search-and-replace "
"operations.  In addition to the simple @kbd{M-x replace-string} command, "
"there is @kbd{M-%} (@code{query-replace}), which presents each occurrence of "
"the pattern and asks you whether to replace it."
msgstr ""

#. type: Plain text
#: search.texi.orig:1089
msgid ""
"The replace commands normally operate on the text from point to the end of "
"the buffer.  When the region is active, they operate on it instead "
"(@pxref{Mark}).  The basic replace commands replace one @dfn{search string} "
"(or regexp) with one @dfn{replacement string}.  It is possible to perform "
"several replacements in parallel, using the command "
"@code{expand-region-abbrevs} (@pxref{Expanding Abbrevs})."
msgstr ""

#. type: vindex
#: search.texi.orig:1090
#, no-wrap
msgid "replace-lax-whitespace"
msgstr ""

#. type: Plain text
#: search.texi.orig:1096
msgid ""
"Unlike incremental search, the replacement commands do not use lax space "
"matching (@pxref{Special Isearch}) by default.  To enable lax space matching "
"for replacement, change the variable @code{replace-lax-whitespace} to "
"@code{t}.  (This only affects how Emacs finds the text to replace, not the "
"replacement text.)"
msgstr ""

#. type: node
#: search.texi.orig:1102 search.texi.orig:1104
#, no-wrap
msgid "Unconditional Replace"
msgstr ""

#. type: menuentry
#: search.texi.orig:1102
msgid "Replacing all matches for a string."
msgstr ""

#. type: node
#: search.texi.orig:1102 search.texi.orig:1134
#, no-wrap
msgid "Regexp Replace"
msgstr ""

#. type: menuentry
#: search.texi.orig:1102
msgid "Replacing all matches for a regexp."
msgstr ""

#. type: node
#: search.texi.orig:1102 search.texi.orig:1221
#, no-wrap
msgid "Replacement and Case"
msgstr ""

#. type: menuentry
#: search.texi.orig:1102
msgid "How replacements preserve case of letters."
msgstr ""

#. type: subsection
#: search.texi.orig:1102 search.texi.orig:1253 search.texi.orig:1254
#, no-wrap
msgid "Query Replace"
msgstr ""

#. type: menuentry
#: search.texi.orig:1102
msgid "How to use querying."
msgstr ""

#. type: subsection
#: search.texi.orig:1105
#, no-wrap
msgid "Unconditional Replacement"
msgstr ""

#. type: findex
#: search.texi.orig:1106
#, no-wrap
msgid "replace-string"
msgstr ""

#. type: item
#: search.texi.orig:1109
#, no-wrap
msgid ""
"M-x replace-string @key{RET} @var{string} @key{RET} @var{newstring} "
"@key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:1111
msgid "Replace every occurrence of @var{string} with @var{newstring}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1121
msgid ""
"To replace every instance of @samp{foo} after point with @samp{bar}, use the "
"command @kbd{M-x replace-string} with the two arguments @samp{foo} and "
"@samp{bar}.  Replacement happens only in the text after point, so if you "
"want to cover the whole buffer you must go to the beginning first.  All "
"occurrences up to the end of the buffer are replaced; to limit replacement "
"to part of the buffer, activate the region around that part.  When the "
"region is active, replacement is limited to the region (@pxref{Mark})."
msgstr ""

#. type: Plain text
#: search.texi.orig:1127
msgid ""
"When @code{replace-string} exits, it leaves point at the last occurrence "
"replaced.  It adds the prior position of point (where the "
"@code{replace-string} command was issued) to the mark ring, without "
"activating the mark; use @kbd{C-u C-@key{SPC}} to move back there.  "
"@xref{Mark Ring}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1130
msgid ""
"A prefix argument restricts replacement to matches that are surrounded by "
"word boundaries."
msgstr ""

#. type: Plain text
#: search.texi.orig:1133
msgid ""
"@xref{Replacement and Case}, for details about case-sensitivity in replace "
"commands."
msgstr ""

#. type: subsection
#: search.texi.orig:1135
#, no-wrap
msgid "Regexp Replacement"
msgstr ""

#. type: findex
#: search.texi.orig:1136
#, no-wrap
msgid "replace-regexp"
msgstr ""

#. type: Plain text
#: search.texi.orig:1141
msgid ""
"The @kbd{M-x replace-string} command replaces exact matches for a single "
"string.  The similar command @kbd{M-x replace-regexp} replaces any match for "
"a specified pattern."
msgstr ""

#. type: item
#: search.texi.orig:1143
#, no-wrap
msgid ""
"M-x replace-regexp @key{RET} @var{regexp} @key{RET} @var{newstring} "
"@key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:1145
msgid "Replace every match for @var{regexp} with @var{newstring}."
msgstr ""

#. type: cindex
#: search.texi.orig:1147
#, no-wrap
msgid "back reference, in regexp replacement"
msgstr ""

#. type: Plain text
#: search.texi.orig:1158
msgid ""
"In @code{replace-regexp}, the @var{newstring} need not be constant: it can "
"refer to all or part of what is matched by the @var{regexp}.  @samp{\\&} in "
"@var{newstring} stands for the entire match being replaced.  "
"@samp{\\@var{d}} in @var{newstring}, where @var{d} is a digit, stands for "
"whatever matched the @var{d}th parenthesized grouping in @var{regexp}.  "
"(This is called a ``back reference''.)  @samp{\\#} refers to the count of "
"replacements already made in this command, as a decimal number.  In the "
"first replacement, @samp{\\#} stands for @samp{0}; in the second, for "
"@samp{1}; and so on.  For example,"
msgstr ""

#. type: example
#: search.texi.orig:1161
#, no-wrap
msgid "M-x replace-regexp @key{RET} c[ad]+r @key{RET} \\&-safe @key{RET}\n"
msgstr ""

#. type: Plain text
#: search.texi.orig:1166
msgid ""
"replaces (for example) @samp{cadr} with @samp{cadr-safe} and @samp{cddr} "
"with @samp{cddr-safe}."
msgstr ""

#. type: example
#: search.texi.orig:1169
#, no-wrap
msgid "M-x replace-regexp @key{RET} \\(c[ad]+r\\)-safe @key{RET} \\1 @key{RET}\n"
msgstr ""

#. type: Plain text
#: search.texi.orig:1174
msgid ""
"performs the inverse transformation.  To include a @samp{\\} in the text to "
"replace with, you must enter @samp{\\\\}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1179
msgid ""
"If you want to enter part of the replacement string by hand each time, use "
"@samp{\\?} in the replacement string.  Each replacement will ask you to edit "
"the replacement string in the minibuffer, putting point where the @samp{\\?} "
"was."
msgstr ""

#. type: Plain text
#: search.texi.orig:1182
msgid ""
"The remainder of this subsection is intended for specialized tasks and "
"requires knowledge of Lisp.  Most readers can skip it."
msgstr ""

#. type: Plain text
#: search.texi.orig:1192
msgid ""
"You can use Lisp expressions to calculate parts of the replacement string.  "
"To do this, write @samp{\\,} followed by the expression in the replacement "
"string.  Each replacement calculates the value of the expression and "
"converts it to text without quoting (if it's a string, this means using the "
"string's contents), and uses it in the replacement string in place of the "
"expression itself.  If the expression is a symbol, one space in the "
"replacement string after the symbol name goes with the symbol name, so the "
"value replaces them both."
msgstr ""

#. type: Plain text
#: search.texi.orig:1201
msgid ""
"Inside such an expression, you can use some special sequences.  @samp{\\&} "
"and @samp{\\@var{n}} refer here, as usual, to the entire match as a string, "
"and to a submatch as a string.  @var{n} may be multiple digits, and the "
"value of @samp{\\@var{n}} is @code{nil} if subexpression @var{n} did not "
"match.  You can also use @samp{\\#&} and @samp{\\#@var{n}} to refer to those "
"matches as numbers (this is valid when the match or submatch has the form of "
"a numeral).  @samp{\\#} here too stands for the number of already-completed "
"replacements."
msgstr ""

#. type: Plain text
#: search.texi.orig:1204
msgid ""
"Repeating our example to exchange @samp{x} and @samp{y}, we can thus do it "
"also this way:"
msgstr ""

#. type: example
#: search.texi.orig:1208
#, no-wrap
msgid ""
"M-x replace-regexp @key{RET} \\(x\\)\\|y @key{RET}\n"
"\\,(if \\1 \"y\" \"x\") @key{RET}\n"
msgstr ""

#. type: Plain text
#: search.texi.orig:1215
msgid ""
"For computing replacement strings for @samp{\\,}, the @code{format} function "
"is often useful (@pxref{Formatting Strings,,, elisp, The Emacs Lisp "
"Reference Manual}).  For example, to add consecutively numbered strings like "
"@samp{ABC00042} to columns 73 @w{to 80} (unless they are already occupied), "
"you can use"
msgstr ""

#. type: example
#: search.texi.orig:1219
#, no-wrap
msgid ""
"M-x replace-regexp @key{RET} ^.\\@{0,72\\@}$ @key{RET}\n"
"\\,(format \"%-72sABC%05d\" \\& \\#) @key{RET}\n"
msgstr ""

#. type: subsection
#: search.texi.orig:1222
#, no-wrap
msgid "Replace Commands and Case"
msgstr ""

#. type: Plain text
#: search.texi.orig:1229
msgid ""
"If the first argument of a replace command is all lower case, the command "
"ignores case while searching for occurrences to replace---provided "
"@code{case-fold-search} is non-@code{nil}.  If @code{case-fold-search} is "
"set to @code{nil}, case is always significant in all searches."
msgstr ""

#. type: vindex
#: search.texi.orig:1230
#, no-wrap
msgid "case-replace"
msgstr ""

#. type: Plain text
#: search.texi.orig:1234
msgid ""
"In addition, when the @var{newstring} argument is all or partly lower case, "
"replacement commands try to preserve the case pattern of each occurrence.  "
"Thus, the command"
msgstr ""

#. type: example
#: search.texi.orig:1237
#, no-wrap
msgid "M-x replace-string @key{RET} foo @key{RET} bar @key{RET}\n"
msgstr ""

#. type: Plain text
#: search.texi.orig:1245
msgid ""
"replaces a lower case @samp{foo} with a lower case @samp{bar}, an all-caps "
"@samp{FOO} with @samp{BAR}, and a capitalized @samp{Foo} with @samp{Bar}.  "
"(These three alternatives---lower case, all caps, and capitalized, are the "
"only ones that @code{replace-string} can distinguish.)"
msgstr ""

#. type: Plain text
#: search.texi.orig:1252
msgid ""
"If upper-case letters are used in the replacement string, they remain upper "
"case every time that text is inserted.  If upper-case letters are used in "
"the first argument, the second argument is always substituted exactly as "
"given, with no case conversion.  Likewise, if either @code{case-replace} or "
"@code{case-fold-search} is set to @code{nil}, replacement is done without "
"case conversion."
msgstr ""

#. type: cindex
#: search.texi.orig:1255
#, no-wrap
msgid "query replace"
msgstr ""

#. type: item
#: search.texi.orig:1258
#, no-wrap
msgid "M-% @var{string} @key{RET} @var{newstring} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:1260
msgid "Replace some occurrences of @var{string} with @var{newstring}."
msgstr ""

#. type: item
#: search.texi.orig:1260
#, no-wrap
msgid "C-M-% @var{regexp} @key{RET} @var{newstring} @key{RET}"
msgstr ""

#. type: table
#: search.texi.orig:1262
msgid "Replace some matches for @var{regexp} with @var{newstring}."
msgstr ""

#. type: kindex
#: search.texi.orig:1264
#, no-wrap
msgid "M-%"
msgstr ""

#. type: findex
#: search.texi.orig:1265
#, no-wrap
msgid "query-replace"
msgstr ""

#. type: Plain text
#: search.texi.orig:1276
msgid ""
"If you want to change only some of the occurrences of @samp{foo} to "
"@samp{bar}, not all of them, use @kbd{M-%} (@code{query-replace}).  This "
"command finds occurrences of @samp{foo} one by one, displays each occurrence "
"and asks you whether to replace it.  Aside from querying, "
"@code{query-replace} works just like @code{replace-string} "
"(@pxref{Unconditional Replace}).  In particular, it preserves case provided "
"@code{case-replace} is non-@code{nil}, as it normally is (@pxref{Replacement "
"and Case}).  A numeric argument means to consider only occurrences that are "
"bounded by word-delimiter characters.  A negative prefix argument replaces "
"backward."
msgstr ""

#. type: kindex
#: search.texi.orig:1277
#, no-wrap
msgid "C-M-%"
msgstr ""

#. type: findex
#: search.texi.orig:1278
#, no-wrap
msgid "query-replace-regexp"
msgstr ""

#. type: Plain text
#: search.texi.orig:1282
msgid ""
"@kbd{C-M-%} performs regexp search and replace "
"(@code{query-replace-regexp}).  It works like @code{replace-regexp} except "
"that it queries like @code{query-replace}."
msgstr ""

#. type: cindex
#: search.texi.orig:1283
#, no-wrap
msgid "faces for highlighting query replace"
msgstr ""

#. type: cindex
#: search.texi.orig:1284
#, no-wrap
msgid "query-replace face"
msgstr ""

#. type: cindex
#: search.texi.orig:1285
#, no-wrap
msgid "lazy-highlight face"
msgstr ""

#. type: Plain text
#: search.texi.orig:1294
msgid ""
"These commands highlight the current match using the face "
"@code{query-replace}.  They highlight other matches using "
"@code{lazy-highlight} just like incremental search (@pxref{Incremental "
"Search}).  By default, @code{query-replace-regexp} will show the substituted "
"replacement string for the current match in the minibuffer.  If you want to "
"keep special sequences @samp{\\&} and @samp{\\@var{n}} unexpanded, customize "
"@code{query-replace-show-replacement} variable."
msgstr ""

#. type: Plain text
#: search.texi.orig:1297
msgid ""
"The characters you can type when you are shown a match for the string or "
"regexp are:"
msgstr ""

#. type: kindex
#: search.texi.orig:1299
#, no-wrap
msgid "SPC @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1300
#, no-wrap
msgid "DEL @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1301
#, no-wrap
msgid ", @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1302
#, no-wrap
msgid "RET @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1303
#, no-wrap
msgid ". @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1304
#, no-wrap
msgid "! @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1305
#, no-wrap
msgid "^ @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1306
#, no-wrap
msgid "C-r @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1307
#, no-wrap
msgid "C-w @r{(query-replace)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1308
#, no-wrap
msgid "C-l @r{(query-replace)}"
msgstr ""

#. type: key{#1}
#: search.texi.orig:1313
#, no-wrap
msgid "SPC"
msgstr ""

#. type: table
#: search.texi.orig:1315
msgid "to replace the occurrence with @var{newstring}."
msgstr ""

#. type: key{#1}
#: search.texi.orig:1316
#, no-wrap
msgid "DEL"
msgstr ""

#. type: table
#: search.texi.orig:1318
msgid "to skip to the next occurrence without replacing this one."
msgstr ""

#. type: item
#: search.texi.orig:1319
#, no-wrap
msgid ", @r{(Comma)}"
msgstr ""

#. type: table
#: search.texi.orig:1324
msgid ""
"to replace this occurrence and display the result.  You are then asked for "
"another input character to say what to do next.  Since the replacement has "
"already been made, @key{DEL} and @key{SPC} are equivalent in this situation; "
"both move to the next occurrence."
msgstr ""

#. type: table
#: search.texi.orig:1330
msgid ""
"You can type @kbd{C-r} at this point (see below) to alter the replaced "
"text.  You can also type @kbd{C-x u} to undo the replacement; this exits the "
"@code{query-replace}, so if you want to do further replacement you must use "
"@kbd{C-x @key{ESC} @key{ESC} @key{RET}} to restart (@pxref{Repetition})."
msgstr ""

#. type: key{#1}
#: search.texi.orig:1331
#, no-wrap
msgid "RET"
msgstr ""

#. type: table
#: search.texi.orig:1333
msgid "to exit without doing any more replacements."
msgstr ""

#. type: item
#: search.texi.orig:1334
#, no-wrap
msgid ".@: @r{(Period)}"
msgstr ""

#. type: table
#: search.texi.orig:1337
msgid ""
"to replace this occurrence and then exit without searching for more "
"occurrences."
msgstr ""

#. type: item
#: search.texi.orig:1338
#, no-wrap
msgid "!"
msgstr ""

#. type: table
#: search.texi.orig:1340
msgid "to replace all remaining occurrences without asking again."
msgstr ""

#. type: item
#: search.texi.orig:1341
#, no-wrap
msgid "Y @r{(Upper-case)}"
msgstr ""

#. type: table
#: search.texi.orig:1347
msgid ""
"to replace all remaining occurrences in all remaining buffers in "
"multi-buffer replacements (like the Dired @key{Q} command that performs "
"query replace on selected files).  It answers this question and all "
"subsequent questions in the series with \"yes\", without further user "
"interaction."
msgstr ""

#. type: item
#: search.texi.orig:1348
#, no-wrap
msgid "N @r{(Upper-case)}"
msgstr ""

#. type: table
#: search.texi.orig:1353
msgid ""
"to skip to the next buffer in multi-buffer replacements without replacing "
"remaining occurrences in the current buffer.  It answers this question "
"\"no\", gives up on the questions for the current buffer, and continues to "
"the next buffer in the sequence."
msgstr ""

#. type: table
#: search.texi.orig:1358
msgid ""
"to go back to the position of the previous occurrence (or what used to be an "
"occurrence), in case you changed it by mistake or want to reexamine it."
msgstr ""

#. type: table
#: search.texi.orig:1364
msgid ""
"to enter a recursive editing level, in case the occurrence needs to be "
"edited rather than just replaced with @var{newstring}.  When you are done, "
"exit the recursive editing level with @kbd{C-M-c} to proceed to the next "
"occurrence.  @xref{Recursive Edit}."
msgstr ""

#. type: item
#: search.texi.orig:1365
#, no-wrap
msgid "C-w"
msgstr ""

#. type: table
#: search.texi.orig:1370
msgid ""
"to delete the occurrence, and then enter a recursive editing level as in "
"@kbd{C-r}.  Use the recursive edit to insert text to replace the deleted "
"occurrence of @var{string}.  When done, exit the recursive editing level "
"with @kbd{C-M-c} to proceed to the next occurrence."
msgstr ""

#. type: item
#: search.texi.orig:1371
#, no-wrap
msgid "e"
msgstr ""

#. type: table
#: search.texi.orig:1376
msgid ""
"to edit the replacement string in the minibuffer.  When you exit the "
"minibuffer by typing @key{RET}, the minibuffer contents replace the current "
"occurrence of the pattern.  They also become the new replacement string for "
"any further occurrences."
msgstr ""

#. type: item
#: search.texi.orig:1377
#, no-wrap
msgid "C-l"
msgstr ""

#. type: table
#: search.texi.orig:1380
msgid ""
"to redisplay the screen.  Then you must type another character to specify "
"what to do with this occurrence."
msgstr ""

#. type: item
#: search.texi.orig:1381
#, no-wrap
msgid "C-h"
msgstr ""

#. type: table
#: search.texi.orig:1384
msgid ""
"to display a message summarizing these options.  Then you must type another "
"character to specify what to do with this occurrence."
msgstr ""

#. type: Plain text
#: search.texi.orig:1389
msgid ""
"Some other characters are aliases for the ones listed above: @kbd{y}, "
"@kbd{n} and @kbd{q} are equivalent to @key{SPC}, @key{DEL} and @key{RET}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1394
msgid ""
"Aside from this, any other character exits the @code{query-replace}, and is "
"then reread as part of a key sequence.  Thus, if you type @kbd{C-k}, it "
"exits the @code{query-replace} and then kills to end of line."
msgstr ""

#. type: Plain text
#: search.texi.orig:1399
msgid ""
"To restart a @code{query-replace} once it is exited, use @kbd{C-x @key{ESC} "
"@key{ESC}}, which repeats the @code{query-replace} because it used the "
"minibuffer to read its arguments.  @xref{Repetition, C-x ESC ESC}."
msgstr ""

#. type: cindex
#: search.texi.orig:1400
#, no-wrap
msgid "invisible text, and query-replace"
msgstr ""

#. type: Plain text
#: search.texi.orig:1403
msgid ""
"The option @code{search-invisible} determines how @code{query-replace} "
"treats invisible text.  @xref{Outline Search}."
msgstr ""

#. type: Plain text
#: search.texi.orig:1408
msgid ""
"@xref{Operating on Files}, for the Dired @kbd{Q} command which performs "
"query replace on selected files.  See also @ref{Transforming File Names}, "
"for Dired commands to rename, copy, or link files by replacing regexp "
"matches in file names."
msgstr ""

#. type: section
#: search.texi.orig:1410
#, no-wrap
msgid "Other Search-and-Loop Commands"
msgstr ""

#. type: Plain text
#: search.texi.orig:1417
msgid ""
"Here are some other commands that find matches for a regular expression.  "
"They all ignore case in matching, if the pattern contains no upper-case "
"letters and @code{case-fold-search} is non-@code{nil}.  Aside from "
"@code{occur} and its variants, all operate on the text from point to the end "
"of the buffer, or on the region if it is active."
msgstr ""

#. type: findex
#: search.texi.orig:1418
#, no-wrap
msgid "list-matching-lines"
msgstr ""

#. type: findex
#: search.texi.orig:1419
#, no-wrap
msgid "occur"
msgstr ""

#. type: findex
#: search.texi.orig:1420
#, no-wrap
msgid "multi-occur"
msgstr ""

#. type: findex
#: search.texi.orig:1421
#, no-wrap
msgid "multi-occur-in-matching-buffers"
msgstr ""

#. type: findex
#: search.texi.orig:1422
#, no-wrap
msgid "how-many"
msgstr ""

#. type: findex
#: search.texi.orig:1423
#, no-wrap
msgid "flush-lines"
msgstr ""

#. type: findex
#: search.texi.orig:1424
#, no-wrap
msgid "keep-lines"
msgstr ""

#. type: item
#: search.texi.orig:1427
#, no-wrap
msgid "M-x multi-isearch-buffers"
msgstr ""

#. type: table
#: search.texi.orig:1434
msgid ""
"Prompt for one or more buffer names, ending with @key{RET}; then, begin a "
"multi-buffer incremental search in those buffers.  (If the search fails in "
"one buffer, the next @kbd{C-s} tries searching the next specified buffer, "
"and so forth.)  With a prefix argument, prompt for a regexp and begin a "
"multi-buffer incremental search in buffers matching that regexp."
msgstr ""

#. type: item
#: search.texi.orig:1435
#, no-wrap
msgid "M-x multi-isearch-buffers-regexp"
msgstr ""

#. type: table
#: search.texi.orig:1438
msgid ""
"This command is just like @code{multi-isearch-buffers}, except it performs "
"an incremental regexp search."
msgstr ""

#. type: cindex
#: search.texi.orig:1439
#, no-wrap
msgid "Occur mode"
msgstr ""

#. type: cindex
#: search.texi.orig:1440
#, no-wrap
msgid "mode, Occur"
msgstr ""

#. type: item
#: search.texi.orig:1441
#, no-wrap
msgid "M-x occur"
msgstr ""

#. type: table
#: search.texi.orig:1447
msgid ""
"Prompt for a regexp, and display a list showing each line in the buffer that "
"contains a match for it.  To limit the search to part of the buffer, narrow "
"to that part (@pxref{Narrowing}).  A numeric argument @var{n} specifies that "
"@var{n} lines of context are to be displayed before and after each matching "
"line."
msgstr ""

#. type: kindex
#: search.texi.orig:1448
#, no-wrap
msgid "RET @r{(Occur mode)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1449
#, no-wrap
msgid "o @r{(Occur mode)}"
msgstr ""

#. type: kindex
#: search.texi.orig:1450
#, no-wrap
msgid "C-o @r{(Occur mode)}"
msgstr ""

#. type: table
#: search.texi.orig:1457
msgid ""
"In the @file{*Occur*} buffer, you can click on each entry, or move point "
"there and type @key{RET}, to visit the corresponding position in the buffer "
"that was searched.  @kbd{o} and @kbd{C-o} display the match in another "
"window; @kbd{C-o} does not select it.  Alternatively, you can use the "
"@kbd{C-x `} (@code{next-error}) command to visit the occurrences one by one "
"(@pxref{Compilation Mode})."
msgstr ""

#. type: cindex
#: search.texi.orig:1458
#, no-wrap
msgid "Occur Edit mode"
msgstr ""

#. type: cindex
#: search.texi.orig:1459
#, no-wrap
msgid "mode, Occur Edit"
msgstr ""

#. type: table
#: search.texi.orig:1464
msgid ""
"Typing @kbd{e} in the @file{*Occur*} buffer switches to Occur Edit mode, in "
"which edits made to the entries are also applied to the text in the "
"originating buffer.  Type @kbd{C-c C-c} to return to Occur mode."
msgstr ""

#. type: table
#: search.texi.orig:1467
msgid "The command @kbd{M-x list-matching-lines} is a synonym for @kbd{M-x occur}."
msgstr ""

#. type: item
#: search.texi.orig:1468 search.texi.orig:1469
#, no-wrap
msgid "M-s o"
msgstr ""

#. type: table
#: search.texi.orig:1473
msgid ""
"Run @code{occur} using the search string of the last incremental string "
"search.  You can also run @kbd{M-s o} when an incremental search is active; "
"this uses the current search string."
msgstr ""

#. type: item
#: search.texi.orig:1474
#, no-wrap
msgid "M-x multi-occur"
msgstr ""

#. type: table
#: search.texi.orig:1478
msgid ""
"This command is just like @code{occur}, except it is able to search through "
"multiple buffers.  It asks you to specify the buffer names one by one."
msgstr ""

#. type: item
#: search.texi.orig:1479
#, no-wrap
msgid "M-x multi-occur-in-matching-buffers"
msgstr ""

#. type: table
#: search.texi.orig:1484
msgid ""
"This command is similar to @code{multi-occur}, except the buffers to search "
"are specified by a regular expression that matches visited file names.  With "
"a prefix argument, it uses the regular expression to match buffer names "
"instead."
msgstr ""

#. type: item
#: search.texi.orig:1485
#, no-wrap
msgid "M-x how-many"
msgstr ""

#. type: table
#: search.texi.orig:1489
msgid ""
"Prompt for a regexp, and print the number of matches for it in the buffer "
"after point.  If the region is active, this operates on the region instead."
msgstr ""

#. type: item
#: search.texi.orig:1490
#, no-wrap
msgid "M-x flush-lines"
msgstr ""

#. type: table
#: search.texi.orig:1497
msgid ""
"Prompt for a regexp, and delete each line that contains a match for it, "
"operating on the text after point.  This command deletes the current line if "
"it contains a match starting after point.  If the region is active, it "
"operates on the region instead; if a line partially contained in the region "
"contains a match entirely contained in the region, it is deleted."
msgstr ""

#. type: table
#: search.texi.orig:1502
msgid ""
"If a match is split across lines, @code{flush-lines} deletes all those "
"lines.  It deletes the lines before starting to look for the next match; "
"hence, it ignores a match starting on the same line at which another match "
"ended."
msgstr ""

#. type: item
#: search.texi.orig:1503
#, no-wrap
msgid "M-x keep-lines"
msgstr ""

#. type: table
#: search.texi.orig:1510
msgid ""
"Prompt for a regexp, and delete each line that @emph{does not} contain a "
"match for it, operating on the text after point.  If point is not at the "
"beginning of a line, this command always keeps the current line.  If the "
"region is active, the command operates on the region instead; it never "
"deletes lines that are only partially contained in the region (a newline "
"that ends a line counts as part of that line)."
msgstr ""

#. type: table
#: search.texi.orig:1512
msgid "If a match is split across lines, this command keeps all those lines."
msgstr ""
