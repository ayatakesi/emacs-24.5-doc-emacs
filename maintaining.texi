@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual., Abbrevs, This is part of the Emacs manual., Top
@c Copyright (C) 1985-1987, 1993-1995, 1997, 1999-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@node Maintaining
@chapter 大きなプログラムの保守

  このチャプターでは、大きなプログラムをメンテナンスするEmacsの機能を説明します。Lispの大きなプログラムをメンテナンスしている場合は、ここで説明している機能に加え、@file{ERT}
(``Emacs Lisp Regression Testing'')ライブラリーも便利だと思うかもしれません(@ref{Top,,ERT,ert,
Emacs Lisp Regression Testing}を参照してください)。

@menu
* Version Control::          バージョンコントロールシステムの使用。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Tags::                     1つのコマンドでプログラムの任意の関数に直接移動する。Tagsはそれがどのファイルにあるか記憶する。
* EDE::                      Emacsのための統合開発環境。
@ifnottex
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。
@end ifnottex
@end menu

@node Version Control
@section バージョンコントロール
@cindex version control

  @dfn{バージョンコントロールシステム(version control
system)}は、ソースファイルの複数のバージョンを記録したり、それらのバージョンの作成日時などや、誰が作成したか、何が変更されたかの説明などを記録できるプログラムのことです。

  Emacsのバージョンコントロールのためのインターフェースは、@dfn{VC}と呼ばれます。VCコマンドは、複数の異なるバージョンコントロールシステムで機能します。現在のところ、GNU
Arch、Bazaar、CVS、Git、Mercurial、Monotone、RCS、SCCS/CSSC、Subversionがサポートされます。これらの中で、GNUプロジェクトのディストリビューションはCVS、Arch、RCS、Bazaarです。

  バージョン管理システムで生成されたファイルをvisitすると、自動的にVCが有効になります。VCを無効にするには、カスタマイズ可能な変数@code{vc-handled-backends}を@code{nil}をセットします
@iftex
(@ref{Customizing VC,,,emacs-xtra, Specialized Emacs Features}を参照してください)。
@end iftex
@ifnottex
(@ref{Customizing VC}を参照してください)。
@end ifnottex

@menu
* Introduction to VC::       バージョンコントロールが機能する一般的な方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
@ifnottex
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。
@end ifnottex
@end menu

@node Introduction to VC
@subsection バージョンコントロールの紹介

  VCは、Emacsからのバージョンコントロールシステムの使用、およびバージョンコントロールの操作と編集をスムーズに統合します。VCは、多くのバージョンコントロールシステムでの一般的な操作にたいする、統一されたインターフェースを提供します。

  リポジトリー設定の変更など、非一般的または複雑なバージョンコントロールの操作は、VCではサポートされません。そのようなタスクは、Emacsの外(たとえばコマンドライン)で処理する必要があります。

  このセクションは、バージョンコントロールの一般的な概観を提供し、VCがサポートするバージョンコントロールを説明します。すでに使いたいバージョンコントロールシステムをよく知っている場合、このセクションはスキップできます。

@menu
* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのリポジトリーが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。
@end menu

@node Why Version Control?
@subsubsection 問題の背景

  バージョンコントロールシステムは、3つの重要な能力を提供します。

@itemize @bullet
@item
@dfn{Reversibility(可逆性)}: ある変更が間違い、または間違えた考えにもとづくものだと気づいたときに、前の状態に戻す能力です。

@item
@dfn{Concurrency(並列性)}: 多くの人が同じファイルコレクションを変更するとき、変更の衝突を検知して解決する能力です。

@item
@dfn{History(履歴)}:
それを変更した背後の意図を説明するコメントなど、履歴データをデータに付す能力です。1人で作業するプログラマーでさえ、変更履歴は記憶を助けるのに重要です。複数人のプロジェクトでは、開発者間のコミュニケーション形式として、とても重要です。
@end itemize

@node Version Control Systems
@subsubsection サポートされるバージョンコントロールシステム

@cindex back end (version control)
  VCは現在のところ、多くの異なるバージョンコントロールで機能し、それらを@dfn{バックエンド(back ends)}として参照します:

@itemize @bullet

@cindex SCCS
@item
SCCSは、これまでに構築された一番最初のバージョンコントロールシステムで、ずっと以前に、もっと進んだものに取って代わられました。SCCSにない特定の機能のためのVCコンポーネントは、それら自身により実装されています。複数ブランチなど、その他のVC機能は単に利用不可です。SCCSはフリーではないので、これを避けることを推奨します。

@cindex CSSC
@item
CSSCはSCCSのフリーな置き換えです。何らかの理由により、もっと新しい、より良いデザインのバージョンコントロールシステムを使うことができないときだけ、CSSCを使うべきです。

@cindex RCS
@item
RCSは、VCが最初に構築された頃の、フリーなバージョンコントロールシステムです。これは比較的に初期のものです。これはネットワークを超えて使うことはできず、ファイルに個別のレベルで機能します。RCSでできるほとんどのことは、VCを通じて行うことができます。

@cindex CVS
@item
CVSは、フリーなバージョンコントロールシステムで、最近(2008年ごろ)まではフリーソフトウェアプロジェクトの大半で使われていました。最近では、新しいシステムに徐々に置き換えられています。CVSではローカルまたはネットワーク越しの、複数ユーザーによる並列開発が可能です。新しいシステムとは異なり、アトミックなコミットとファイルの移動・リネームにたいするサポートがありません。VCはCVS下での基本的な編集操作をサポートします。

@cindex SVN
@cindex Subversion
@item
Subversion(svn)は、CVSと同じようにデザインされた、フリーなバージョンコントロールシステムですが、CVSのもつ問題はありません(たとえば、これはファイルセットのアトミックなコミット、ディレクトリーのバージョニング、シンボリックリンク、メタデータ、リネーム、コピー、削除をサポートします)。

@cindex GNU Arch
@cindex Arch
@item
GNU
Archは、一番古い@dfn{分散化された(decentralized)}バージョンコントロールシステムです(他にMonotoneがあります)。分散化されたバージョンコントロールシステムの説明は、@ref{VCS
Concepts}を参照してください。Bazaarを優先するために、もはや活発に開発されておらず、推奨されていません。

@cindex git
@item
Gitは、最初にLinus
TorvaldsによりLinux(彼のkernel)の開発をサポートするために考案されました。VCは多くのGit操作をサポートしますが、その他のリポジトリーの同期などはコマンドラインを使わなければなりません。

@cindex hg
@cindex Mercurial
@item
Mercurial(hg)は、Gitに酷似した分散化されたバージョンコントロールシステムです。VCは、リポジトリーの同期操作を除いて、ほとんどのMercurialコマンドをサポートします。

@cindex bzr
@cindex Bazaar
@item
Bazaar(bzr)は、リポジトリーベースと分散化されたバージョニングの両方をサポートする、分散化されたバージョンコントロールシステムです。VCはBazaar下でのほとんどの基本的な編集操作をサポートします。
@end itemize

@node VCS Concepts
@subsubsection バージョンコントロールの概念

@cindex repository
@cindex registered file
   ファイルがバージョンコントロールの配下にある時、それがバージョンコントロールシステムに@dfn{登録されている(registered)}と言います。バージョンコントロールシステムは、@dfn{リポジトリー(repository)}をもちます。これはファイルの現在の状態、および古いバージョンから現在のバージョンを再構成するのに充分な変更履歴の、両方を保存します。リポジトリーには、各ファイルに行われた変更の説明である@dfn{ログエントリー(log
entries)}など、その他の情報も含まれます。

@cindex work file
@cindex checking out files
  実際に編集する、バージョンコントロールされたファイルのコピーのことを、@dfn{作業ファイル(work
file)}と呼びます。作業ファイルは、通常のファイルを同じように変更できます。一連の変更を終えた後、その変更を@dfn{コミット(commit)}または@dfn{チェックイン(check
in)}します。これにより、その変更はログエントリーの記述とともに、リポジトリーに記録されます。

@cindex working tree
  作業ファイルのディレクトリツリーを、@dfn{作業ツリー(working tree)}と呼びます。

@cindex revision
@cindex revision ID
  co８mmitするたびに、リポジトリーに新しい@dfn{リビジョン(revision)}が作成されます。バージョンコントロールシステムは、過去のすべてのリビジョンと、各リビジョンで行われた変更を記録します。各リビジョンには、@dfn{リビジョンID(revision
ID)}により名前がつけられます。リビジョンIDのフォーマットは、バージョンコントロールシステムに依存します。もっとも簡単なケースでは、リビジョンIDは単なる整数です。

  これらの基本的な概念を超えるにつれ、各バージョンコントロールシステムの違いの、3つの様相を理解する必要がでてくるでしょう。以降の3つのセクションで説明するように、各バージョンコントロールシステムには、ロックベース(lock-based)とマージベース(merge-based)、ファイルベース(file-based)と変更セットベース(changeset-based)、集中型(centralized)と分散型(decentralized)の違いがあります。VCはこれらすべてのモードの操作を処理しますが、それらの違いを隠蔽することはできません。

@node VCS Merging
@subsubsection バージョンコントロールにおけるマージベースとロックベース

  バージョンコントロールシステムは通常、同じファイルを変更したい複数ユーザーを調整するために、何らかのメカニズムをもちます。これを行うには2つの方法
--- マージとロック --- があります。

@cindex merging-based version
  マージを使うバージョンコントロールシステムでは、各ユーザーはいつでも作業ファイルを変更します。バージョンコントロールシステムは、コミットされていない変更を含むユーザーの作業ファイルを、他のユーザーによりコミットされた最新の変更とマージします。

@cindex locking-based version
  古いバージョンコントロールシステムは、かわりに@dfn{ロック(locking)}を使います。この場合、作業ファイルは通常は読み取り専用です。ファイルを編集するには、それを@dfn{ロック}することにより書き込み可能にできるか、バージョンコントロールシステムに尋ねます。ある時点で、そのファイルをロックできるユーザーは1人だけです。この手順は、通常のファイルの同時編集をEmacsが検知する方法と類似しているようですが、異なります(@ref{Interlocking}を参照してください)。変更をコミットすると、ファイルはアンロック(unlocks)され、作業ファイルは再び読み取り専用になります。他のユーザーは、変更するためにそのファイルをロックすることができます。

  ロックおよびマージの両方のシステムは、複数ユーザーが同じときに同じファイルの変更を試みたときに問題が発生し得ます。ロックを使うシステムには、@dfn{ロックの衝突(lock
conflicts)}があります。あるユーザーはファイルのチェックアウトを試みますが、それがすでにロックされている場合はロックできません。マージを使うシステムには、@dfn{マージの衝突(merge
conflicts)}があります。これはファイルに行った変更をコミットするとき、それが後からチェックアウトした他の誰かによる変更のコミットと衝突するときに発生します。どちらの衝突も、人間の判断と意思疎通により解決する必要があります。経験から、開発者に取っての利便性と、実際に発生する衝突の重大性と数を最小にするという両方の点で、マージはロックに優ります。

  SCCSは常にロックを使います。RCSはデフォルトではロックベースですが、マージスタイルで処理するように指示できます。CVSとSubversionはデフォルトではマージベースですが、ロックモードで処理するように指示できます。GNU
Arch、Git、Mercurialのような分散型のバージョンコントロールシステムは、マージベースだけです。

  VCはロックとマージの両方のバージョンコントロールをサポートします。``commit(コミット)''と``update(更新)''という用語は、新しいバージョンコントロールシステムで使用されます。古いロックベースのシステムでは、``check
in(チェックイン)''と``check out(チェックアウト)''という用語が使用されます。VCはこれらの違いをできる限り隠蔽します。

@node VCS Changesets
@subsubsection バージョンコントロールに置ける変更セットベースとファイルベース

@cindex file-based version control
  SCCS、RCS、CVS、およびその他の初期のバージョンコントロールシステムでは、バージョンコントロールの操作は@dfn{ファイルベース(file-based)}です。各ファイルは、他のすべてのファイルとは別に、ファイル自身のコメントとリビジョン履歴をもちます。Subversionで始まる新しいシステムは、@dfn{変更セットベース(changeset-based)}です。コミットは複数ファイルにたいする変更を含むときがあり、一連の変更全体を1つの単位として扱います。変更にたいするコメントは1つのファイルではなく、変更セットに属します。

@cindex changeset-based version control
  変更セットベースのバージョンコントロールは、ファイルベースのバージョンコントロールより、柔軟で強力です。通常、複数ファイルの変更を元に戻す必要がある時、それを簡単に識別してすべてを削除できます。

@node VCS Repositories
@subsubsection リポジトリーにおける分散型と集中型

@cindex centralized version control
@cindex decentralized version control
@cindex distributed version control
  初期のバージョンコントロールシステムは、@dfn{集中型(centralized)}モデルでデザインされていて、各プロジェクトはすべての開発者が使用するただ1つのリポジトリーをもちます。SCCS、RCS、CVS、Subversionはこの種のモデルを共有します。このモデルの欠点の1つは、リポジトリーが信頼性と効率の要衝となることです。

  GNU
Archは、@dfn{分配型(distributed)}または@dfn{分散型(decentralized)}のバージョンコントロールの先駆で、後にGit、Mercurial、Bazaarで実装されました。プロジェクトは複数の異なるリポジトリーをもつことができ、これらのシステムはリポジトリー間で変更履歴を調停する、ある種のスーパーマージをサポートします。開発者ごとに1つのリポジトリーがあり、リポジトリーのマージがコミット操作を代行します。

  VCは個人の作業ファイルと、リポジトリーとの間で行われる通信を管理する手助けをします。VCは、リポジトリーが唯一のマスターなのか、それともネットワークのピアーのレポジトリーの1つなのかは関知しません。

@node Types of Log File
@subsubsection ログファイルのタイプ
@cindex types of log file
@cindex log File, types of
@cindex version control log

  バージョンコントロールシステムを使うプロジェクトは、変更にたいする2つのタイプのログをもつことができます。1つはバージョンコントロールシステムで保守されるログです。変更をコミットするたびに、変更にたいする@dfn{ログエントリー(log
entry)}を入力します(@ref{Log Buffer}を参照してください)。これは@dfn{バージョンコントロールログ(version
control log)}と呼ばれます。

  もう1つの種類のログは、@file{ChangeLog}です(@ref{Change
Log}を参照してください)。これはプログラムの大きな部分(通常は1つのディレクトリーと、そのサブディレクトリー)にたいする変更の記録を、年代順に記録します。小さなプログラムは、1つの@file{ChangeLog}を使用するでしょう。大きなプログラムは、主要なディレクトリーごとに@file{ChangeLog}をもつかもしれません。@ref{Change
Log}を参照してください。プログラマーは、バージョンコントロールシステムのずっと前からChangeLogを使ってきました。

  変更セットベースのバージョンシステムは、通常システム全体にたいして変更セットベースの修正ログを保守します。これはChangeLogを冗長なものにします。ChangeLogを残す利点の1つは、他のディレクトリーとは別に、1つのディレクトリーの履歴トランザクションが見れるのは便利なときがあるからです。他の利点として、多くのバージョンコントロールシステムはコミットログを特定できないからです。

  バージョンコントロールで管理されるプロジェクトは、バージョンコントロールログだけを使用するか、両方の種類のログを使用します。あるファイルにたいしては1つのログを使い、他のファイルにたいしては別の方法を使うこともできます。プロジェクトごとに、したがうべきポリシーがあります。

  両方を使うというポリシーの場合は通常、変更にたいして1度だけエントリーを書いて、それを両方のログに書き込みたいと思うでしょう。@file{ChangeLog}にエントリーを記述して、変更をコミットするとき@kbd{C-c
C-a}でログバッファーにコピーできます。または変更をコミットするときログバッファーにエントリーを記述して、後で@kbd{C-x v
a}コマンドでそれを@file{ChangeLog}にコピーできます
@iftex
(@ref{Change Logs and VC,,,emacs-xtra, Specialized Emacs
Features}を参照してください)。
@end iftex
@ifnottex
(@ref{Change Logs and VC}を参照してください)。
@end ifnottex

@node VC Mode Line
@subsection バージョンコントロールとモードライン
@cindex VC mode line indicator

  バージョンコントロール配下のファイルをvisitしたとき、Emacsはモードラインにそれを示します。たとえば@samp{Bzr-1223}と表示された場合、そのファイルにBazaarが使用され、カレントのリビジョンIDが1223であることを示します。

@cindex version control status
  バックエンド名とリビジョンIDの間の文字は、作業ファイルの@dfn{バージョンコントロール状態(version control
status)}を示します。マージベースのバージョンコントロールシステムでは、文字@samp{-}は作業ファイルが変更されていないことを示し、文字@samp{:}は作業ファイルが変更されていることを示します。文字@samp{!}は最新のマージ処理の結果により、そのファイルに衝突が含まれていることを示すか(@ref{Merging}を参照してください)、そのファイルがバージョンコントロールから削除されたことを示します。最後に、文字@samp{?}は、そのファイルがバージョンコントロールの配下にあるが、作業ツリーにないことを示します。

  ロックベースのシステムでは、@samp{-}はファイルがロックされていないことを示し、@samp{:}はファイルが他のユーザー(たとえば@samp{jim})にロックされていることを示し、@samp{RCS:jim:1.3}のように表示されます。@samp{@@}は、そのファイルがローカルに追加されたが、まだマスターリポジトリーにコミットされていないことを示します。

  グラフィカルなディスプレーでは、モードラインのインジケーターの上にマウスを移動すると、``ツールチップ''が表示され、それにはバージョンコントロール状態の、より多くの説明が表示されます。インジケーターを@kbd{Mouse-1}でクリックすると、メニューバーの@samp{Tools
/ Version Control}と同じVCコマンドがのメニューがポップアップします。

@vindex auto-revert-check-vc-info
  Auto
Revertモード(@ref{Reverting}を参照してください)がバージョンコントロール配下のバッファーをリバートするとき、これはモードラインのバージョンコントロール情報を更新します。しかし、Auto
Revertモードは、作業ファイルの変更をともなわない、カレントのEmacsセッションの外でのバージョンコントロール状態の変化の情報は、正しく更新しないかもしれません。@code{auto-revert-check-vc-info}を@code{t}にセットすると、Auto
Revertモードは、作業ファイル自身を変更していなくても、@code{auto-revert-interval}秒ごとにバージョンコントロール状態の情報を更新します。CPU使用率はバージョンコントロールシステムに依存しますが、通常はそれほど高価な処理ではありません。

@node Basic VC Editing
@subsection バージョンコントロール下での基本的な編集

@cindex filesets, VC
@cindex VC filesets
   ほとんどのVCコマンドは、@dfn{VCファイルセット(VC
filesets)}にたいして処理を行います。VCファイルセットは、VC操作が機能する1つ以上のファイルのコレクションです。バージョンコントロールされたファイルをvisitしているバッファーでVCコマンドをタイプすると、VCファイルセットは単にそのファイル1つだけになります。VC
Directoryバッファーで、いくつかのファイルをマークしているときにVCコマンドをタイプしたときは、VCファイルセットはマークされたファイルです(@ref{VC
Directory Mode}を参照してください)。

  現代的な変更セットベースのバージョンコントロールシステム(@ref{VCS
Changesets}を参照してください)では、VCコマンドは複数ファイルからなるVCファイルセットを1つのグループとして扱います。たとえば複数ファイルからなるVCファイルセットをコミットすると、それらすべてのファイルにたいする変更を含む、1つのリビジョンが生成されます。CVSのような古いファイルベースのバージョンコントロールシステムでは、複数ファイルからなるVCファイルセットの各ファイルは個別に処理されます。たとえば、コミットにより、変更されたファイル後とに1つのリビジョンが生成されます。

@table @kbd
@item C-x v v
カレントVCファイルセットにたいして、次の適切なバージョンコントロール操作を処理します。
@end table

@findex vc-next-action
@kindex C-x v v
  重要なVCコマンド@kbd{C-x v v}
(@code{vc-next-action})は多目的なもので、カレントのVCファイルセットにたいして、``もっとも適切''な操作を処理します。このコマンドは、それをバージョンコントロールシステムに登録するか、コミットするか、ロックを外すか、変更をマージします。正確な動作の詳細は、以下のサブセクションで説明します。@kbd{C-x
v v}は、ファイルをvisitしているバッファーと、VC Directoryバッファーの両方で使うことができます。

  VCファイルセットは、ファイルを閲覧したりvisitするためのグループ機能として使用される、``名前付のファイルセット(named
filesets)''とは別の物だということに注意してください(@ref{Filesets}を参照してください)。名前付のファイルセットとは異なり、VCファイルセットは名前をもたず、セッションをまたいで持続しません。

@menu
* VC With A Merging VCS::    ロックしない: 
                               CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。
@end menu

@node VC With A Merging VCS
@subsubsection マージでの基本的なバージョンコントロール

  マージベースのバージョンコントロールシステム(たとえばもっとも現代的な方法の1つ。@ref{VCS
Merging}を参照してください)では、@kbd{C-x v v}は以下のことを行います:

@itemize @bullet
@item
VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします(しかしファイルセットには、``新しく追加された''ファイルと、``変更された''ファイルを含むことができることに注意してください。@ref{Registering}を参照してください)。

@item
VCファイルセットに、バージョンコントロールシステムに登録されたファイルがない場合、VCファイルセットを登録(たとえばバージョンコントロールの配下に置く)します。@ref{Registering}を参照してください。Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに登録します。

@item
VCファイルセットの、すべての作業ファイルが変更されていない場合は、何もしません。

@item
VCファイルセットの各作業ファイルが変更されている場合、変更をコミットします。これを行うには、Emacsが@file{*vc-log*}バッファーをポップアップするので、新しいリビジョンのログエントリーをタイプしてから、@kbd{C-c
C-c}でコミットします。@ref{Log Buffer}を参照してください。

共有リポジトリーにコミットする場合、最後に更新したときからリポジトリーが変更されているときは、コミットが失敗するでしょう。このような場合、再試行する前に更新をしなければなりません。分散型のバージョンコントロールシステムでは、@kbd{C-x
v +}(@ref{VC Pull}を参照してください)、またh@kbd{C-x v
m}を使用します(@ref{Merging}を参照してください)。集中型のバージョンコントロールシステムでは、リポジトリーに変更をマージするために、再度@kbd{C-x
v v}とタイプしてください。

@item
最後に、集中型のバージョンコントロールシステムでは、VCファイルセットの各ファイルが最新かチェックします。リポジトリーで変更されたファイルがある場合、更新を提案します。
@end itemize

  これらのルールは、変更はリポジトリーから自動的にマージされない点をのぞき、RCSを``非ロック''モードで使用している場合も適用されます。あなたがファイルの編集を始めた後に、他のユーザーが同じファイルをコミットした場合、何の情報も与えられません。あなたのリビジョンをコミットしたとき、彼の変更は失われます(しかし、それはリポジトリーには残るので、決定的に失われるわけではありません)。したがって、変更をコミットする前に、カレントリビジョンが変更されていないことを調べなければなりません。それに加えて、このモードでもRCSでロックすることが可能です。変更されていないファイルでの@kbd{C-x
v v}は、RCSの通常のロックモードのようにそのファイルをロックします。(@ref{VC With A Locking VCS}を参照してください)。

@node VC With A Locking VCS
@subsubsection ロックでの基本的なバージョンコントロール

  ロックベースのバージョンコントロールシステム(SCCSやRCSのデフォルトモードなど)では、@kbd{C-x v v}は以下のことを行います:

@itemize @bullet
@item
VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョンコントロール状態と矛盾する場合、エラーをシグナルします。

@item
VCファイルセットに、バージョンコントロールシステムに登録されたファイルがない場合、VCファイルセットを登録します。@ref{Registering}を参照してください。Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに登録します。

@item
各ファイルが登録されていてロックされていなければ、それを書き込み可能にするためにロックして、編集を開始できるようにします。

@item
各ファイルのロックを獲得していて、それらが変更を含む場合、その変更をコミットします。これを行うことにより、Emacsは@file{*vc-log*}バッファーをポップアップするので、新しいリビジョンのログエントリーをタイプしてから、C-c
C-cでコミットします(@ref{Log Buffer}を参照してください)。

@item
各ファイルのロックをすでに獲得していて、変更がない場合、ファイルを再び読み取り専用にするために、ロックを開放します。

@item
各ファイルが他のユーザーによりロックされている場合、``ロックを横取りする(steal the
lock)''か、確認を求めます。これにyesと応えると、あなたがロックを獲得して、その前にファイルをロックしていたユーザーに、警告メッセージが送られます。
@end itemize

  このルールは、CVSがロックの横取りをサポートしない点をのぞき、CVSをロックモードで使用している場合も適用されます。

@node Advanced C-x v v
@subsubsection @kbd{C-x v v}の高度な制御

@cindex revision ID in version control
  @code{vc-next-action}にプレフィクス引数を与えた場合(@kbd{C-u C-x v
v})、論理的に次のバージョンコントロール操作を処理する点に変わりはありませんが、どのように操作を行うかを正確に指定するために、追加の引数を指定できるようになります。

@itemize @bullet
@item
@cindex specific version control system
バージョンコントロールシステムの名前を指定できます。これは、ファイルセットが複数のバージョンコントロールシステムで管理されていて、Emacsが正しいものを検知するのに失敗するとき便利です。

@item
そうでない場合で、CVSかRCSを使用しているときは、リビジョンIDを指定できます。

ファイルセットが変更(またはロック)されている場合、Emacsは指定したリビジョンIDでそれをコミットします。適切なリビジョンIDを与えることにより、新しいブランチを作成できます(@ref{Branches}を参照してください)。

ファイルセットが変更(またはロック)されていない場合、これは指定したリビジョンを作業ツリーにチェックインします。リビジョンIDまたはブランチIDを与えることにより、他のブランチのリビジョンを指定できます(@ref{Switching
Branches}を参照してください)。空の引数(例: @kbd{C-u C-x v v
@key{RET}})は、カレントブランチの最新のリビジョン(``head'')をチェックアウトします。

これは、分散型のバージョンコントロールシステムではエラーをシグナルします。これらのシステムでは、独自のリビジョンIDは指定できず、個別のファイルを``チェックアウト''するという概念も使いません。
@end itemize

@node Log Buffer
@subsection Log Entryバッファーの機能

@cindex C-c C-c @r{(Log Edit mode)}
@findex log-edit-done
  VCに変更のコミットを指示したとき、@file{*vc-log*}という名前のバッファーがポップアップします。このバッファーには、行った変更を説明する@dfn{ログエントリー(log
entry)}を書き込みます。書き込んだら@kbd{C-c C-c} (@code{log-edit-done})とタイプして,
そのバッファーを抜けて、ログエントリーとともに変更をコミットします。

@cindex Log Edit mode
@cindex mode, Log Edit
@vindex vc-log-mode-hook
@c FIXME: Mention log-edit-mode-hook here?  --xfq
  @file{*vc-log*}バッファーのためのメジャーモードはLog Editモードで、これはTextモードの変種です(@ref{Text
Mode}を参照してください)。Log
Editモードに入ると、Emacsはフック@code{text-mode-hook}および@code{vc-log-mode-hook}を実行します(@ref{Hooks}を参照してください)。

  @file{*vc-log*}バッファーでは、１行以上の@dfn{ヘッダー行(header
lines)}を記入できます。これにはバージョンコントロールシステムにより提供される、追加の情報を指定します。各ヘッダー行は、そのバッファーの最初の1行を占めなければなりません。ヘッダー行でない最初の行は、ログエントリーの開始として扱われます。たとえば以下のヘッダー行は、その変更が他の開発者によるものだということを示します:

@smallexample
Author: J. R. Hacker <jrh@@example.com>
@end smallexample

@noindent
@samp{Author}ヘッダーとは別に、Emacsは@samp{Date}ヘッダー(コミット日時を手入力で指定します)、@samp{Fixes}ヘッダー(変更によるバグフィクスへの参照)を認識します。すべてのバージョンコントロールシステムが、すべてのヘッダーを認識するわけではありません。Bazaarは3つのヘッダーすべてを認識し、Git、Mercurial、Monotoneは@samp{Author}と@samp{Date}だけを認識します。そのシステムでサポートされていないヘッダーを指定した場合、それはログエントリーの一部として扱われます。

@kindex C-c C-f @r{(Log Edit mode)}
@findex log-edit-show-files
@kindex C-c C-d @r{(Log Edit mode)}
@findex log-edit-show-diff
  @file{*vc-log*}バッファーにいる間は、``カレントVCファイルセット(current VC
fileset)''とは、@w{@kbd{C-c
C-c}}とタイプすることによりコミットされるファイルセットだと考えられます。そのVCファイルセットのファイル一覧を閲覧するには、@w{@kbd{C-c
C-f}}
(@code{log-edit-show-files})とタイプします。そのVCファイルセットと、編集を開始したバージョンとのdiffを閲覧するには、@kbd{C-c
C-d} (@code{log-edit-show-diff})とタイプしてください。

@kindex C-c C-a @r{(Log Edit mode)}
@findex log-edit-insert-changelog
  VCファイルセットが1つ以上の@file{ChangeLog}(@ref{Change Log}を参照してください)ファイルを含む場合、@kbd{C-c
C-a}
(@code{log-edit-insert-changelog})とタイプすると、関連するエントリーを、@file{*vc-log*}バッファーに引用します。各@file{ChangeLog}ファイルの一番上のアイテムが、今日の日付でユーザー名があなたの場合、このコマンドはコミットされるファイルにマッチするエントリーのアイテムを検索して、それを挿入します。
@ifnottex
CVSまたはRCSを使用している場合は、反対のこと --- Log EditバッファーからChangeLogエントリーを生成 ---
を行います。@ref{Change Logs and VC}を参照してください。
@end ifnottex

  コミットを中止するには、そのバッファーで単に@kbd{C-c
C-c}を@emph{タイプしない}で、バッファーを切り替えて他の編集を行うことができます。他のコミットを試みなければ、編集していたエントリーは@file{*vc-log*}に残っているので、後でそのバッファーに戻ってコミットを完了できます。

@kindex M-n @r{(Log Edit mode)}
@kindex M-p @r{(Log Edit mode)}
@kindex M-s @r{(Log Edit mode)}
@kindex M-r @r{(Log Edit mode)}
  コミットコメントをコピーするために、以前のログエントリーの履歴を閲覧することもできます。これは、似たようなコメントで複数のコミットを行いたいとき便利です。これを行うコマンド@kbd{M-n}、@kbd{M-p}、@kbd{M-s}、@kbd{M-r}は、これらがミニバッファーの外で使用される点を除けば、ミニバッファーのヒストリーコマンド(@ref{Minibuffer
History}を参照してください)と同様です。

@node Registering
@subsection バージョンコントロールへのファイルの登録

@table @kbd
@item C-x v i
visitしているファイルを、バージョンコントロールに登録します。
@end table

@kindex C-x v i
@findex vc-register
  コマンド@kbd{C-x v i}
(@code{vc-register})は、カレントVCファイルセットの各ファイルを、バージョンコントロールの配下に置きます。これは登録されていないVCファイルセットにたいして、@kbd{C-x
v v}が行う動作と基本的に同じですが、VCファイルセットがすでに登録されているとき(@ref{Basic VC
Editing}を参照してください)、@kbd{C-x v v}は他の操作を処理しますが、@kbd{C-x v
i}はエラーをシグナルする、という点が異なります。

  ファイルを登録するために、Emacsはバージョンコントロールシステムを選択しなければなりません。複数ファイルのVCファイルセットにたいしては、VC
Directoryバッファーが使用するシステムを指定します(@ref{VC Directory
Mode}を参照してください)。VCファイルセットのファイルが1つで、そのファイルのディレクトリーがすでにバージョンコントロールシステムに登録されたファイルを含むか、そのディレクトリーがバージョンコントロールシステムにより制御される作業ツリーの一部の場合、Emacsはそのシステムを選択します。複数のバージョンコントロールシステムが当てはまる場合、Emacsは変数
@iftex
@code{vc-handled-backends}に最初に表れるシステムを使用します。
@end iftex
@ifnottex
@code{vc-handled-backends}に最初に表れるシステムを使用します(@pxref{Customizing VC})。
@end ifnottex
Emacsがファイルを登録するバージョンコントロールシステムを見つけられなかった場合、リポジトリータイプの入力を求め、新しいリポジトリーを作成して、そのリポジトリーにファイルを登録します。

  ほとんどのバージョンコントロールシステムでは、@kbd{C-x v i}または@kbd{C-x v
v}でファイルを登録することにより、それを``作業ツリー(working
tree)''に追加しますが、リポジトリーには追加しません。そのようなファイルは、VC
Directoryバッファーでは@samp{added}とラベル付けされ、モードラインのリビジョンIDには@samp{@@@@}が表示されます。リポジトリーにたいして登録を有効にするには、コミットを行わなければなりません(@ref{Basic
VC Editing}を参照してください)。1つのコミットに、ファイルの追加と、既存ファイルの編集の両方を含むことができるのに注意してください。

  ロックベースのバージョンコントロールシステム(@ref{VCS
Merging}を参照してください)では、ファイルの登録により、ファイルはロックされていない読み取り専用の状態に留まります。編集を開始するには、@kbd{C-x
v v}とタイプします。

@node Old Revisions
@subsection 古いリビジョンの調査と比較

@table @kbd
@item C-x v =
カレントVCファイルセットの作業ファイルと、編集を開始したバージョンを比較します(@code{vc-diff})。プレフィクス引数を指定した場合、カレントVCファイルセットの2つのリビジョンの入力を求め、それらを比較します。このコマンドをDiredバッファーから呼び出すこともできます(@ref{Dired}を参照してください)。

@ifnottex
@item M-x vc-ediff
@kbd{C-x v =}と同様ですが、Ediffを使用します。@ref{Top,, Ediff, ediff, The Ediff
Manual}を参照してください。
@end ifnottex

@item C-x v D
編集を開始したリビジョンの、作業ツリー全体を比較します(@code{vc-root-diff})。プレフィクス引数を指定した場合、2つのリビジョンの入力を求め、それらのツリーを比較します。

@item C-x v ~
カレントファイルのリビジョンの入力を求め、それを別のバッファーでvisitします(@code{vc-revision-other-window})。

@item C-x v g
カレントファイルの、注釈付きのバージョンを表示します。各行には、その行が変更された最新のリビジョンが表示されます(@code{vc-annotate})。
@end table

@findex vc-diff
@kindex C-x v =
  @kbd{C-x v =}
(@code{vc-diff})は、@dfn{diff}を表示します。これはカレントVCファイルセットの各作業ファイルを、編集を開始したときのバージョンと比較します。diffは別のウィンドウに、@file{*vc-diff*}という名前のDiff
modeモードのバッファー(@ref{Diff
Mode}を参照してください)で表示されます。このバッファーでは、通常のDiffモードコマンドが利用可能です。特に@kbd{g}
(@code{revert-buffer})コマンドは、ファイル比較を再び行い、新しいdiffを生成します。

@kindex C-u C-x v =
  カレントVCファイルセットの、任意の2つのリビジョンを比較するには、@kbd{C-u C-x v
=}のようにプレフィクス引数を指定して、@code{vc-diff}を呼び出します。これは2つのリビジョンID(@ref{VCS
Concepts}を参照してください)の入力を求め、ファイルセットのそれらのバージョンの間のdiffを表示します。このコマンドは、バージョンコントロールシステムが変更セットベースではなくファイルベースの場合(たとえばCVS)に、複数ファイルのVCファイルセットにたいして確実に動作しません。なぜなら同じリビジョンIDをもつ異なるファイル同士を、意味のある方法で関連させることができないからです。

  リビジョンIDではなく、他のフォーマットでリビジョンを指定するバージョンコントロールシステムもいくつかあります。たとえばBazaarでは、@kbd{C-u
C-x v
=}(および関連するコマンド)に@samp{date:yesterday}と入力でき、これは昨日以降コミットされた最初のリビジョンを指定します。詳細については、バージョンコントロールシステムのドキュメントを参照してください。

  Diredバッファー(@ref{Dired}を参照してください)で@kbd{C-x v =}または@kbd{C-u C-x v
=}を呼び出すと、カレント行にリストされたファイルが、カレントVCファイルセットとして扱われます。

@ifnottex
@findex vc-ediff
  @kbd{M-x vc-ediff}は、@kbd{C-x v =}と同じように機能しますが、Ediffセッションを使用します。@ref{Top,,
Ediff, ediff, The Ediff Manual}を参照してください。
@end ifnottex

@findex vc-root-diff
@kindex C-x v D
  @kbd{C-x v D} (@code{vc-root-diff})は、@kbd{C-x v
=}と似ていますが、カレント作業ツリー全体の変更を表示します(たとえばカレントVCファイルセットを含む作業ツリー)。このコマンドをDiredバッファーから呼び出すと、そのディレクトリーを含む作業ツリーに適用されます。

@vindex vc-diff-switches
  @kbd{C-x v =}および@kbd{C-x v
D}が、diffを生成するために使用する@command{diff}オプションをカスタマイズできます。オプションには、変数@code{vc-@var{backend}-diff-switches}、@code{vc-diff-switches}、@code{diff-switches}(@pxref{Comparing
Files})の順に、最初の非@code{nil}の値が使用されます。ここで@var{backend}は、関連するバージョンコントロールシステムで、たとえばBazaarの場合は@code{bzr}です。@code{nil}は順番に次の変数をチェックすることを意味するので、スイッチを指定しない場合は最初の2つの値を@code{t}にします。ほとんどの@code{vc-@var{backend}-diff-switches}変数のデフォルトは@code{nil}ですが、いくつかのbackendのデフォルトは@code{t}です。Subversionのように、これらのバージョンコントロールシステムの@code{diff}実装は、一般的なdiffオプションを受け付けません。

@findex vc-revision-other-window
@kindex C-x v ~
  ファイルの古いバージョンを直接調べるには、作業ファイルをvisitして、@kbd{C-x v ~ @var{revision} @key{RET}}
(@code{vc-revision-other-window})とタイプします。これは@var{revision}に対応するバージョンのファイルを取得して、それを@file{@var{filename}.~@var{revision}~}に保存してから、別のウィンドウでvisitします。

@findex vc-annotate
@kindex C-x v g
  多くのバージョンコントロールシステムでは、@kbd{C-x v g}
(@code{vc-annotate})とタイプして、行ごとにリビジョン情報の@dfn{注釈付き(annotated)}でファイルを閲覧できます。これは新しいバッファー(``annotateバッファー'')を作成して、各行に古さを示すカラーをつけて、ファイルのテキストを表示します。赤いテキストは新しく、古いものは青、その中間色は中間のバージョンを示します。デフォルトでは、一番古い変更を青、一番新しい変更を赤で、すべてのバージョンレンジにカラーをスケーリングします。

  このコマンドにプレフィクス引数を指定した場合、Emacsはミニバッファーを使って、表示および注釈つけする(カレントファイル内容のかわりの)リビジョンと、カラーレンジがカバーすべきタイムスパンの、2つの引数を読み取ります。

  annotateバッファーでは、@samp{VC-Annotate}メニューから、これら、または他のカラースケールオプションが利用可能です。このバッファーでは、過去のリビジョンの注釈の表示、diffの閲覧、ログエントリーの閲覧を行うために、以下のキーを使うこともできます:

@table @kbd
@item p
前のリビジョン(たとえば現在の注釈付きのリビジョンの1つ前のリビジョン)に注釈を付けます。数引数は繰り返し回数となるので、@kbd{C-u 10
p}は10個前のリビジョンに注釈を付けます。

@item n
次のリビジョン(たとえば現在の注釈付きのリビジョンの1つ後のリビジョン)に注釈を付けます。数引数は繰り返し回数です。

@item j
カレント行に示されたリビジョンに解釈を付けます。

@item a
カレント行に示されたリビジョンの、1つ前のリビジョンに注釈を付けます。これはカレント行が変更される前の状態のファイルを見るとき便利です。

@item f
カレント行に示されたリビジョンのファイルを、バッファーに表示します。

@item d
カレント行のリビジョンと、その前のリビジョンの間のdiffを表示します。これはカレント行のリビジョンが実際にどのように変更されたか、ファイルを見るとき便利です。

@item D
カレント行のリビジョンと、その前のリビジョンの間で、(変更セットをサポートするバージョンコントロールシステムの)変更セットのすべてのファイルのdiffを表示します。これはカレント行のリビジョンが、実際にどのように変更されたかツリー内を見るとき便利です。

@item l
カレント行のリビジョンのログを表示します。これはカレント行のリビジョンの変更にたいする執筆者(author)の説明を見るのに便利です。

@item w
作業中のリビジョン(編集中のもの)に注釈を付けます。@kbd{p}や@kbd{n}を使って他のリビジョンを表示している場合、このキーで作業中のリビジョンに戻ることができます。

@item v
注釈の表示・非表示を切り替えます。これは邪魔になる注釈抜きでファイル内容だけを見たいとき便利です。
@end table

@node VC Change Log
@subsection VC Change Log

@table @kbd
@item C-x v l
カレントファイルセットの変更履歴を表示します(@code{vc-print-log})。

@item C-x v L
カレントリポジトリーの変更履歴を表示します(@code{vc-print-root-log})。

@item C-x v I
pull操作が取り込む変更を表示します(@code{vc-log-incoming})。

@item C-x v O
push操作が送信する変更を表示します(@code{vc-log-outgoing})。
@end table

@kindex C-x v l
@findex vc-print-log
  @kbd{C-x v l}
(@code{vc-print-log})は、@file{*vc-change-log*}という名前のバッファーを表示して、誰が変更したのか、その日時、各変更のログエントリー(これらは@file{*vc-log*}バッファーを通じて入力したログエントリーと同じです。@ref{Log
Buffer}を参照してください)を含む、カレントファイルに行われた変更の履歴を表示します。現在visitしているファイルのリビジョンに、ポイントが配されます。プレフィクス引数を指定した場合、このコマンドはポイントが配されるリビジョンと、表示するリビジョンの最大数の入力を求めます。

  VC Directoryバッファー(@ref{VC Directory
Mode}を参照してください)、またはDiredバッファー(@ref{Dired}を参照してください)から@kbd{C-x v
l}を呼び出した場合、カレント行にリストされたファイルにたいして適用されます。

@findex vc-print-root-log
@findex log-view-toggle-entry-display
  @kbd{C-x v L}
(@code{vc-print-root-log})は、@file{*vc-change-log*}バッファーを表示して、バージョンコントロールされたディレクトリーツリー全体を表示します。このコマンドはプレフィクス引数を指定した場合、表示するリビジョンの最大数の入力を求めます。

  @kbd{C-x v
L}では履歴は簡略化された形式で表示され、通常は各ログエントリーの最初の行だけが表示されます。しかし@file{*vc-change-log*}バッファーで@key{RET}
(@code{log-view-toggle-entry-display})とタイプすると、ポイント位置のリビジョンのログエントリー全体を表示します。2回目の@key{RET}で、再びそれを隠します。

  分散型のバージョンコントロールシステムでは、@kbd{C-x v I}
(@code{vc-log-incoming})コマンドは、次回にバージョンコントロールの``pull''コマンドを実行するときに、他のリポジトリーから受け取る新しいリビジョンにより適用される変更を、ログバッファーに表示します(@ref{VC
Pull}を参照してください)。ここで他のリポジトリーとは、バージョンコントロールシステムで定義される、変更がpullされるリポジトリーのことです。プレフィクス引数を指定すると、@code{vc-log-incoming}は特定のリポジトリーの入力を求めます。同様に、@kbd{C-x
v O}
(@code{vc-log-outgoing})は、次回に``push''コマンドを実行するときに、他のリポジトリーに送る変更を表示します。プレフィクス引数を指定すると、特定の送信先リポジトリーの入力を求めます。

  @file{*vc-change-log*}バッファーでは、リビジョンのログまたはファイル間の移動や、過去のリビジョン(@ref{Old
Revisions}を参照してください)を調べたり比較するために、以下のキーを使うことができます:

@table @kbd
@item p
前のリビジョンエントリーに移動します(logバッファーのリビジョンエントリーは通常、日時の降順になっているので、前のリビジョンアイテムは通常、もっと新しいリビジョンに対応します)。数引数は繰り返し回数です。

@item n
次のリビジョンエントリーに移動します。数引数は繰り返し回数です。

@item P
複数ファイルのVCファイルセットのログを表示している場合は、前のファイルのログに移動します。そうでない場合は、単にログの先頭に移動します。数引数は繰り返し回数です。

@item N
複数ファイルのVCファイルセットのログを表示している場合は、次のファイルのログに移動します。数引数は繰り返し回数です。

@item a
カレント行のリビジョンに注釈を付けます(@ref{Old Revisions}を参照してください)。

@item e
ポイント位置に表示された変更コメントを修正します。すべてのバージョンコントロールシステムが、変更コメントの修正をサポートするわけではないことに注意してください。

@item f
カレント行に示されたリビジョンをvisitします。

@item d
ポイント位置のリビジョンと、次に古いリビジョンとの間で、特定のファイルにたいするdiffを表示します。

@item D
ポイント位置のリビジョンと、次に古いリビジョンとの間で、変更セットのdiffを表示します。これは、そのリビジョンですべてのファイルにたいして行われた変更を表示します。

@item @key{RET}
簡略形式のlogバッファー(たとえば@kbd{C-x v
L}で作成されたバッファー)で、ポイント位置のログエントリーにたいして、完全なログエントリーの表示・非表示を切り替えます。
@end table

@vindex vc-log-show-limit
多くのログエントリーを取得するには時間がかかるので、@file{*vc-change-log*}バッファーは、デフォルトで2000を超えるリビジョンは表示しません。変数@code{vc-log-show-limit}はこの制限を指定します。この値を0にセットすると、制限が削除されます。既存の@file{*vc-change-log*}で、バッファーの最後のボタン@samp{Show
2X entries}または@samp{Show unlimited
entries}をクリックして、表示するリビジョン数を増やすこともできます。しかしRCS、SCCS、CVSはこの機能をサポートしません。

@node VC Undo
@subsection バージョンコントロール操作のアンドゥ

@table @kbd
@item C-x v u
カレントVCファイルセットの作業ファイルを、最後のリビジョンにリバートします(@code{vc-revert})。
@end table

@c `C-x v c' (vc-rollback) was removed, since it's RCS/SCCS specific.

@kindex C-x v u
@findex vc-revert
@vindex vc-revert-show-diff
  カレントVCファイルセットにたいするすべての変更を破棄したい場合、@kbd{C-x v u}
(@code{vc-revert-buffer})とタイプします。これは作業ファイルと、編集を開始したときのリビジョンのdiffを表示して、変更を破棄するか確認を求めます。これに同意するとファイルセットはリバートされます。@kbd{C-x
v
u}でdiffを表示させたくない場合は、変数@code{vc-revert-show-diff}に@code{nil}をセットします(この設定をしても@kbd{C-x
v =}で直接diffを表示できます。@ref{Old Revisions}を参照してください)。@kbd{C-x v
u}は通常のアンドゥコマンドでは戻せないので、注意して使用してください(@ref{Undo}を参照してください)。

  ロックベースのバージョンコントロールシステムでは、@kbd{C-x v
u}はファイルをロックしないまま残します。編集を再開するには、再度ロックしなければなりません。ファイルをロックしてから、やはりそれを変更しないと決めたときも、@kbd{C-x
v u}でファイルのロックを開放できます。

@node VC Ignore
@subsection バージョンコントロールファイルを無視する

@table @kbd
@item C-x v G
カレントのバージョンコントロールシステム配下のファイルを無視します(@code{vc-ignore})。
@end table

@kindex C-x v G
@findex vc-ignore
  ソースツリーの多くは、エディターのバックアップや、オブジェクトファイル、バイトコードファイル、ビルドされるプログラムなどの、バージョン管理する必要のないファイルを含みます。これらは単に追加しないだけでも構いませんが、常に不明なファイルとして現れるでしょう。ツリーのトップの、無視するファイルのリストにこれらのファイルを追加して、それらを無視するようにバージョンコントロールシステムに指示することもできます。これを行うには@kbd{C-x
v G} (@code{vc-ignore})が助けとなるでしょう。プレフィクス引数を指定すると、無視するファイルリストからファイルを削除できます。

@node VC Directory Mode
@subsection VC Directoryモード

@cindex VC Directory buffer
  @dfn{VC
Directoryバッファー}は、ディレクトリーツリーにあるファイルのバージョンコントロール状態を見て、それらのファイルにバージョンコントロール操作を実行するために特化したバッファーです。特に複数ファイルのVCファイルセットにたいして、@w{@kbd{C-x
v v}}のようなコマンドを適用するのに使用されます(@ref{VC Directory Commands}を参照してください)。

@kindex C-x v d
@findex vc-dir
  VC Directoryバッファーを使用するには、@kbd{C-x v d}
(@code{vc-dir})とタイプします。これはミニバッファーを使用してディレクトリー名を読み取り、そのディレクトリーにたいするVC
Directoryバッファーに切り替えます。デフォルトでは、バッファーの名前は@file{*vc-dir*}です。その内容については、
@iftex
以下で説明します。
@end iftex
@ifnottex
@ref{VC Directory Buffer}で説明します。
@end ifnottex

  @code{vc-dir}コマンドは、指定したディレクトリーで使用されているバージョンコントロールシステムを自動的に検知します。そのディレクトリーにたいして複数のバージョンコントロールシステムが使用されている場合、@kbd{C-u
C-x v d}のようにプレフィクス引数を指定して、このコマンドを呼び出す必要があるでしょう。これはVC
Directoryバッファーが使用すべきバージョンコントロールシステムの入力を求めます。

@ifnottex
@cindex PCL-CVS
@pindex cvs
@cindex CVS directory mode
  VC Directoryバッファーに加えて、EmacsにはCVSに特化したPCL-CVSと呼ばれる似た機能があります。@ref{Top, , About
PCL-CVS, pcl-cvs, PCL-CVS---The Emacs Front-End to CVS}を参照してください。
@end ifnottex

@menu
* Buffer: VC Directory Buffer.  バッファーの外観と意味。
* Commands: VC Directory Commands.  VC 
                                      directoryバッファーで使用するコマンド。
@end menu

@node VC Directory Buffer
@subsubsection VC Directoryバッファー

  VC Directoryバッファーは、バージョンコントロールされたファイルと、それらのバージョンコントロール状態を含みます。これは、(@kbd{C-x
v
d}を呼び出すことにより指定される)カレントディレクトリーの、``注目すべき''状態のファイルとサブディレクトリーをだけリストします。最新のファイル(リポジトリーのものと同じ)は省略されます。サブディレクトリーのファイルがすべて最新の場合、そのサブディレクトリーもリストされません。例外として、VCコマンドの直接の結果として最新になったファイルはリストされます。

  以下はVC Directoryバッファーのリストの例です:

@smallexample
@group
                     ./
    edited           configure.ac
*   added            README
    unregistered     temp.txt
                     src/
*   edited           src/main.c
@end group
@end smallexample

@noindent
2つの作業ファイル、カレントディレクトリーの@file{configure.ac}と、サブディレクトリー@file{src/}の@file{foo.c}は、変更されていますがコミットされていません。@file{README}という名前のファイルは追加されましたが、まだコミットされていません。そして@file{temp.txt}はバージョンコントロールの配下にありません(@ref{Registering}を参照してください)。

エントリー@file{README}および@file{src/main.c}の隣の@samp{*}という文字は、ユーザーがそれらのファイルをカレントVCファイルセットとしてマークしたことを示します
@iftex
(以下を参照してください)。
@end iftex
@ifnottex
(@ref{VC Directory Commands}を参照してください)。
@end ifnottex

  上記は、Bazaar、Git、Mercurialのような分散型のバージョンコントロールシステムでの典型的な例です。他のシステムでは、他の状態も見られます。たとえばCVSは、リポジトリーが変更されていて、それがまだ作業ファイルに適用されていないときは、@samp{needs-update}という状態を表示します。RCSとSCCSは、ロックされているファイルの状態に、ロックしているユーザーの名前を表示します。

@ifnottex
@vindex vc-stay-local
@vindex vc-cvs-stay-local
  CVSとSubversionでは通常、@code{vc-dir}コマンドは更新のチェックのために、おそらくはリモートマシン上にあるであろうリポジトリーにアクセスします。変数@code{vc-stay-local}(CVSは@code{vc-cvs-stay-local}。@ref{CVS
Options}を参照してください)を@code{nil}に変更すると、EmacsはVC
Directoryバッファーが生成されるときのリモートのリポジトリーへのアクセスを避けます(コミットを行うときなど、必要なときはアクセスします)。これは、オフラインで作業していたり、ネットワークが遅いときは望ましいでしょう。
@end ifnottex

@vindex vc-directory-exclusion-list
  VC
Directoryバッファーは、変数@code{vc-directory-exclusion-list}にリストされているサブディレクトリーを省略します。この変数のデフォルト値には、バージョンコントロールシステムにより内部的に使用されるディレクトリーが含まれています。

@node VC Directory Commands
@subsubsection VC Directoryコマンド

  EmacsはVC
Directoryバッファーの操作と、カレントVCファイルセットに属させるために、ファイルを``マーク''するためのコマンドをいくつか提供します。

@table @kbd
@item n
@itemx @key{SPC}
次のエントリーにポイントを移動します(@code{vc-dir-next-line})。

@item p
前のエントリーにポイントを移動します(@code{vc-dir-previous-line})。

@item @key{TAB}
次のディレクトリーエントリーに移動します(@code{vc-dir-next-directory})。

@item S-@key{TAB}
前のディレクトリーエントリーに移動します(@code{vc-dir-previous-directory})。

@item @key{RET}
@itemx f
カレント行にリストされたファイル、またはディレクトリーをvisitします(@code{vc-dir-find-file})。

@item o
カレント行にリストされたファイル、またはディレクトリーを別のウィンドウでvisitします(@code{vc-dir-find-file-other-window})。

@item m
カレント行のファイルまたはディレクトリーをマークして、それをカレントVCファイルセットに加えます(@code{vc-dir-mark})。リージョンがアクティブのときは、リージョンの中のすべてのファイルをマークします。

すでにマークされたディレクトリーの中のファイル、またはそのサブディレクトリーは、このコマンドではマークされません。同様に、ツリーの中のいくつかのファイルがマークされているディレクトリーは、このコマンドではマークされません。

@item M
ポイントがファイルエントリーにあるときは、同じ状態のすべてのファイルをマークします。ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルをマークします(@code{vc-dir-mark-all-files})。プレフィクス引数を指定した場合、リストされたファイルとディレクトリーのすべてをマークします。

@item q
VC Directoryバッファーを終了して、隠します(@code{quit-window})。

@item u
カレント行のファイル、またはディレクトリーのマークを外します(@code{vc-dir-unmark})。リージョンがアクティブのときは、リージョンの中のすべてのファイルのマークを外します。

@item U
ポイントがファイルエントリーにあるときは。同じ状態のすべてのファイルのマークを外し、ポイントがディレクトリーエントリーにあるときは、そのディレクトリーツリーのすべてのファイルのマークを外します(@code{vc-dir-unmark-all-files})。プレフィクス引数を指定した場合、すべてのファイルおよびディレクトリーのマークを外します。

@item x
状態が@samp{up-to-date}のファイルを隠します(@code{vc-dir-hide-up-to-date})。プレフィクス引数を指定した場合、状態がポイント位置のアイテムと同じアイテムを隠します。
@end table

@findex vc-dir-mark
@findex vc-dir-mark-all-files
  VC Directoryバッファーでは、@kbd{m} (@code{vc-dir-mark})または@kbd{M}
(@code{vc-dir-mark})でマークしたすべてのファイルが、カレントVCファイルセットになります。ディレクトリーエントリーを@kbd{m}でマークした場合、そのディレクトリーツリーにリストされたすべてのファイルが、カレントVCファイルセットになります。カレントVCファイルセットに属するファイルとディレクトリーは、VC
Directoryではバージョンコントロール状態の隣に、文字@samp{*}が示されます。この方法により@w{@kbd{C-x v v}}
(@ref{Basic VC Editing}を参照してください)、@w{@kbd{C-x v =}} (@ref{Old
Revisions}を参照してください)、@w{@kbd{C-x v u}} (@ref{VC
Undo}を参照してください)のようなVCコマンドが作用する、複数ファイルのVCファイルセットをセットアップできます。

  VC Directoryバッファーは、@kbd{C-x
v}というプレフィクスをもつコマンドを、1キーで入力するショートカット(@kbd{=}、@kbd{+}、@kbd{l}、@kbd{i}、@kbd{D}、@kbd{L}、@kbd{G}、@kbd{I}、@kbd{v})を定義します。

  たとえば、VC
Directoryバッファーで開いて編集された一連のファイルは、@samp{edited}という状態でリストされ、それらのファイルをマークして、@kbd{v}または@kbd{C-x
v v}
(@code{vc-next-action})でコミットできます。バージョンコントロールシステムが変更セットベースの場合、Emacsはそれらのファイルを1つのリビジョンとしてコミットします。

  VC Directoryバッファーでは、以下のコマンドによりカレントVCファイルセットの検索と置換を処理することもできます:

@table @kbd
@item S
ファイルセットを検索します(@code{vc-dir-search})。

@item Q
ファイルセットにたいして、正規表現による問い合わせ置換を行います(@code{vc-dir-query-replace-regexp})。

@item M-s a C-s
ファイルセットにたいして、インクリメンタル検索を行います(@code{vc-dir-isearch})。

@item M-s a C-M-s
ファイルセットにたいして、インクリメンタルな正規表現検索を行います(@code{vc-dir-isearch-regexp})。
@end table

@noindent
複数ファイルに作用する点を除けば、これらのコマンドは1つのバッファーに作用する同等のコマンドに似ています(@ref{Search}を参照してください)。

@cindex stashes in version control
@cindex shelves in version control
  上記のコマンドは、メニューバーおよび@kbd{Mouse-2}によるコンテキストメニューを通じても利用可能です。さらにVCのバックエンドのいくつかは、そのバックエンド特有のコマンドを提供するメニューを使用します。たとえばGitとBazaarでは、@dfn{stashes(隠してあるもの)}と@dfn{shelves(棚)}を操作できます(コミットされていない変更を一時的に除外して、後でそれを戻すコマンドです)。

@node Branches
@subsection バージョンコントロールのブランチ
@cindex branch (version control)

  バージョンコントロールの活用法の1つとして、@dfn{ブランチ(branches)}と呼ばれる複数の独立した開発ラインのサポートがあります。中でもとりわけブランチは、プログラムの``安定版(stable)''と``開発版(development)''を個別に保守したり、関係のない機能を他の版から隔離して開発するのに使用されます。

  現在のところVCのブランチ操作にたいするサポートは、かなり制限されています。分散型のバージョンコントロールシステムにたいしては、あるブランチを他のブランチのコンテンツで@dfn{更新}するコマンドと、2つの異なるブランチの変更を@dfn{マージ}するコマンドを提供します。集中型のバージョンコントロールシステムにたいしては、異なるブランチからチェックアウトして、新規または異なるブランチにコミットするコマンドを提供します。

@menu
* Switching Branches::       既存のブランチを取得する方法。
* VC Pull::                  ブランチの内容の更新。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。
@end menu

@node Switching Branches
@subsubsection ブランチ間の切り替え

  さまざまなバージョンコントロールシステムにおいて、ブランチが実装される方法は異なり、VCはこれらの違いを完全に隠蔽することはできません。

  BazaarとMercurialを含む分散型バージョンコントロールシステムのいくつかは、ノーマルモードの操作では、各ブランチは自身の作業ディレクトリーツリーをもつので、ブランチの切り替えは単にディレクトリーを切り替えるだけです。Gitでは、ブランチは通常、同じディレクトリーの@dfn{共通場所(co-located)}を使用し、ブランチの切り替えは、作業ツリーの内容をそのブランチに一致するように変更する、@command{git
checkout}を使用して行われます。Bazaarも共通場所をサポートし、この場合は@command{bzr
switch}コマンドによりカレントディレクトリーでブランチを切り替えます。Subversionでは他のブランチに切り替えるのに、@command{svn
switch}コマンドを使用します。

  カレントディレクトリーの他のブランチに切り替えるVCコマンドは、@kbd{C-x v r @var{branch-name} @key{RET}}
(@code{vc-retrieve-tag})です。

  集中型のバージョンコントロールシステムでは、最新の作業ファイルで@kbd{C-u C-x v v}とタイプして(@ref{Advanced C-x v
v}を参照してください)、他のブランチのリビジョンIDを入力することにより、ブランチ間を切り替えることもできます。たとえばCVSでは、@dfn{trunk(幹の意。開発の主要ラインを示します)}のリビジョンは通常、1.1、1.2、1.3、@dots{}という形式をもち、最初のブランチがリビジョン1.2から作成された場合、リビジョン1.2は1.2.1.1、1.2.1.2、@dots{}というリビジョンIDをもち、さらに2番目のブランチが同じくリビジョン1.2から作成された場合、それは1.2.2.1、1.2.2.2、@dots{}という形式になります。ブランチのリビジョンIDから最後の部分を除いた(たとえば1.2.1)、@dfn{ブランチID(branch
ID)}を指定して、そのブランチの最新のリビジョンに切り替えることもできます。

  ロックベースのシステムでは、他のブランチに切り替えることにより、作業ツリーのロックが解除(書き込み禁止)になります。

  1度ブランチを切り替えると、そのブランチを他に切り替えるまで、VCコマンドはそのブランチに適用されます。たとえば任意のVCファイルセットをコミットすると、そのブランチにコミットされるようになります。

@node VC Pull
@subsubsection ブランチへの変更の取り込み

@table @kbd
@item C-x v +
分散型のバージョンコントロールシステムでは、他の場所から変更を``pull''することにより、カレントのブランチを更新します。

集中型のバージョンコントロールシステムでは、カレントVCファイルセットを更新します。
@end table

@kindex C-x v +
@findex vc-pull
  分散型のバージョンコントロールシステムでは、コマンド@kbd{C-x v +}
(@code{vc-pull})は、カレントブランチと作業ツリーを更新します。これは通常、リモートのブランチのコピーを更新するのに使用されます。プレフィクス引数を与えた場合、このコマンドは使用する正確なバージョンコントロールコマンドの入力をもとめます。これにより変更をどこからpullするか指定できます。プレフィクス引数を指定しない場合は、バージョンコントロールシステムにより決定される、デフォルトの場所からpullします。

  分散型のバージョンコントロールシステムの中で、現在@kbd{C-x v
+}がサポートするのはBazaar、Git、Mercurialだけです。Bazaarでは、これは通常のブランチにたいしては、(マスターブランチをミラーリングされたブランチにpullするために)@command{bzr
pull}を呼び出し、バインドされたブランチにたいしては、(中心となるリポジトリーからpullするために)@command{bzr
update}を呼び出します。Gitでは、これはリモートのリポジトリーから変更を取得して、それをカレントブランチにマージするために、@command{git
pull}を呼び出します。Mercurialでは、デフォルトのリモートリポジトリーから変更を取得して、作業ディレクトリーを更新するために@command{hg
pull -u}を呼び出します。

  pullする前に@kbd{C-x v I}
(@code{vc-log-incoming})を使用して、適用される変更のlogバッファーを閲覧できます。@ref{VC Change
Log}を参照してください。

  CVSのような集中型のバージョンコントロールシステムでは、@kbd{C-x v +}はリポジトリーからカレントVCファイルセットを更新します。

@node Merging
@subsubsection ブランチのマージ
@cindex merging changes

@table @kbd
@item C-x v m
分散型のバージョンコントロールシステムでは、カレントのブランチに他のブランチの変更をマージします。

集中型のバージョンコントロールシステムでは、カレントVCファイルセットに他のブランチの変更をマージします。
@end table

  ブランチで開発している場合、すでに他のブランチで行われた変更を@dfn{マージ(merge)}する必要があるときがあります。これは2つのブランチでの変更が重なる場合もあるため、些細な操作とはいえません。

  分散型のバージョンコントロールシステムでは、マージはコマンド@kbd{C-x v m}
(@code{vc-merge})により行われます。Bazaarでは、これは@command{bzr
merge}に渡す正確な引数の入力を求めます。そのとき、可能であれば目的にかなったデフォルトを提示します。Gitでは、これはマージするブランチ名の入力を求めます。このとき、(カレントリポジトリーが知っているブランチ名にもとづく)補完を行います。マージコマンドの実行による出力は、他のバッファーに表示されます。

  CVSのような集中型のバージョンコントロールシステムでは、@kbd{C-x v
m}はブランチID、または2つのリビジョンIDの入力を求めます。コマンドはそのブランチからの変更点、または指定した2つのリビジョン間の差分を探して、それらの変更をカレントVCファイルセットにマージします。@key{RET}だけをタイプした場合、Emacsは単にそのファイルをチェックアウトしたブランチに行われた変更をマージします。

@cindex conflicts
@cindex resolving conflicts
  マージを処理した直後は、作業ツリーだけが変更されており、@kbd{C-x v
D}および関連するコマンドで、マージにより生成された変更をレビューできます(@ref{Old
Revisions}を参照してください)。2つのブランチが重なった変更をもつ場合、マージは@dfn{衝突(conflict)}を生成します。その場合、マージコマンドの出力には警告が現れ。影響のある作業ファイルの、衝突する2つの変更の周囲に、@dfn{衝突マーカー(conflict
markers)}が挿入されます。衝突を解決するには、衝突するファイルを編集しなければなりません。編集が終わったら、マージが効果を発揮するように、通常の方法により変更したファイルをコミットしなければなりません(@ref{Basic
VC Editing}を参照してください)。

@node Creating Branches
@subsubsection 新しいブランチの作成

  CVSのような集中型のバージョンコントロールシステムでは、Emacsはコミット操作の一部として、新しいブランチの作成をサポートします。変更されたVCファイルセットをコミットするとき、@kbd{C-u
C-x v v} (@code{vc-next-action}のようにプレフィクス引数を指定します。@ref{Advanced C-x v
v}を参照してください).すると、Emacsは新しいリビジョンのリビジョンIDの入力を求めます。ここでカレントリビジョンから開始するブランチの。適切なブランチIDを指定する必要があります。たとえば、カレントリビジョンIDが2.5の場合、ブランチIDは2.5.1、2.5.2、...となるべきでしょう。ブランチIDは、その時点での既存のブランチの番号に依存します。

  (すでにブランチのヘッドではない)古いリビジョンに新しいブランチを作成するには、最初にそのリビジョンを選択します(@ref{Switching
Branches}を参照してください)。その後の手順は、ロックベースのバージョンコントロールシステムを使っているか、マージベースのものを使っているかで異なります。

  ロックベースのバージョンコントロールシステムでは、@kbd{C-x v
v}で古いリビジョンのブランチを選択します。古いリビジョンを選択する場合、本当に新しいブランチを作成したいのか確認を求めます。これにnoと応えた場合、かわりに最新のリビジョンをロックする機会が与えられます。マージベースのバージョンコントロールシステムでは、このステップはスキップします。

  変更を行なってから、再び@kbd{C-x v
v}とタイプして、新しいリビジョンをコミットします。これは選択されたリビジョンから始まる、新しいブランチを作成します。

  ブランチが作成された後は、それ以降のコミットは、そのブランチに新しいリビジョンを作成します。ブランチを離れるには、@kbd{C-u C-x v
v}で明示的に異なるリビジョンを選択しなければなりません。

@ifnottex
@include vc1-xtra.texi
@end ifnottex

@node Change Log
@section 変更ログ

@cindex change log
  多くのソフトウェアプロジェクトでは、@dfn{変更ログ(change
log)}を管理します。これは通常、いつどのようにして、そのプログラムが変更されたかの日付順の記録を含む、@file{ChangeLog}という名前のファイルです。これらのファイルは、バージョンコントロールシステムに保存された変更ログエントリーから自動的に生成されたり、それらの変更ログエントリーを自動的に生成するのに使われる場合もあります。複数の変更ログファイルがあり、それぞれが1つのディレクトリー、またはディレクトリーツリーに対応する場合もあります。

@menu
* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。
@end menu

@node Change Log Commands
@subsection 変更ログコマンド

@kindex C-x 4 a
@findex add-change-log-entry-other-window
  Emacsコマンド@kbd{C-x 4
a}は、編集しているファイルにたいする新しいエントリーを、変更ログファイルに追加します(@code{add-change-log-entry-other-window})。そのファイルが実際にはバックアップファイルの場合、このコマンドはそのファイルの元のファイルのエントリーを適切に作成します
--- これはカレントバージョンから削除された関数のログエントリーを作成するとき便利です。

  @kbd{C-x 4
a}は変更ログファイルをvisitして、一番最近のエントリーが今日の日付であなたの名前でない場合は、新しいエントリーを作成します。これはカレントファイルにたいする、新しいアイテムも作成します。このコマンドは多くの言語にたいして、変更された関数またはその他のオブジェクトを推測することすらできます。

@vindex add-log-keep-changes-together
  変数@code{add-log-keep-changes-together}が非@code{nil}の場合、@kbd{C-x 4
a}は新しいアイテムを開始せず、そのファイルにたいする既存のアイテムに追加します。

同じ性質の複数の変更を1つにまとめることができます。最初の@kbd{C-x 4 a}の後にテキストを何も入力せずに、続けて@kbd{C-x 4
a}をタイプしていくと、他のシンボルが変更ログエントリーに追加されます。

@vindex add-log-always-start-new-record
  @code{add-log-always-start-new-record}が非@code{nil}の場合、最後のエントリーが同じ日付のあなたによる変更だったときでも、@kbd{C-x
4 a}は常に新しいエントリーを作成します。

@vindex change-log-version-info-enabled
@vindex change-log-version-number-regexp-list
@cindex file version in change log entries
  変数@code{change-log-version-info-enabled}の値が非@code{nil}の場合、@kbd{C-x 4
a}は、ファイルのバージョン番号を変更ログのエントリーに追加します。これは変数@code{change-log-version-number-regexp-list}の正規表現を使用して、ファイルの最初の10%から、バージョン番号を探します。

@cindex Change Log mode
@findex change-log-mode
  変更ログファイルは、Change
Logモードでvisitされます。このメジャーモードでは、グループ化されたアイテムの集まりは1つのパラグラフと扱われ。各エントリーはページとみなされます。これはエントリーの編集を容易にします。@kbd{C-j}およびauto-fillは、新しい行を前の行と同様にインデントします。これはエントリーの内容を入力するとき便利です。

Change Logモードがオンの場合、@code{next-error}コマンド(デフォルトでは@kbd{C-x
`}にバインドされています)を使用して、変更ログのエントリー間を移動することができます。次の変更ログエントリーだけでなく、そのファイルが変更された実際の場所にジャンプすることもあるでしょう。同じリストを戻って移動するのに、@code{previous-error}を使うこともできます。

@findex change-log-merge
  コマンド@kbd{M-x change-log-merge}を使用して、他のログファイルを、エントリーの日付順を保持したまま、Change
Logモードのバッファーにマージできます。

  プログラムの変更を追跡して変更ログを維持する他の方法として、バージョンコントロールシステムがあります。VC logバッファーでは、@kbd{C-c
C-a}
(@code{log-edit-insert-changelog})とタイプすると、変更ログが存在する場合は、関連する変更ログのエントリーを追加します。

@node Format of ChangeLog
@subsection ChangeLogの書式

  変更ログエントリーは、現在の日付、名前(変数@code{add-log-full-name}より取得)、電子メールアドレス(変数@code{add-log-mailing-address}より取得)を含むヘッダー行から開始されます。ヘッダー行を除いた変更ログの各行は、スペースまたはタブで開始されます。エントリーの大部分は、空白文字とアスタリスクで行が開始される、@dfn{アイテム(items)}から構成されます。以下は2つのアイテムおよび1つのアイテムをもつ、日付が1993年5月の、2つのエントリーの例です。

@iftex
@medbreak
@end iftex
@smallexample
1993-05-25  Richard Stallman  <rms@@gnu.org>

        * man.el: Rename symbols `man-*' to `Man-*'.
        (manual-entry): Make prompt string clearer.

        * simple.el (blink-matching-paren-distance):
        Change default to 12,000.

1993-05-24  Richard Stallman  <rms@@gnu.org>

        * vc.el (minor-mode-map-alist): Don't use it if it's void.
        (vc-cancel-version): Doc fix.
@end smallexample

  1つのエントリーで複数の変更を記述できます。変更はそれぞれアイテム、またはアイテムの中の行を占めます。アイテムの間には通常、空行があります。アイテムが関連している場合(異なる場所での同じ変更など)、それらの間に空行を置かずにそれらをグループ化します。

  変更ログファイルの最後には、著作権表示と使用許諾を配すべきです。以下は例です:

@smallexample
Copyright 1997, 1998 Free Software Foundation, Inc.
Copying and distribution of this file, with or without modification, are
permitted provided the copyright notice and this notice are preserved.
@end smallexample

@noindent
これはもちろん、正しい年と版権所有者に置き換えて使う必要があります。

@node Tags
@section タグテーブル
@cindex tags and tag tables

  @dfn{タグ(tag)}とは、プログラムまたはドキュメント内のサブユニットにたいするリファレンスです。ソースコードではタグは、関数サブルーチン、データ型、マクロなどのプログラムの構文要素を参照します。ドキュメントではチャプター、セクション、アペンディクスなどを参照します。タグは対応するサブユニットが定義されているファイルの場所と、サブユニットがファイルのどこで定義されているかを指定します。

  @dfn{タグテーブル(tags
table)}は、特定のプログラムまたはドキュメントのソースコードをスキャンすることにより抽出されたタグを記録します。生成されたファイルから抽出されたタグは、タグ抽出の際にスキャンされる生成されたファイルではなく、その元になるファイルを参照します。生成されたファイルの例として、Cwebソース、Yaccパーサー、Lexスキャナー定義から生成されたCファイルや、プリプロセスされたCファイルの@file{.i}、@file{.fpp}ソースファイルをプリプロセスすることにより生成されるFortranファイルがあります。

@cindex etags
  タグテーブルを生成するには、ドキュメントまたはソースコードファイルにたいして、シェルコマンド@command{etags}を実行します。@samp{etags}プログラムは、@dfn{タグテーブルファイル(tags
table file)}、または略記して@dfn{タグファイル(tags
file)}にタグを書き込みます。タグファイルは慣習的に@file{TAGS}という名前です。@ref{Create Tags
Table}を参照してください。

  Emacsは、タグテーブルに記録された情報を使用して検索や置換を行う、多くのコマンドを提供します。たとえば@kbd{M-.}
(@code{find-tag})は、指定した関数にたいして、それのソースファイルの関数定義の場所にジャンプします。@ref{Find
Tag}を参照してください。

@cindex C++ class browser, tags
@cindex tags, C++
@cindex class browser, C++
@cindex Ebrowse
  Ebrowse機能は@command{etags}に似ていますが、C++に特化したものです。@ref{Top,, Ebrowse, ebrowse,
Ebrowse User's Manual}を参照してください。
Semanticパッケージは、@command{etags}機能とは別の、タグを生成して使用する他の方法を提供します。@ref{Semantic}を参照してください。

@menu
* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        @command{etags}によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した任意タグの作成。
* Select Tags Table::        タグテーブルをvisitする方法。
* Find Tag::                 特定のタグの定義を見つけるコマンド。
* Tags Search::              検索と置換にたいしてタグテーブルを使う。
* List Tags::                補完および補完候補の一覧にタグを使う。
@end menu

@node Tag Syntax
@subsection ソースファイルタグの構文

  以下は、もっともポピュラーな言語でタグ構文が定義される方法です:

@itemize @bullet
@item
Cコードでは、Cの関数やtypedefはタグなので、@code{struct}、@code{union}、@code{enum}の定義もタグです。タグテーブルを作成するとき、@samp{--no-defines}を指定しなければ、@code{#define}マクロ定義、@code{#undef}および@code{enum}定数もタグになります。同様に、@samp{--no-globals}を指定しなければグローバル変数もタグで、@samp{--no-members}を指定していなければ構造体のメンバーもタグです。@samp{--no-globals}、@samp{--no-defines}、@samp{--no-members}を使用することにより、タグテーブルを小さくすることができます。

@command{etags}に@samp{--declarations}オプションを与えることにより、関数定義(function
definitions)に加えて、関数宣言(function declarations)と外部変数(external
variables)もタグ付けできます。

@item
C++コードでは、Cコードのすべてのタグ構成に加えて、メンバー関数も認識されます。@samp{--no-members}オプションを使用しなければ、メンバー変数も認識されます。クラスの変数および関数にたいするタグは、@samp{@var{class}::@var{variable}}および@samp{@var{class}::@var{function}}という名前になります。@code{演算子(operator)}定義は@samp{operator+}のような名前になります。

@item
Javaコードでは、C++で認識されるのすべてのタグ構成に加えて、@code{interface}、@code{extends}、@code{implements}もタグとして認識されます。クラスの変数および関数にたいするタグは、@samp{@var{class}.@var{variable}}および@samp{@var{class}.@var{function}}という名前になります。

@item
@LaTeX{}ドキュメントでは、@code{\chapter}、@code{\section}、@code{\subsection}、@code{\subsubsection}、@code{\eqno}、@code{\label}、@code{\ref}、@code{\cite}、@code{\bibitem}、@code{\part}、@code{\appendix}、@code{\entry}、@code{\index}、@code{\def}、@code{\newcommand}、@code{\renewcommand}、@code{\newenvironment}、@code{\renewenvironment}にたいする引数がタグになります。

@command{etags}を呼び出す前に、環境変数@env{TEXTAGS}で指定することにより、他のコマンドも同様にタグにできます。この環境変数の値には、コロンで区切られたコマンド名のリストを指定します。たとえば、

@example
TEXTAGS="mycommand:myothercommand"
export TEXTAGS
@end example

@noindent
これは、(Bourneシェルの構文の使用して)コマンド@samp{\mycommand}と@samp{\myothercommand}もタグとして定義します。

@item
Lispコードでは、@code{defun}で定義された任意の関数、@code{defvar}および@code{defconst}で定義された任意の変数、および一般的に列0から@samp{(def}で始まる任意の式の最初の引数はタグです。例外として@code{(defvar
@var{foo})}という形式の式は、宣言として扱われ、@samp{--declarations}オプションが与えられたときだけタグになります。

@item
Schemeコードでは、@code{def}で定義されたすべて、または名前が@samp{def}で始まる構成がタグに含まれます。これらは、ファイルのトップレベルで@code{set!}でセットされる変数も含まれます。
@end itemize

  他の言語もいくつかサポートされます:

@itemize @bullet

@item
Adaコードでは、関数(functions)、プロシージャー(procedures)、パッケージ(packages)、タスク(tasks)、タイプ(types)がタグです。@samp{--packages-only}オプションを使用することにより、タグをパッケージにたいしてだけ作成できます。

Adaでは、異なる種類のエンティティー(たとえば関数とプロシージャー)に、同じ名前を使うことができます。またパッケージ、プロシージャー、関数と似たものに、スペック(spec、たとえばinterface)およびボディー(body、たとえばimplementation)があります。欲しい定義を簡単に取り出すために、Adaのタグ名にはエンティティーのタイプを示す接尾辞がつきます:

@table @samp
@item /b
パッケージのボディー(package body)。
@item /f
関数(function)
@item /k
タスク(task)。
@item /p
プロシージャー(procedure)。
@item /s
パッケージのスペック(package spec)。
@item /t
タイプ(type)。
@end table

  したがって、@kbd{M-x find-tag @key{RET} bidule
@key{RET}}は単に@code{bidule}という任意のタグを検索しますが、@kbd{M-x find-tag @key{RET}
bidule/b @key{RET}}は直接パッケージ@code{bidule}のボディーに移動します。

@item
アセンブラーコードでは、行の開始に現れ、後にコロンが続くラベルがタグです。

@item
BisonまたはYaccの入力ファイルでは、各構文規則で定義する非終端記号がタグです。ファイル内に含まれるCコードの部分は、Cコードとして解析します。

@item
Cobolコードでは、タグはパラグラフ名なので、列8から始まり、後にピリオドが続く任意の単語がタグです。

@item
Erlangコードでは、ファイルで定義された関数(functions)、レコード(records)、マクロ(macros)がタグです。

@item
Fortranコードでは、サブルーチン(subroutines)およびブロックデータ(block data)がタグです。

@item
HTML入力ファイルでは、@code{title}、および@code{h1}、@code{h2}、@code{h3}ヘッダーがタグです。アンカー内の@code{name=}、およびすべての@code{id=}もタグです。

@item
Lua入力ファイルでは、すべての関数(functions)がタグです。

@item
makefileでは、ターゲット(targets)がタグで、@samp{--no-globals}を指定しなければ変数(variables)もタグです。

@item
Objective Cコードでは、クラスにたいするObjective C定義、クラスカテゴリー(class
categories)、メソッド(methods)、プロトコル(protocols)が含まれます。クラスの変数および関数にたいするタグの名前は、@samp{@var{class}::@var{variable}}および@samp{@var{class}::@var{function}}になります。

@item
Pascalコードでは、ファイル内で定義された関数およびプロシージャーがタグです。

@item
Perlコードでは、パッケージ、サブルーチン、変数がタグで、キーワード@code{package}、@code{sub}、@code{use
constant}、@code{my}、@code{local}で定義されます。グローバル変数をタグ付けしたい場合、@samp{--globals}を使用します。サブルーチンにたいするタグの名前は、@samp{@var{package}::@var{sub}}になります。デフォルトのパッケージで定義されたサブルーチンの名前は、@samp{main::@var{sub}}になります。

@item
PHPコードでは、関数(functions)、クラス(classes)、定義(defines)がタグです。@samp{--no-members}オプションを使用しなければ、変数(vars)もタグです。

@item
PostScriptコードでは、関数がタグです。

@item
Prologコードでは、行頭の述語(predicates)とルール(rules)がタグです。

@item
Pythonコードでは、行頭の@code{def}および@code{class}はタグを生成します。
@end itemize

  他の書式や言語を扱うために、regexpにたいするマッチにもとづいてタグを生成することもできます(@ref{Etags
Regexps}を参照してください)。

@node Create Tags Table
@subsection タグテーブルの作成
@cindex @command{etags} program

  @command{etags}プログラムは、タグテーブルファイルを作成するために使用されます。このコマンドは、
@iftex
前のセクションで説明している複数の構文を理解します。
@end iftex
@ifnottex
@ref{Tag Syntax}で説明している複数の構文を理解します。
@end ifnottex
以下は@command{etags}を実行する方法です:

@example
etags @var{inputfiles}@dots{}
@end example

@noindent
@command{etags}プログラムは、指定されたファイルを読み込んで、カレント作業ディレクトリーの@file{TAGS}という名前のファイルに、タグテーブルを書き込みます。@samp{--output=@var{file}}オプションを使用して、タグテーブルに異なる名前のファイル名を指定することもできます。ファイル名に@file{-}を指定すると、タグテーブルを標準出力に出力します。

  指定されたファイルが見つからない場合、@command{etags}はそれらの圧縮されたバージョンを探して、それらを解凍して読み込みます。MS-DOSでは、コマンドラインに@samp{mycode.c}が与えられ、@samp{mycode.c}が存在しないとき、@command{etags}は@file{mycode.cgz}のような名前のファイルを探します。

  ファイルの内容が変更されてタグテーブルが古くなったときは、@command{etags}を再び実行することにより、タグテーブルを更新できます。タグテーブルにタグが記録されていなかったり、間違ったファイルにたいして記録している場合、タグテーブルを更新するまで、Emacsはそれの定義を見つけることができません。しかしタグに記録されている位置が、(編集により)少し間違っているようなときは、少しの遅れは生じますがEmacsは正しい位置を見つけることができます。

   したがって、編集するたびにタグテーブルを更新する必要はありません。リストしたい新しいタグを定義したときや、タグ定義をあるファイルから他のファイルへ移動したとき、または大幅な変更を施したときは、タグテーブルを更新するべきです。

  @command{etags}に@samp{--include=@var{file}}オプションを渡すことにより、タグテーブルに他のタグテーブルを@dfn{インクルード(include)}できます。これによりインクルードされたタグファイルでカバーされる、すべてのファイルをカバーできます。

  @command{etags}を実行するとき、ソースファイルを相対ファイル名で指定した場合、タグファイルには、そのタグファイルが最初に書き込まれたディレクトリーにたいする相対ファイル名が含まれます。この方法を使えば、ディレクトリーツリー全体を移動しても、タグファイルは正しくソースファイルを参照します。しかしタグファイルが@file{-}または@file{/dev}のときは、ファイル名はカレント作業ディレクトリーにたいする相対ファイル名になります。これはタグを@file{/dev/stdout}に書き込むときに便利です。

  相対ファイル名を使う場合、違うディレクトリーにあるタグファイルを指すシンボリックリンクを指定するべきではありません。なぜならこれは一般的にファイル名を無効にするからです。

  @command{etags}の引数に絶対ファイル名を指定した場合、タグファイルには絶対ファイル名が含まれます。この方法では、ソースファイルが同じ場所にある限り、タグファイルを移動してもタグファイルは同じ名前を参照します。絶対ファイル名は@samp{/}で開始されるか、MS-DOSおよびMS-Windowsでは@samp{@var{device}:/}で開始されます。

   非常に大きな数のファイルからタグテーブルを作成したい場合、それをコマンドラインに指定すると問題が発生するかもしれません。なぜならコマンドライン引数の長さに制限のあるシステムもあるからです。この制限は、以下のようにファイル名の場所にダッシュを指定して、@command{etags}にファイル名を標準入力から読み込むように指示して回避することができます。

@smallexample
find . -name "*.[chCH]" -print | etags -
@end smallexample

  @command{etags}はファイル名とファイル内容にもとづいて、入力ファイルで使用されている言語を認識します。@samp{--language=@var{name}}オプションで、明示的に言語を指定できます。このオプションはファイル名に混ぜることができます。各指定はその後に続くファイル名に適用されます。@samp{--language=auto}の指定は、ファイル名とファイル内容から言語を推測するよう@command{etags}に指示します。@samp{--language=none}を指定すると、言語に特有の処理を完全にオフに切り替えます。この場合、@command{etags}はregexpのマッチングだけでタグを認識します(@ref{Etags
Regexps}を参照してください)。

  オプション@samp{--parse-stdin=@var{file}}は、@command{etags}をプログラムから呼び出すときに便利です。これは、(1回だけ)コマンドラインからファイル名を読み取るとき使用できます。@command{etags}は標準入力から読み取り、生成されたタグがファイル@var{file}に属するとマークします。

  @samp{etags
--help}オプションは@command{etags}が認識する言語と、言語を推測するためのファイル名ルールのリストを出力します。これは利用可能な@command{etags}オプションと、簡単な説明のリストも出力します。このオプションの後に、1つ以上の@samp{--language=@var{lang}}を指定すると、@var{lang}にたいするタグの生成方法の詳細を出力します。

@node Etags Regexps
@subsection EtagsのRegexps

  @samp{--regex}オプションは、正規表現のマッチにもとづいて@command{etags}がタグを認識できるようにします。このオプションはファイル名と混ぜることができます。オプションは、それぞれのオプション後に続くソースファイルに適用されます。複数の@samp{--regex}を指定した場合、それらすべては並列に使用されます。構文は以下のとおりです:

@smallexample
--regex=[@var{@{language@}}]/@var{tagregexp}/[@var{nameregexp}/]@var{modifiers}
@end smallexample

@noindent
オプション値の肝心な部分は@var{tagregexp}で、これはタグにマッチするregexpです。これは常に位置が固定されており、行の開始だけにマッチします。インデントされたタグの場合、最初の空白文字にマッチさせるために、@samp{[
\t]*}で始まるregexpを使用します。

  これらの正規表現では、@samp{\}は次の文字をクォートします。またGCCのエスケープ文字シーケンスのすべて、すなわち@samp{\a}(bell)、@samp{\b}(back
space)、@samp{\d}(delete)、@samp{\e}(escape)、@samp{\f}(formfeed)、@samp{\n}(newline)、@samp{\r}(carriage
return)、@samp{\t}(tab)、and @samp{\v}(vertical tab)がサポートされます。

  理想的には、@var{tagregexp}はタグとして認識させるのに必要な文字以上にマッチさせるべきではありません。構文がそれを求める場合、タグより多くの文字にマッチする@var{tagregexp}を記述して、そのマッチからタグだけをピックアップするために、@var{nameregexp}を追加するべきです。これはEmacsがより正しくタグを見つけて、タグ名の補完をより確実にすることを可能にします。

  @var{modifiers}(修飾子)は、@command{etags}がマッチングを行う方法を変更するための0文字以上の文字シーケンスです。修飾子がないregexpは、大文字小文字を区別する方法で、入力ファイルの各行にたいして順番に適用されます。修飾子とその意味は以下のとおりです:

@table @samp
@item i
このregexpのマッチングで、大文字小文字を無視します。
@item m
この正規表現はファイル全体にマッチするので、複数行のマッチが可能です。
@item s
この正規表現はファイル全体にマッチし、@var{tagregexp}内の@samp{.}は改行にマッチします。
@end table

  @samp{-R}オプションは、それの前に@samp{--regex}で定義されたregexpをすべて取り消します。これは後に続くファイル名にも適用されます。以下は例です:

@smallexample
etags --regex=/@var{reg1}/i voo.doo --regex=/@var{reg2}/m \
    bar.ber -R --lang=lisp los.er
@end smallexample

@noindent
この例では、@command{etags}は@file{voo.doo}と@file{bar.ber}にたいして。ファイル内容に一致する解析用の言語を選択します。@command{etags}は、@file{voo.doo}内の追加のタグを認識するために@var{reg1}も使用し、@file{bar.ber}内の追加のタグを認識するために@var{reg1}と@var{reg2}の両方を使用します。@file{voo.doo}と@file{bar.ber}の各行にたいして大文字小文字を区別せずに@var{reg1}がチェックされ、@file{bar.ber}のファイル全体にたいして大文字小文字を区別して@var{reg2}がチェックされ、これは複数行へのマッチが許されます。@file{los.er}のタグの認識にはユーザー指定のregexpマッチは行わず、Lispのタグルールだけが使用されます。

  オプションのプレフィクス@var{@{language@}}を使用して、与えられた言語だけに@samp{--regex}オプションを制限できます(@samp{etags
--help}で@command{etags}が認識する言語のリストが表示されます)。これはファイルに、@command{etags}にたいして事前に定義された多くの正規表現が含まれている場合に便利です。以下の例は、EmacsのC言語のソースファイルの@code{DEFVAR}マクロにたいするタグです:

@smallexample
--regex='@{c@}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'
@end smallexample

@noindent
正規表現が複雑な場合、そのリストをファイルに保存することができます。以下のオプション構文は、@command{etags}に正規表現が保存された2つのファイルを指示します。2つ目のファイルに含まれる正規表現は、大文字小文字を区別せずにマッチします。

@smallexample
--regex=@@@var{case-sensitive-file} --ignore-case-regex=@@@var{ignore-case-file}
@end smallexample

@noindent
@command{etags}にたいするregexファイルは、行ごとに1つの正規表現を含みます。空行およびスペースかタブで始まる行は無視されます。表の開始が@samp{@@}の場合、@command{etags}はその行の残りを他の正規表現ファイルとみなすので、そのようなファイルを他のファイルをインクルードできます。他のすべての行は正規表現です。最初の非空白文字が@samp{--}の場合、その行はコメントです。

  たとえば、以下の内容の@samp{emacs.tags}という名前のファイルを作成できます:

@smallexample
        -- This is for GNU Emacs C source files
@{c@}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/
@end smallexample

@noindent
これは以下のように使用します:

@smallexample
etags --regex=@@emacs.tags *.[ch] */*.[ch]
@end smallexample

  さらに例を示しましょう。regexpはシェルから解釈され内容にクォートされています。

@itemize @bullet

@item
Octaveファイルのタグ:

@smallexample
etags --language=none \
      --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
      --regex='/###key \(.*\)/\1/' \
      --regex='/[ \t]*global[ \t].*/' \
      *.m
@end smallexample

@noindent
タグはスクリプトにたいして生成されるので、そのスクリプトにジャンプしたいときは、あなた自身で@samp{###key
@var{scriptname}}という形式の行を追加する必要があることに注意してください。

@item
Tclファイルのタグ:

@smallexample
etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl
@end smallexample

@item
VHDLファイルのタグ:

@smallexample
etags --language=none \
  --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
  --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
  \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'
@end smallexample
@end itemize

@node Select Tags Table
@subsection タグテーブルの選択

@findex visit-tags-table
  Emacsは常に、@dfn{選択された}タグテーブルを1つもちます。タグテーブルにたいして機能するすべてのコマンドは、選択されたタグテーブルを使用します。タグテーブルを選択するには、@kbd{M-x
visit-tags-table}とタイプします。これは、引数としてタグテーブルファイル名を読み取ります。デフォルトディレクトリーの@file{TAGS}がデフォルトです。

@vindex tags-file-name
  Emacsは、タグテーブルを使用するまでは実際にタグテーブルの内容を読み込みません。@code{visit-tags-table}が行うのは、ファイル名を変数@code{tags-file-name}に格納するのがすべてなので、あなた自身でこの変数をセットしても同じことができます。この変数の初期値は@code{nil}です。この変数の値は、タグテーブルにたいして機能するすべてのコマンドに、使用するタグテーブルファイル名を知らせます。

  タグテーブルがすでにロードされているときに@code{visit-tags-table}を使用すると、2つの選択肢が与えられます。つまり、タグテーブルのカレントリストに新しいタグを追加するか、あるいは新しいリストを開始することもできます。タグコマンドは、カレントリストのすべてのタグテーブルを使用します。新しいリストを開始した場合、他のものの@emph{かわりに}、新しいタグテーブルが使用されます。カレントリストに新しいタグテーブルを追加した場合、それは他のものと@emph{同じように}使用されます。

@vindex tags-table-list
  以下のようにして、変数@code{tags-table-list}に文字列のリストをセットすることにより、タグテーブルのリストを正確に指定できます:

@c keep this on two lines for formatting in smallbook
@example
@group
(setq tags-table-list
      '("~/emacs" "/usr/local/lib/emacs/src"))
@end group
@end example

@noindent
これは、タグコマンドが@file{TAGS}ファイルを、@file{~/emacs}ディレクトリーと@file{/usr/local/lib/emacs/src}ディレクトリーから探すよう指示します。上記で説明したように、順序は、対象にしているファイルと、どのタグテーブルがそのファイルを記述しているかに依存します。

  @code{tags-file-name}と@code{tags-table-list}の両方をセットしてはいけません。

@node Find Tag
@subsection タグの検索

  タグテーブルが可能にすることの中で一番重要なのは、指定したタグの定義を探すことです。

@table @kbd
@item M-.@: @var{tag} @key{RET}
@var{tag}の最初の定義を探します(@code{find-tag})。
@item C-u M-.
最後に指定したタグにたいして、次の候補の定義を探します。
@item C-u - M-.
前に見つかったタグに戻ります。
@item C-M-. @var{pattern} @key{RET}
@var{pattern}にマッチする名前のタグを探します(@code{find-tag-regexp})。
@item C-u C-M-.
最後に使用したパターンにマッチする名前のタグを探します。
@item C-x 4 .@: @var{tag} @key{RET}
@var{tag}の最初の定義を探して、他のウィンドウに表示します(@code{find-tag-other-window})。
@item C-x 5 .@: @var{tag} @key{RET}
@var{tag}の最初の定義を探して、新しいフレームを作成してそのバッファーを選択します(@code{find-tag-other-frame})。
@item M-*
前に@kbd{M-.}または同種のコマンドを呼び出した場所に戻ります。
@end table

@kindex M-.
@findex find-tag
  @kbd{M-.}
(@code{find-tag})はタグ名の入力を求め、それのソース定義にジャンプします。これはタグテーブルからタグのファイルと、おおよその文字位置を検索して、そのファイルをvisitし、記録されたおおよその位置から、範囲を広げながらタグ定義の検索をします。

  @kbd{M-.}の引数にタグを入力するとき、通常のミニバッファーの補完コマンドを使用できます(@ref{Completion}を参照してください)。補完では、選択されたタグテーブルのタグ名が補完候補になります。空の引数を指定した場合、ポイント位置またはその前の、対応がとれた式がデフォルトの引数になります。@ref{Expressions}を参照してください。

  @kbd{M-.}に、タグの完全な名前を与える必要はありません。名前の一部で充分です。@kbd{M-.}は、引数を部分文字列として含むタグを探します。しかし部分文字列にたいするマッチより、正確なマッチの方が好ましいです。同じ部分文字列にマッチする他のタグを探すには、@kbd{C-u
M-.}または@kbd{M-0
M-.}のように、@code{find-tag}に数引数を与えます。これはタグ名を読み取らず、最後に使用されたのと同じ部分文字列を含む他のタグにたいして、タグテーブルのテキストの検索を継続します。

@kindex C-x 4 .
@findex find-tag-other-window
@kindex C-x 5 .
@findex find-tag-other-frame
  バッファーを切り替えるほとんどのコマンドと同様に、@code{find-tag}は新しいバッファーを他のウィンドウ、または新しいバッファーのために新しいフレームを作成する変種をもっています。前者は@w{@kbd{C-x
4 .}} (@code{find-tag-other-window})、後者は@w{@kbd{C-x 5 .}}
(@code{find-tag-other-frame})です。

  前のタグ定義に戻るには@kbd{C-u -
M-.}を使用します。より一般的には、@kbd{M-.}に負の数引数を指定します。同様に@w{@kbd{C-x 4
.}}に負の引数を指定すると、他のウィンドウで前のタグ位置を探します。

@kindex M-*
@findex pop-tag-mark
@vindex find-tag-marker-ring-length
  最近探したタグの位置に戻るのと同様に、@kbd{M-*}
(@code{pop-tag-mark})を使用して、それらを探すのを始めた場所に戻ることができます。したがって何かにたいして@kbd{M-.}で探して調べた後、@kbd{M-*}で元の場所に戻ることができます。

  @kbd{C-u -
M-.}および@kbd{M-*}は、@code{find-tag-marker-ring-length}により決定される深さで、それまでのステップを遡ることができます。

@findex find-tag-regexp
@kindex C-M-.
  コマンド@kbd{C-M-.}
(@code{find-tag-regexp})は、指定した正規表現にマッチするタグをvisitします。これは@kbd{M-.}と同じですが、部分文字列にたいするマッチではなく、regexpにたいするマッチです。

@node Tags Search
@subsection タグテーブルの検索と置換
@cindex search and replace in multiple files
@cindex multiple-file search and replace

  このセクションのコマンドは、選択されたタグテーブルにリストされたファイルを、1つずつvisitして検索します。これらのコマンドにたいして、タグテーブルは検索する一連のファイルを指定するためだけに使用されます。これらのコマンドは、タグテーブルのリストの最初のタグテーブルから、(もしあれば)カレントファイルを記述するものを走査して、そこからリストの最後まで進めて、その後リストの先頭からリストのすべてのタグテーブルをカバーするまで走査します。

@table @kbd
@item M-x tags-search @key{RET} @var{regexp} @key{RET}
選択されたタグテーブルのファイルから、@var{regexp}を検索します。
@item M-x tags-query-replace @key{RET} @var{regexp} @key{RET} @var{replacement} @key{RET}
選択されたタグテーブルの各ファイルにたいして、@code{query-replace-regexp}を実行します。
@item M-,
ポイントのカレント位置から上記のコマンドの1つを再開します(@code{tags-loop-continue})。
@end table

@findex tags-search
  @kbd{M-x
tags-search}は、ミニバッファーを使用してregexpを読み取り、選択されたタグテーブルのすべてのファイルから、1ファイルずつマッチを検索します。これは検索しているファイル名を表示するので、進行状況を確認することができます。マッチが見つかった場合、@code{tags-search}はリターンします。

@kindex M-,
@findex tags-loop-continue
  1つのマッチが見つかったら、おそらく残りのすべてについても検索したいと思うでしょう。@kbd{M-,}
(@code{tags-loop-continue})とタイプすると、多くのマッチを探すために@code{tags-search}を再開します。これはカレントバッファーの残りの部分を検索して、その後タグテーブルの残りのファイルを検索します。

@findex tags-query-replace
  @kbd{M-x
tags-query-replace}は、タグテーブルのすべてのファイルにたいして、1つの@code{query-replace-regexp}を実行します。これは、通常の@kbd{M-x
query-replace-regexp}と同様、検索するregexpと、それを置換する文字列を読み取ります。この検索はむしろ@kbd{M-x
tags-search}に似ていますが、入力へのマッチを繰り返し処理します。問い合わせ付き置換については、@ref{Query
Replace}を参照してください。

@vindex tags-case-fold-search
@cindex case-sensitivity and tags search
  変数@code{tags-case-fold-search}の値をカスタマイズすることにより、タグ検索コマンドの大文字小文字の扱いを制御できます。デフォルトには、@code{case-fold-search}の値と同じ設定が使用されます(@ref{Search
Case}を参照してください)。

  1回の@kbd{M-x
tags-query-replace}の呼び出しで、タグテーブルのすべてのファイルを検索することが可能です。しかし、一時的に検索を抜けられると便利なときもあります。これは、問い合わせ付き置換として特別な意味をもたない入力イベントで行うことができます。つづけて問い合わせ付き置換を再開するには、@kbd{M-,}とタイプします。このコマンドは、最後のタグ検索または置換コマンドを再開します。たとえばカレントファイルの残りをスキップするには、@kbd{M->
M-,}とタイプします。

  このセクションのコマンドは、@code{find-tag}系の検索より広範な検索を行います。@code{find-tag}コマンドは、部分文字列または正規表現にマッチするタグ定義だけを検索します。コマンド@code{tags-search}および@code{tags-query-replace}は、通常の検索および置換コマンドがカレントバッファーにたいして行うように、すべてのマッチを検索します。

  これらのコマンドは、(それらがすでにEmacsバッファーでvisitされていなければ)検索する必要があるファイルのために、一時的なバッファーを作成します。マッチが見つからないバッファーは、速やかにkillされます。そうでない場合は残されます。

  @code{tags-search}のかわりに、サブプロセスとして@command{grep}を実行して、Emacsにマッチした行を1つずつ表示させることができます。@ref{Grep
Searching}を参照してください。

@node List Tags
@subsection タグテーブルの照会

@table @kbd
@item C-M-i
@itemx M-@key{TAB}
タグテーブルがロードされているときは、選択されたタグテーブルを使って、ポイント周囲のテキストの置換を行います(@code{completion-at-point})。
@item M-x list-tags @key{RET} @var{file} @key{RET}
プログラムファイル@var{file}で定義されているタグのリストを表示します。
@item M-x tags-apropos @key{RET} @var{regexp} @key{RET}
@var{regexp}にマッチする、すべてのタグのリストを表示します。
@end table

@cindex completion (symbol names)
  プログラミング言語のモードのほとんどでは、@kbd{C-M-i}または@kbd{M-@key{TAB}}
(@code{completion-at-point})とタイプして、ポイント位置のシンボルを補完できます。選択されたタグテーブルがある場合、このコマンドは補完候補を生成するためにそれを使用することができます。@ref{Symbol
Completion}を参照してください。

@findex list-tags
  @kbd{M-x
list-tags}は、選択されたタグテーブルでカバーされたファイルの名前を1つ読み取り、そのファイルで定義されたタグのリストを表示します。タグテーブルに記録されたファイル名にディレクトリーが含まれない場合は、ファイル名にディレクトリーを含めないでください。

@findex tags-apropos
@vindex tags-apropos-verbose
@vindex tags-tag-face
@vindex tags-apropos-additional-actions
  @kbd{M-x
tags-apropos}は、タグにたいする@code{apropos(適切な)}のようなものです(@ref{Apropos}を参照してください)。これは、選択されたタグテーブルのエントリーが@var{regexp}にマッチするタグのリストを表示します。変数@code{tags-apropos-verbose}が非@code{nil}の場合、タグ名と一緒にタグファイル名も表示します。フェイスにたいする変数@code{tags-tag-face}をセットすることにより、出力の外観をカスタマイズできます。変数@code{tags-apropos-additional-actions}をカスタマイズすることにより、追加の出力を表示できます。詳細は、変数のドキュメントを参照してください。

@findex next-file
  @kbd{M-x
next-file}は、選択されたタグテーブルでカバーされるファイルをvisitします。最初に呼び出したとき、テーブルでカバーされた最初のファイルをvisitします。続けて呼び出すことにより、次のカバーされたファイルをvisitしていきます。プレフィクス引数を指定した場合、最初のファイルに戻ります。

@node EDE
@section Emacs開発環境
@cindex EDE (Emacs Development Environment)
@cindex Emacs Development Environment
@cindex Integrated development environment

EDE(@dfn{Emacs Development Environment:
Emacs開発環境})は、Emacsでの大きなプログラムの作成、ビルド、デバッグなどのタスクを単純化するパッケージです。これはEmacsにおいて、IDE(@dfn{Integrated
Development Environment: 統合開発環境})の機能をいくつか提供します。

このセクションは、EDEの簡単な説明を提供します。
@ifnottex
完全な詳細については、@ref{Top, EDE,, ede, Emacs Development Environment}を参照してください。
@end ifnottex
@iftex
EDEの完全な詳細は、@kbd{C-h i}とタイプしてEDEのマニュアルを選択してください。
@end iftex

  EDEは、グローバルなマイナーモードとして実装されています(@ref{Minor Modes}を参照してください)。有効にするには@kbd{M-x
global-ede-mode}とタイプするか、@samp{Tools}メニューの@samp{Project Support
(EDE)}アイテムをクリックします。以下の行をinitファイルに追加することにより、Emacs開始時にEDEを有効にすることもできます。

@smallexample
(global-ede-mode t)
@end smallexample

@noindent
EDEを有効にすることにより、メニューバーに@samp{Development}という名前のメニューが追加されます。以下で説明するコマンドを含めて、多くのEDEコマンドをこのメニューから呼び出すことができます。

  EDEは、ファイルを@dfn{プロジェクト(projects)}に編成します。プロジェクトはディレクトリーに対応します。@dfn{プロジェクトルート(project
root)}は、プロジェクトの最上層のディレクトリーです。新しいプロジェクトを定義するには、プロジェクトルートのファイルをvisitして、@kbd{M-x
ede-new}とタイプします。このコマンドは@dfn{プロジェクトタイプ(project
type)}の入力を求めます。これはEDEがプロジェクトを背後で管理する方式です(@ref{Creating a project, EDE,, ede,
Emacs Development
Environment}を参照してください)。もっとも一般的なプロジェクトタイプは、Makefilesを使用する@samp{Make}、およびGNU
Automake(@ref{Top, Automake,, automake,
Automake}を参照してください)を使用する@samp{Automake}です。どちらの場合も、EDEはプロジェクトに関する情報を格納する、@file{Project.ede}という名前のファイルを作成します。

  プロジェクトには、1つ以上の@dfn{ターゲット(targets)}を含めることができます。ターゲットとは、プロジェクトの1つ以上のファイルから``ビルド''されるオブジェクトファイル、実行ファイル、またはその他の種類のファイルです。

  プロジェクトに新しい@dfn{ターゲット(target)}を追加するには、@kbd{C-c . t} (@code{M-x
ede-new-target})とタイプします。このコマンドは、カレントファイルをそのターゲットに``追加''するか尋ねます。これはターゲットがそのファイルからビルドされることを意味します。ターゲットを定義した後は、@kbd{C-c
. a} (@code{ede-add-file})とタイプすることにより、ターゲットにファイルを追加することができます。

  ターゲットをビルドするには、@kbd{C-c . c}
(@code{ede-compile-target})とタイプします。プロジェクトのすべてのターゲットをビルドするには、@kbd{C-c . C}
(@code{ede-compile-project})とタイプします。EDEはターゲットがどのようにビルドされるべきか推測するために、ファイルタイプを使用します。

@ifnottex
@include emerge-xtra.texi
@end ifnottex
