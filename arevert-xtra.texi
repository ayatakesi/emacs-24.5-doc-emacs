@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 2004-2015 Free Software Foundation, Inc.
@c See file emacs.texi for copying conditions.
@c
@c This file is included either in emacs-xtra.texi (when producing the
@c printed version) or in the main Emacs manual (for the on-line version).
@node Autorevert
@section 非ファイルバッファーの自動リバート

通常Global Auto
Revertモードは、ファイルのバッファーだけをリバートします。非ファイルバッファーにたいして自動リバートを行うには、2つの方法があります。1つはそれらのバッファーにたいしてAuto
Revertモードを有効にする方法です(@kbd{M-x
auto-revert-mode}を使います)。もう1つは@code{global-auto-revert-non-file-buffers}に非@code{nil}値をセットする方法です。後者はそれが実装されているすべての種類のバッファーにたいして、自動リバートを有効にします(以下のメニューにリストされています)。

ファイルバッファーと同様、非ファイルバッファーはそれらにたいして作業を行っているときや、リバートすると失われてしまう情報が含まれているとき、通常はリバートすべきではありません。したがって、それらが``modified(変更されている)''のときはリバートしません。非ファイルバッファーが変更されているとマークするのは、ファイルバッファーのときより通常難しいので、トリッキーになり得ます。

他のトリッキーな点に関する詳細は、効率の問題です。自動リバートはしばしばバッファーにたいするすべての可能な変更を検知しようとせず、``広範''または簡単に検知できる変更だけを検知します。したがって、非ファイルバッファーに自動リバートを有効にすることは、バッファーのすべての情報が最新であると常に保証はしませんし、手動によるリバートを無用にする必要もないからです。

それとは反対に、特定のバッファーは@code{auto-revert-interval}で指定された秒数ごとに自動的にリバートします(これは現在のところBuffer
Menuだけに適用されます)。この場合、自動リバートはリバートの際、@code{auto-revert-verbose}が非@code{nil}でも、何もメッセージを表示しません。

詳細はバッファーの特性に依存し、それらは対応するセクションで説明されています。

@menu
* Auto Reverting the Buffer Menu::  Buffer 
                                      Menuの自動リバートについて。
* Auto Reverting Dired::     Diredバッファーの自動リバートについて。
* Supporting additional buffers::  自動リバートのサポートを追加する方法。
@end menu

@node Auto Reverting the Buffer Menu
@subsection Buffer Menuの自動リバート

非ファイルバッファーの自動リバートが有効なとき、必要性の有無にかかわらず、Buffer
Menuは@code{auto-revert-interval}で指定された秒数ごとに自動的にリバートされます。(これは多分実際にリバートする必要があるかチェックするより長い間隔です)。

Buffer
Menuがmodifiedと不適切にマークされたときは、@kbd{g}により手動でリバートして自動リバートを再開します。しかし特定のバッファーにたいして削除や表示のマークをつけた場合は、慎重になる必要があります。なぜならリバートはすべてのマークを消去するからです。マークの追加はバッファーのmodifiedフラグをセットするという事実は、自動的なマークの消去からの自動リバートを防ぎます。

@node Auto Reverting Dired
@subsection Diredバッファーの自動リバート

Diredバッファーの自動リバートは、現在のところUnixスタイルのオペレーティングシステムだけで機能します。他のシステムでは満足に機能しないでしょう。

Diredバッファーは、バッファーのメインディレクトリーのファイルリストが変化したとき(たとえば新しいファイルの追加)だけ、自動リバートします。特定のファイルの情報が変化したとき(たとえばサイズの変化)や、サブディレクトリーへの追加は自動リバートしません。@emph{すべて}のリストされた情報が最新であることを確実にするには、Diredバッファーで自動リバートが@emph{有効であっても}、手動で@kbd{g}を使ってリバートする必要があります。メインディレクトリーにリストされているファイルへの変更や保存で、実際に自動リバートが起こるのに気付くかもしれません。これはファイルの変更や保存は、たとえばバックアップファイルやauto-saveファイルにより、高い確率でディレクトリー自身を変更するからです。しかし、これは保証されているわけではありません。

Diredバッファーがmodifiedとマークされ、残したい変更がない場合、大抵は@kbd{g}でバッファーを手動でリバートすることにより、自動リバートを再開できます。しかし1つ例外があります。ファイルにフラグやマークをつけた場合、安全にバッファーをリバートできます。これはフラグやマークを消去しません(もちろんマークされたファイルが削除されていない場合です)。しかしバッファーはリバートの後でさえmodifiedの状態に留まるので、自動リバートは再開しません。これは、もしファイルにたいしてフラグやマークをつけた場合、それはバッファーにたいして作業をしており、警告なしにバッファーが変更されることを望まないだろうからです。マークやフラグがある状態で自動リバートを再開したいときは、@kbd{M-~}を使ってバッファーをnon-modifiedとマークします。しかしマークやフラグの追加・削除・変更により、バッファーは再びmodifiedとマークされます。

リモートのDiredバッファーは、自動リバートされません(これは遅くなるからです)。特定のファイルだけをリストするように、シェルのワイルドカードやファイル引数を与えられたDiredバッファーも同じです。@file{*Find*}および@file{*Locate*}は、どちらも自動リバートしません。

@c FIXME?  This should be in the elisp manual?
@node Supporting additional buffers
@subsection 追加のバッファーにたいする自動リバートのサポートの追加

このセクションは、新しいタイプのバッファーに自動リバートのサポートを追加したいElispプログラマーのために意図されています。

バッファーに自動リバートのサポートを追加するには、まず最初に適切な@code{revert-buffer-function}をもつことです。@xref{Definition
of revert-buffer-function,, Reverting, elisp, the Emacs Lisp Reference
Manual}.を参照してください。

それに加えて、適切な@code{buffer-stale-function}をもたなければなりません。

@c FIXME only defvar in all of doc/emacs!
@defvar buffer-stale-function
この変数の値は、バッファーがリバートする必要があるかチェックする関数です。これは1つのオプション引数@var{noconfirm}をもつ関数です。この関数はバッファーがリバートされるべきときは、非@code{nil}を返します。バッファーは、この関数が呼ばれたときのバッファーです。

この関数は主に自動リバートで使うことを意図していますが、他の目的にも同様に使うことができます。たとえば自動リバートが無効の場合、これはバッファーをリバートする必要があるとユーザーに警告するのに使えます。このアイデアは引数@var{noconfirm}が背景にあります。もしこれが@code{t}のときは、ユーザーに尋ねることなくリバートを行い、この関数をバッファーが無効だとユーザーに警告するために使うときは、@code{nil}を指定します。特に自動リバートに使う場合、@var{noconfirm}は@code{t}になります。関数を自動リバートだけに使う場合、引数@var{noconfirm}は無視できます。

(Buffer
Menuのように)@code{auto-revert-interval}で指定した秒数ごとに自動リバートを自動的に行いたいだけのときは、以下のようにします:

@example
(setq-local buffer-stale-function
     #'(lambda (&optional noconfirm) 'fast))
@end example

@noindent
これをバッファーのモード関数の中に記述します。

特別な戻り値@samp{fast}は、呼出側にリバートの必要性チェックは必要ないが、バッファーのリバートは早く行うことを呼出側に伝えます。これは@code{auto-revert-verbose}が非@code{nil}のときも、自動リバートがリバートメッセージを表示しないことも伝えます。これは重要です。なぜなら@code{auto-revert-interval}秒ごとにリバートメッセージが表示されるのは、とても煩わしくなり得るからです。この戻り値で提供される情報は、関数が自動リバート以外の目的で使われる場合にも有用です。
@end defvar

バッファーが適切な@code{revert-buffer-function}および@code{buffer-stale-function}をもっていても、通常は問題がいくつか残ります。

バッファーは、unmodifiedとマークされているときだけ自動リバートします。したがって、さまざまな関数がバッファーをmodifiedとマークするのは、バッファーがリバートされることにより失われる情報を持つとき、またはユーザーがバッファーで作業しているので、自動リバートが迷惑だと信じる理由があるときだと確信する必要があります。ユーザーはmodifiedのステータスを手作業で調整することにより、常にこれをオーバーライドできます。これをサポートするために、unmodifiedとマークされたバッファーでの@code{revert-buffer-function}の呼び出しは、そのバッファーのunmodifiedのマークを維持すべきです。

一連の自動リバートで、ポイントがあちこちジャンプしないことを保証するのは重要です。もちろんバッファーが活発に変化するとき、ポイントが移動するのは仕方ありません。

@code{revert-buffer-function}が、@code{auto-revert-verbose}が@code{t}のとき出力される自動リバート自身のメッセージと重複する、不要なメッセージを出力しないことと、@code{auto-revert-verbose}にセットされた@code{nil}値を、効果的にオーバーライドすることを確実にするべきです。したがってモードを自動リバートに適合させることは、しばしばそのようなメッセージの削除をともないます。これは@code{auto-revert-interval}秒ごとに自動リバートを行うバッファーで特に重要です。

新しい自動リバートがEmacsの一部となったときは、@code{global-auto-revert-non-file-buffers}のドキュメント文字列にそれを記載するべきです。

@ifinfo
同様にこのチャプターのメニューにノードを追加するべきです。そのノード
@end ifinfo
@ifnotinfo
同様にこのチャプターにセクションを追加するべきです。そのセクション
@end ifnotinfo
は、バッファーの自動更新を有効にすることによりバッファーのすべての情報が完全に最新(または最新から@code{auto-revert-interval}秒後)であると保証されるかを、最小限かつ明確にすべきです。
