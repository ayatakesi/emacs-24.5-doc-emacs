@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2000-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@iftex
@chapter その他のコマンド

  このチャプターには、他のどこにも適さないような、複数のトピックについての概略が含まれています。それらには以下のものが含まれます:
``ドキュメントファイル''の閲覧、Usenetニュースの購読、シェルコマンドおよびシェルサブプロセスの実行、エディターをサブプロセスとして実行するユーティリティーとして1つの共有Emacsを使用する、ハードコピーの印刷、テキストのソート、バイナリーファイルの編集、後で再開するためにEmacsセッションを保存する、ハイパーリンクをフォローする、他のエディターのエミュレート、およびさまざまな気晴らしと娯楽、などです。

@end iftex

@ifnottex
@raisesections
@end ifnottex

@node Gnus
@section Gnus
@cindex Gnus
@cindex Usenet news
@cindex newsreader

  Gnusは、主にUsenetニュースを読んだりポストするためにデザインされた、Emacsパッケージです。これはいくつかの異なるソース ---
電子メール、リモートディレクトリー、ダイジェスト、などを読んだり、メッセージを返すためにも使うことができます。以下はGnusの紹介と、いくつかの基本的な機能の説明です。
@ifnottex
完全な詳細に付いては、@ref{Top, Gnus,, gnus, The Gnus Manual}を参照してください。
@end ifnottex
@iftex
Gnusについての完全な詳細は、@kbd{C-h i}とタイプしてから、Gnus manualを選択してください。
@end iftex

@menu
* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。
@end menu

@node Buffers of Gnus
@subsection Gnusバッファー

  Gnusは、情報を表示したり返信コマンドのために、複数のバッファーを使用します。もっとも一般的に使用される3つのGnusバッファーは@dfn{グループバッファー(group
buffer)}、@dfn{サマリーバッファー(summary buffer)}、@dfn{アーティクルバッファー(article
buffer)}です。

  @dfn{グループバッファー}は、アーティクルソースのリスト(たとえばニュースグループや電子メールのinbox)を含んでおり、それらは@dfn{グループ}として参照されます。これはGnusを開始したときに最初に表示されるバッファーです。これは通常、あなたが登録したグループと、未読のアーティクルだけを表示します。このバッファーから、読みたいグループを選択できます。

  @dfn{サマリーバッファー}は1つのグループのアーティクルをリストし、1行に1つのアーティクルを表示します。デフォルトでは、アーティクルの作者、subject、
@iftex
行数が表示されます。
@end iftex
@ifnottex
行数が表示されますが、これはカスタマイズできます。@ref{Summary Buffer Format,,, gnus, The Gnus
Manual}を参照してください。
@end ifnottex
サマリーバッファーは、グループバッファーでグループを選択すると作成され、グループを抜けるとkillされます。

  サマリーバッファーから、閲覧するアーティクルを選択できます。アーティクルは@dfn{アーティクルバッファー}で表示されます。通常のGnusの使い方では、このバッファーを閲覧はしますが選択はしません
---
すべての便利なGnusコマンドはサマリーバッファーから呼び出すことができます。しかし望むなら、アーティクルバッファーを選択して、そこからGnusコマンドを実行することもできます。

@node Gnus Startup
@subsection Gnusを起動した時

@findex gnus
@cindex @file{.newsrc} file
  あなたのシステムがUsenetニュースをよむためにセットアップされていれば、Gnusを始めるのは簡単です --- @kbd{M-x
gnus}とタイプするだけです。

  起動時に、Gnusはホームディレクトリーにある@file{.newsrc}という名前の@dfn{ニュース初期化ファイル(news
initialization
file)}を読み込みます。これにはあなたのUsenetニュースグループと購読状況がリストされています(これはGnus固有のファイルではありません。他の多くのニュースリーダープログラムにより使用されています)。その後システムのデフォルトのニュースサーバーへの接続を試みます。これは通常、環境変数@env{NNTPSERVER}により指定されます。

  あなたのシステムがデフォルトのニュースサーバーをもっていない場合、または電子メールを読むためにGnusを使いたい場合は、@kbd{M-x
gnus}を呼び出す前に、どこでニュースおよび/またはメールを取得するか、Gnusに指示する必要があります。これを行なうには、変数@code{gnus-select-method}および/または@code{gnus-secondary-select-methods}をカスタマイズします。
@iftex
詳細は、Gnusのマニュアルを参照してください。
@end iftex
@ifnottex
@ref{Finding the News,,, gnus, The Gnus Manual}を参照してください。
@end ifnottex

  1度Gnusを開始すると、グループバッファーを表示します。デフォルトでは少数の@dfn{subscribedグループ(subscribed
groups: 登録されたグループ)}だけが表示されます。他の状態 ---
@dfn{unsubscribed}、@dfn{killed}、@dfn{zombie} ---
のグループは表示されません。最初にGnusを開始したとき、登録していないグループはkilledグループになります。その後にニュースサーバーに現れたグループはzombieグループになります。

  先に進むには、グループバッファーでグループを選択して、そのグループのサマリーバッファーを開かなければなりません。その後サマリーバッファーのアーティクルを選択して、別のウィンドウでアーティクルバッファーを閲覧します。以下のセクションでは、これを行なうための、グループバッファーとサマリーバッファーの使用について説明します。

  Gnusを終了するには、グループバッファーで@kbd{q}とタイプします。これは自動的にグループの状態をファイル@file{.newsrc}ト@file{.newsrc.eld}に記録するので、その後のGnusセッションでも効果があります。

@node Gnus Group Buffer
@subsection Gnus Groupバッファーの使用

  以下のコマンドは、Gnusグループバッファーで利用可能です:

@table @kbd
@kindex SPC @r{(Gnus Group mode)}
@findex gnus-group-read-group
@item @key{SPC}
カレント行のグループの、サマリーバッファーに切り替えます。

@kindex l @r{(Gnus Group mode)}
@kindex A s @r{(Gnus Group mode)}
@findex gnus-group-list-groups
@item l
@itemx A s
グループバッファーでは、未読のアーティクルを含む登録したグループだけをリストします(これはデフォルトの一覧方法です)。

@kindex L @r{(Gnus Group mode)}
@kindex A u @r{(Gnus Group mode)}
@findex gnus-group-list-all-groups
@item L
@itemx A u
すべてのsubscribed(登録)およびunsubscribed(未登録)のグループをリストしますが、killedまたはzombieのグループは表示しません。

@kindex A k @r{(Gnus Group mode)}
@findex gnus-group-list-all-groups
@item A k
killedグループをリストします。

@kindex A z @r{(Gnus Group mode)}
@findex gnus-group-list-all-groups
@item A z
zombieグループをリストします。

@kindex u @r{(Gnus Group mode)}
@findex gnus-group-unsubscribe-current-group
@cindex subscribe groups
@cindex unsubscribe groups
@item u
カレント行のグループの登録状態を切り替えます(たとえばsubscribedグループをunsubscribedグループにしたり、その逆を行ないます)。killedまたはzombieのグループにたいしてこれを呼び出すと、そのグループをunsubscribedグループにします。

@kindex C-k @r{(Gnus Group mode)}
@findex gnus-group-kill-group
@item C-k
カレント行のグループをkillします。killedとなったグループは@file{.newsrc}ファイルに記録され、@kbd{l}または@kbd{L}のリストには表示されなくなります。

@kindex DEL @r{(Gnus Group mode)}
@item @key{DEL}
未読アーティクルを含む、前のグループにポイントを移動します。

@kindex n @r{(Gnus Group mode)}
@findex gnus-group-next-unread-group
@findex gnus-summary-next-unread-article
@item n
次の未読グループにポイントを移動します。

@kindex p @r{(Gnus Group mode)}
@findex gnus-group-prev-unread-group
@findex gnus-summary-prev-unread-article
@item p
前の未読グループにポイントを移動します。

@kindex q @r{(Gnus Group mode)}
@findex gnus-group-exit
@item q
Gnusのセッティングを更新してGnusを終了します。
@end table

@node Gnus Summary Buffer
@subsection Gnus Summaryバッファーの使用

  以下のコマンドは、Gnusサマリーバッファーで利用可能です:

@table @kbd
@kindex SPC @r{(Gnus Summary mode)}
@findex gnus-group-read-group
@item @key{SPC}
選択されたアーティクルがない場合、カレント行のアーティクルを選択して、それをアーティクルバッファーに表示します。そうでない場合、選択されたアーティクルバッファーのウィンドウでスクロールを試みます。バッファーの最後に到達した場合、次の未読アーティクルを選択します。

したがって、繰り返し@key{SPC}をタイプすることにより、すべてのアーティクルを読むことができます。

@kindex DEL @r{(Gnus Summary mode)}
@findex gnus-summary-prev-page
@item @key{DEL}
アーティクルのテキストを後方にスクロールします。

@kindex n @r{(Gnus Summary mode)}
@findex gnus-group-next-unread-group
@findex gnus-summary-next-unread-article
@item n
次の未読アーティクルを選択します。

@kindex p @r{(Gnus Summary mode)}
@findex gnus-group-prev-unread-group
@findex gnus-summary-prev-unread-article
@item p
前の未読アーティクルを選択します。

@kindex s @r{(Gnus Summary mode)}
@findex gnus-summary-isearch-article
@item s
選択されたアーティクルバッファーで、あたかもそのバッファーに切り替えて@kbd{C-s}(@ref{Incremental
Search}を参照してください)とタイプしたかのように、インクリメンタル検索を行ないます。

@kindex M-s @r{(Gnus Summary mode)}
@findex gnus-summary-search-article-forward
@item M-s @var{regexp} @key{RET}
@var{regexp}へのマッチを含むアーティクルを、前方に検索します。

@kindex q @r{(Gnus Summary mode)}
@item q
サマリーバッファーをexitして、グループバッファーに戻ります。
@end table

@node Document View
@section ドキュメントの閲覧
@cindex DVI file
@cindex PDF file
@cindex PS file
@cindex PostScript file
@cindex OpenDocument file
@cindex Microsoft Office file
@cindex DocView mode
@cindex mode, DocView
@cindex document viewer (DocView)
@findex doc-view-mode

  DocViewモードは、DVI、PostScript(PS)、PDF、OpenDocument、Microsoft
Officeドキュメントを閲覧するためのメジャーモードです。このモードはスライス、ズーム、ドキュメント内の検索などの機能を提供します。これは、@command{gs}(GhostScript)、または@command{mudraw}/@command{pdfdraw}(MuPDF)、およびその他の外部ツール@footnote{PostScriptファイルにたいしてはGhostScriptが絶対条件です。DVIファイルにたいしては@code{dvipdf}または@code{dvipdfm}が必要です。OpenDocumentおよびMicrosoft
Officeドキュメントにたいしては@code{unoconv}ツールが必要です。}を使用して、ドキュメントを一連のイメージに変換し、それらのイメージを表示することにより機能します

@findex doc-view-toggle-display
@findex doc-view-toggle-display
@cindex doc-view-minor-mode
  DocViewモードで表示可能なドキュメントをvisitすると、Emacsは自動的にDocViewモードを使用します@footnote{そのドキュメントに必要な外部ツールが利用可能でなければならず、Emacsがグラフィカルなフレームで実行されていて、PNGイメージをサポートしなければなりません。これらの条件が満たされなければ、Emacsは他のメジャーモードにフォールバックします。}。例外として、PostScriptファイルをvisitしたとき、EmacsはPostScriptファイルをテキストとして編集するためのメジャーモードの、PSモードに切り替わります。しかし、これはDocView
minorモードも有効にするので、@kbd{C-c
C-c}とタイプして、そのドキュメントを閲覧することができます。DocViewモードまたはDocView minorモードでは、@kbd{C-c
C-c}
(@code{doc-view-toggle-display})を繰り返すことにより、DocViewとその背後にあるファイル内容を切り替えることができます。

@findex doc-view-open-text
  いくつかの要件が満たされないとき(たとえばテキスト端末のフレームを操作していたり、そのemacsはPNGをサポートしないときなど)に、通常DocViewモードで処理されるファイルをvisitした場合は、そのドキュメントの内容をプレーンテキストとして閲覧したいか問い合わせます。これに同意すると、そのバッファーはtextモードとなり、DocView
minorモードがアクティブになります。したがって@kbd{C-c
C-c}とタイプすることにより、fallbackモードに切り替わります。もう1度@kbd{C-c
C-c}とタイプすると、DocViewモードに戻ります。DocViewモードで@kbd{C-c C-t}
(@code{doc-view-open-text})とタイプすることにより、プレーンテキストで内容を表示することもできます。

  コマンド@code{M-x doc-view-mode}で、DocViewモードを明示的に有効にすることができます。また、@code{M-x
doc-view-minor-mode}で、DocView minorモードに切り替えることができます。

  DocViewモードを開始したときは、ウェルカム画面を表示して、そのファイルを1ページずつフォーマットしていきます。最初のページがフォーマットされると、そのページを表示します。

  DocViewバッファーをkillするには、@kbd{k}
(@code{doc-view-kill-proc-and-buffer})とタイプします。バッファーを隠す(bury)には、@kbd{q}
(@code{quit-window})とタイプします。

@menu
* Navigation: DocView Navigation.  DocViewバッファーの操作。
* Searching: DocView Searching.  ドキュメント内の検索。
* Slicing: DocView Slicing.  ページのどの部分を表示するか指定する。
* Conversion: DocView Conversion.  変換に影響を与えたり、それを誘発するもの。
@end menu

@node DocView Navigation
@subsection DocViewの操作

  DocViewモードでは通常のEmacs移動キー、つまり@kbd{C-p}、@kbd{C-n}、@kbd{C-b}、@kbd{C-f}、および矢印キーを使って、ページをスクロールできます。

@vindex doc-view-continuous
  デフォルトでは、行移動キーの@kbd{C-p}と@kbd{C-n}は、カレントページの先頭または最後でスクロールを止めます。しかし、変数@code{doc-view-continuous}を非@code{nil}値に変更した場合、カレントページの先頭で@kbd{C-p}とタイプすると前のページを表示し、カレントページの最後で@kbd{C-n}とタイプすると次のページを表示します。

@findex doc-view-next-page
@findex doc-view-previous-page
@kindex n @r{(DocView mode)}
@kindex p @r{(DocView mode)}
@kindex C-x ] @r{(DocView mode)}
@kindex C-x [ @r{(DocView mode)}
  @kbd{n}、@key{next}、@kbd{C-x
]}をタイプすることにより、次のページを表示することもできます(@code{doc-view-next-page})。前のページを表示するには、@kbd{p}、@key{prior}、@kbd{C-x
[}をタイプします(@code{doc-view-previous-page})。

@findex doc-view-scroll-up-or-next-page
@findex doc-view-scroll-down-or-previous-page
@kindex SPC @r{(DocView mode)}
@kindex DEL @r{(DocView mode)}
  @key{SPC}
(@code{doc-view-scroll-up-or-next-page})は、ドキュメントを順に読んでいくのに便利な方法です。これはカレントページをスクロールするか、次のページに移動します。@key{DEL}
(@code{doc-view-scroll-down-or-previous-page})は、同様の方法で後方に移動します。

@findex doc-view-first-page
@findex doc-view-last-page
@findex doc-view-goto-page
@kindex M-< @r{(DocView mode)}
@kindex M-> @r{(DocView mode)}
  最初のページに移動するには、@kbd{M-<}
(@code{doc-view-first-page})とタイプします。最後のページに移動するには、@kbd{M->}
(@code{doc-view-last-page})とタイプします。ページ番号を指定して移動するには、@kbd{M-g M-g}または@kbd{M-g
g} (@code{doc-view-goto-page})とタイプしてください。

@findex doc-view-enlarge
@findex doc-view-shrink
@vindex doc-view-resolution
@kindex + @r{(DocView mode)}
@kindex - @r{(DocView mode)}
  @kbd{+} (@code{doc-view-enlarge})と@kbd{-}
(@code{doc-view-shrink})で、ドキュメントを拡大したり縮小することができます。これらのコマンドはドキュメントを新しいサイズに再変換することにより機能します。DocViewにたいするデフォルトサイズを指定するには、変数@code{doc-view-resolution}をカスタマイズしてください。

@node DocView Searching
@subsection DocViewの検索

  DocViewモードでは、ファイルのテキストにたいして正規表現の検索を行なうことができます(@ref{Regexps}を参照してください)。検索のインターフェースは@code{isearch}が元になっています(@ref{Incremental
Search}を参照してください)。

@findex doc-view-search
@findex doc-view-search-backward
@findex doc-view-show-tooltip
  検索を開始するには、@kbd{C-s} (@code{doc-view-search})または@kbd{C-r}
(@code{doc-view-search-backward})とタイプします。これはミニバッファーを使用して正規表現を読み取り、そのドキュメントでマッチした数をエコーします。@kbd{C-s}または@kbd{C-r}とタイプすることにより、マッチ間を前方または後方に移動できます。DocViewモードはページイメージの中でマッチを表示できません。かわりに、カレントページのマッチするすべての行を一覧するツールチップを、(マウス位置に)表示します。このツールチップを強制的に表示するには@kbd{C-t}
(@code{doc-view-show-tooltip})とタイプしてください。

  新しい検索を開始するには、たとえば前方検索では@kbd{C-u C-s}、後方検索では@kbd{C-u
C-r}のように、検索コマンドにプレフィクス引数を使用します。

@node DocView Slicing
@subsection DocViewのスライス

印刷のために広い余白をもつドキュメントもあります。これらはスクリーンでドキュメントを読むとき邪魔になることがあります。なぜならこれらは画面スペースを消費して、スクロールが不便になるからです。

@findex doc-view-set-slice
@findex doc-view-set-slice-using-mouse
  DocViewでは、表示するページの@dfn{スライス(slice)}を選択することにより、これらの余白を隠すことができます。スライスはページ内の矩形領域です。DocViewで1度スライスを指定すると、閲覧するすべてのページに適用されます。

@c ??? how does this work?
  数値でスライスを指定するには、@kbd{s s}
(@code{doc-view-set-slice})とタイプします。その後、スライスの左上のピクセル位置(pixel
position)と、スライスの幅(width)と高さ(height)を入力します。

  スライスを指定するための、もっと便利でグラフィカルな方法は、@kbd{s m}
(@code{doc-view-set-slice-using-mouse})で、スライスの選択にマウスを使う方法です。これは単に、スライスにしたいリージョンの左上隅で左マウスボタンを押して、そのまま右下隅にマウスポインターを移動してマウスボタンを離します。

  最適なスライスをセットする一番簡単な方法は、@kbd{s b}
(@code{doc-view-set-slice-from-bounding-box})とタイプすることにより、そのドキュメントから自動的に判断されるBoundingBox情報を使う方法です。

@findex doc-view-reset-slice
  選択されたスライスを取り消すには、@kbd{s r}
(@code{doc-view-reset-slice})とタイプします。するとDocViewは、余白全体を含めたページ全体を表示します。

@node DocView Conversion
@subsection DocViewの変換

@vindex doc-view-cache-directory
@findex doc-view-clear-cache
  効率のために、DocViewは@command{gs}により生成されたイメージをキャッシュします。このディレクトリーの名前は、変数@code{doc-view-cache-directory}により与えられます。@code{M-x
doc-view-clear-cache}とタイプすることにより、キャッシュディレクトリーをクリアーできます。

@findex doc-view-kill-proc
@findex doc-view-kill-proc-and-buffer
  現在閲覧中のドキュメントを強制的に再変換するには、type @kbd{r}または@kbd{g}
(@code{revert-buffer})とタイプします。カレントバッファーに関連付けられた変換プロセスをkillするには、@kbd{K}
(@code{doc-view-kill-proc})とタイプします。コマンド@kbd{k}
(@code{doc-view-kill-proc-and-buffer})は、変換プロセスとDocViewバッファーをkillします。

@node EWW
@section EWWによるウェブブラウズ

@findex eww
@findex eww-open-file
  @dfn{EWW}(Emacs Web
Wowser)は、Emacs用のウェブブラウザーのパッケージです。これはEmacsバッファーでURLブラウズすることを可能にします。コマンド@kbd{M-x
eww}により、URLを開いたり、ウェブを検索します。コマンド@kbd{M-x
eww-open-file}を使用して、ファイルを開くことができます。@code{browse-url}にたいするウェブブラウザーとして。EWWを使うことができます(@ref{Browse-URL}を参照してください)。完全な詳細に付いては、@ref{Top,
EWW,, eww, The Emacs Web Wowser Manual}を参照してください。

@node Shell
@section Emacsからのシェルコマンドの実行
@cindex subshell
@cindex shell commands

  Emacsには、シェルサブプロセスに1つのコマンドラインを渡したり、入出力にEmacsバッファーを使用して対話的にシェルを実行するコマンドや、端末エミュレーターウィンドウでシェルを実行するコマンドがあります。

@table @kbd
@item M-! @var{cmd} @key{RET}
シェルコマンド@var{cmd}を実行して、出力を表示します(@code{shell-command})。
@item M-| @var{cmd} @key{RET}
リージョンの内容を入力としてシェルコマンド@var{cmd}を実行します。オプションでリージョンを出力で置き換えます(@code{shell-command-on-region})。
@item M-& @var{cmd} @key{RET}
シェルコマンド@var{cmd}を非同期で実行し、出力を表示します(@code{async-shell-command})。
@item M-x shell
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後で、コマンドを対話的に与えることができます。
@item M-x term
Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その後でコマンドを対話的に与えることができます。完全な端末エミュレーションが利用できます。
@end table

@vindex exec-path
  (上記のコマンドの@var{cmd}引数、または他のコンテキストにおいて)実行可能プログラムとして相対ファイル名を指定したときは、Emacsは変数@code{exec-path}により指定されるディレクトリーのプログラムを検索します。この変数の値は、ディレクトリー名のリストでなければなりません。デフォルト値は、Emacsが開始されたときの環境変数@env{PATH}により初期化されます(@ref{General
Variables}を参照してください)。

  @kbd{M-x
eshell}は、Emacsで完全に実装されたシェルを呼び出します。eshellについては、自身のマニュアルにドキュメントされています。
@ifnottex
@ref{Top,Eshell,Eshell, eshell, Eshell: The Emacs Shell}を参照してください。
@end ifnottex
@iftex
Emacsと共に配布される、Eshell Infoマニュアルを参照してください。
@end iftex

@menu
* Single Shell::             シェルコマンドを実行してから、戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* History: Shell History.    シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Options: Shell Options.    Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。
@end menu

@node Single Shell
@subsection 単一のシェルコマンド

@kindex M-!
@findex shell-command
  @kbd{M-!}
(@code{shell-command})は、ミニバッファーを使って1行のテキストを読み取り、それをシェルコマンドとして、そのコマンドのためだけに作成されたサブシェルで実行します。そのコマンドの標準入力はnullデバイスです。シェルコマンドが出力を生成する場合、その出力はエコーエリア(出力が短い場合)、または別のウィンドウの@file{*Shell
Command Output*}という名前のEmacsバッファー(出力が長い場合)に表示されます。

  たとえば@file{foo.gz}という名前のファイルを解凍する1つの方法は、@kbd{M-! gunzip foo.gz
@key{RET}}とタイプすることです。このシェルコマンドは通常、ファイル@file{foo}を作成して、端末出力を生成しません。

  たとえば@kbd{M-1
M-!}のように@code{shell-command}に数引数を指定した場合、別のバッファーではなく、カレントバッファーに端末出力を挿入します。これはポイントを出力の前に配し、出力の後にマークを配します。たとえば@kbd{M-1
M-! gunzip < foo.gz @key{RET}}は、カレントバッファーにファイル@file{foo.gz}の解凍された内容を挿入します。

  最後が@samp{&}でないシェルコマンドを指定した場合、コマンドは@dfn{同期(synchronously)}で実行され、Emacsを継続して使用するには、コマンドがexitするのを待たなければなりません。待つのを中止するには、@kbd{C-g}とタイプします。これはシェルコマンドを終了するために、シグナル@code{SIGINT}を送ります(これは通常、シェルで@kbd{C-c}とタイプしたときに生成されるのと同じシグナルです)。その後、Emacsはコマンドが実際に終了するまで待ちます。シェルコマンドが終了しない場合(そのコマンドがシグナル@code{SIGINT}を無視する場合)は、再度@kbd{C-g}とタイプします。これは　そのコマンドにたいして、無視することが不可能なシグナル@code{SIGKILL}を送ります。

@kindex M-&
@findex async-shell-command
  @samp{&}で終わるシェルコマンドは@dfn{非同期(asynchronously)}で実行され、それを実行した後でも、継続してEmacsを使用できます。シェルコマンドを非同期で実行する前に、@kbd{M-&}
(@code{async-shell-command})とタイプすることもできます。これは最後の@samp{&}が必要ない点を除き、最後に@samp{&}を指定して@kbd{M-!}を呼び出すことと同じです。非同期シェルコマンドにたいするデフォルトの出力バッファーは、@samp{*Async
Shell
Command*}という名前のバッファーです。このバッファーがウィンドウに表示されているかに関わらず、Emacsは出力をこのバッファーに挿入します。

@vindex async-shell-command-buffer
  同時に複数の非同期シェルコマンドを実行した場合、出力バッファーが競合します。この場合どのようにするか ---
たとえば既存の出力バッファーをリネームしたり、新しいコマンドに異なるバッファーを使用する ---
を、オプション@code{async-shell-command-buffer}で指定できます。他の可能なオプションについては、この変数のドキュメントを参照してください。

@kindex M-|
@findex shell-command-on-region
  @kbd{M-|}
(@code{shell-command-on-region})は@kbd{M-!}と同様ですが、入力を与えないかわりに、リージョンの内容をシェルコマンドの標準入力として渡します。数引数を指定した場合、古いリージョンの内容を、シェルコマンドの出力で置き換えます。

  たとえば@kbd{M-|}で@command{gpg}プログラムを使用して、そのバッファーのキーが何かを見ることができます。そのバッファーがGnuPGキーを含む場合、@kbd{C-x
h M-| gpg
@key{RET}}とタイプして、バッファー全体の内容を@command{gpg}に送ることができます。これはキーのリストを、@file{*Shell
Command Output*}バッファーに出力します。

@vindex shell-file-name
  上記のコマンドは、変数@code{shell-file-name}で指定されたシェルを使用します。この変数のデフォルト値は、Emacsが開始されたときの環境変数@env{SHELL}により決定されます。相対ファイル名の場合、Emacsは@code{exec-path}にリストされたディレクトリーを検索します(@ref{Shell}を参照してください)。

  @kbd{M-!}または@kbd{M-|}にたいするコーディングシステムを指定するには、あらかじめコマンド@kbd{C-x @key{RET}
c}を使用します。@ref{Communication Coding}を参照してください。

@vindex shell-command-default-error-buffer
  デフォルトでは、出力バッファーではエラー出力と標準出力が混ざって出力されます。しかし変数@code{shell-command-default-error-buffer}の値を文字列に変更すると、エラー出力はその名前のバッファーに出力されます。

@node Interactive Shell
@subsection 対話的なサブシェル

@findex shell
  対話的にサブシェルを実行するには、@kbd{M-x
shell}とタイプします。これは@file{*shell*}という名前のバッファーを作成(または再使用)して、そのバッファーにたいして入出力を行なう、シェルのサブプロセスを実行します。つまりサブシェルからの端末出力はポイントの後に挿入されてポイントを進め、サブシェルにたいする端末入力はそのバッファーのテキストになります。サブシェルにたいして入力を与えるには、バッファーの最後に移動して入力をタイプし、@key{RET}で終了します。

  サブシェルがコマンドの実行を待つ間、ウィンドウまたはバッファーを切り替えてEmacsで他の編集を行なうことができます。Emacsはそれを処理するときがきたら(たとえばキーボード入力待ちになったとき)、サブシェルからの出力をShellバッファーに挿入します。

@cindex @code{comint-highlight-input} face
@cindex @code{comint-highlight-prompt} face
  Shellバッファーでは、プロンプトはフェイス@code{comint-highlight-prompt}で表示され、サブミットされた入力行はフェイス@code{comint-highlight-input}で表示されます。これにより入力行とシェル出力を容易に区別することができます。@ref{Faces}を参照してください。

  複数のサブシェルを作成するには、(@kbd{C-u M-x shell})のように)プレフィクス引数を指定して@kbd{M-x
shell}を呼び出します。その後、このコマンドはバッファー名を読み取り、そのバッファーでサブシェルを作成(または再使用)します。@kbd{M-x
rename-uniquely}を使用して@file{*shell*}バッファーをリネームしてから、@kbd{M-x
shell}で新しい@file{*shell*}バッファーを作成することもできます。異なるバッファーのサブシェルは、並行して独立に実行されます。

@vindex explicit-shell-file-name
@cindex environment variables for subshells
@cindex @env{ESHELL} environment variable
@cindex @env{SHELL} environment variable
  @kbd{M-x
shell}によりシェルファイル名を指定するには、変数@code{explicit-shell-file-name}をカスタマイズします。これが@code{nil}(デフォルト)の場合、もし存在すればEmacsは環境変数@env{ESHELL}を使用します。そうでない場合は通常、変数@code{shell-file-name}を使用します(@ref{Single
Shell}を参照してください)。しかしデフォルトディレクトリーがリモートの場合(@ref{Remote
Files}を参照してください)、シェルファイル名の入力を求めます。

  Emacsは新しいシェルにたいする入力として、もしそれが存在すればファイル@file{~/.emacs_@var{shellname}}の内容を送ります。ここで@var{shellname}は、そのシェルがロードされたファイルの名前です。たとえばbashを使う場合、送られるファイルは@file{~/.emacs_bash}になります。ファイルが見つからない場合、Emacsは@file{~/.emacs.d/init_@var{shellname}.sh}の使用を試みます。

  シェルにたいしてコーディングシステムを指定するには、@kbd{M-x shell}の直前にコマンド@kbd{C-x @key{RET}
c}を使用します。@kbd{C-x @key{RET}
p}とタイプすることにより、実行されているサブシェルにたいするコーディングシステムを変更することもできます。@ref{Communication
Coding}を参照してください。

@cindex @env{INSIDE_EMACS} environment variable
@cindex @env{EMACS} environment variable
  サブシェルでは、Emacsは環境変数@env{INSIDE_EMACS}に@samp{@var{version},comint}をセットします。ここで@var{version}は、Emacsのバージョン(たとえば@samp{24.1})です。プログラムはこの変数をチェックして、Emacsの内部で実行されているかを判断することができます(環境変数@env{EMACS}が定義されていない場合は、環境変数@env{EMACS}も@code{t}にセットします。しかし、この環境変数は時代遅れなので、これを使うプログラムは、かわりに@env{INSIDE_EMACS}を使うべきです)。

@node Shell Mode
@subsection Shellモード
@cindex Shell mode
@cindex mode, Shell

  ShellバッファーのためのメジャーモードはShellモードです。このモードの特別なコマンドは@kbd{C-c}プレフィクスにバインドされており、最初に@kbd{C-c}をタイプしなければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点があります。以下はShellモードのコマンドのリストです:

@table @kbd
@item @key{RET}
@kindex RET @r{(Shell mode)}
@findex comint-send-input
サブシェルの入力にカレント行を送ります(@code{comint-send-input})。行頭のシェルプロンプトは省略されます(@ref{Shell
Prompts}を参照してください)。ポイントがバッファーの最後にある場合、これは通常の対話的なシェルにおいてコマンド行をサブミットするのに似ています。しかし、シェルバッファーの他の場所でも、@key{RET}を呼び出してカレント行を入力としてサブミットできます。

@item @key{TAB}
@kindex TAB @r{(Shell mode)}
@findex completion-at-point
@cindex shell completion
シェルバッファーのポイントの前のコマンド名、またはファイル名を補完します(@code{completion-at-point})。これは通常のEmacs補完ルールを使用します(@ref{Completion}を参照してください)。ファイル名、環境変数名、シェルコマンドヒストリー、ヒストリー参照が補完候補になります(@ref{History
References}を参照してください)。補完を制御するオプションについては、@ref{Shell Options}を参照してください。

@item M-?
@kindex M-? @r{(Shell mode)}
@findex comint-dynamic-list-filename@dots{}
ポイントの前のファイル名にたいして、可能性のある補完リストを一時的に表示します(@code{comint-dynamic-list-filename-completions})。

@item C-d
@kindex C-d @r{(Shell mode)}
@findex comint-delchar-or-maybe-eof
delete文字、または@acronym{EOF}文字を送ります(@code{comint-delchar-or-maybe-eof})。シェルバッファーの最後でこれをタイプすると、サブシェルに@acronym{EOF}が送られます。バッファーの他の場所でタイプすると、通常どおり文字を削除します。

@item C-c C-a
@kindex C-c C-a @r{(Shell mode)}
@findex comint-bol-or-process-mark
行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動します(@code{comint-bol-or-process-mark})。このコマンドを連続して繰り返すと、2回目はプロセスマーク(process
mark)に戻ります。これはサブシェルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所 --- その行のプロンプトの最後 ---
ですが、@kbd{C-c @key{SPC}}の後では、プロセスマークは前の行にあるかもしれません)。

@item C-c @key{SPC}
複数行の入力を累積して、それらを合わせて送ります。このコマンドはポイントの前に改行を挿入しますが、その前のテキストをサブシェルの入力として ---
少なくともその時点では --- 送りません。改行の前後の行は両方、(それらを分割する改行も含めて)@key{RET}をタイプしたとき一緒に送られます。

@item C-c C-u
@kindex C-c C-u @r{(Shell mode)}
@findex comint-kill-input
まだ入力として送られていない、バッファーの最後のすべてのテキストをkillします(@code{comint-kill-input})。ポイントがバッファーの最後にない場合、これはポイントの前のテキストだけをkillします。

@item C-c C-w
@kindex C-c C-w @r{(Shell mode)}
ポイントの前の単語をkillします(@code{backward-kill-word})。

@item C-c C-c
@kindex C-c C-c @r{(Shell mode)}
@findex comint-interrupt-subjob
シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ます(@code{comint-interrupt-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-z
@kindex C-c C-z @r{(Shell mode)}
@findex comint-stop-subjob
シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。(@code{comint-stop-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-\
@findex comint-quit-subjob
@kindex C-c C-\ @r{(Shell mode)}
シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送ります(@code{comint-quit-subjob})。このコマンドはシェルバッファーの最後の、まだ送られていない任意のシェル入力もkillします。

@item C-c C-o
@kindex C-c C-o @r{(Shell mode)}
@findex comint-delete-output
前のシェルコマンドからの出力の一群を削除します(@code{comint-delete-output})。これはシェルコマンドが大量の出力を吐くときに便利です。

@item C-c C-s
@kindex C-c C-s @r{(Shell mode)}
@findex comint-write-output
前のシェルコマンドからの出力の一群をファイルに書き込みます(@code{comint-write-output})。プレフィクス引数を指定した場合は、ファイルに追加で書き込みます。出力の最後のプロンプトは書き込まれません。

@item C-c C-r
@itemx C-M-l
@kindex C-c C-r @r{(Shell mode)}
@kindex C-M-l @r{(Shell mode)}
@findex comint-show-output
前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、カーソルもそこに移動します(@code{comint-show-output})。

@item C-c C-e
@kindex C-c C-e @r{(Shell mode)}
@findex comint-show-maximum-output
バッファーの最後がウィンドウの最下部になるようにスクロールします(@code{comint-show-maximum-output})。

@item C-c C-f
@kindex C-c C-f @r{(Shell mode)}
@findex shell-forward-command
@vindex shell-command-regexp
シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動しません(@code{shell-forward-command})。変数@code{shell-command-regexp}は、コマンドの最後を認識する方法を指定します。

@item C-c C-b
@kindex C-c C-b @r{(Shell mode)}
@findex shell-backward-command
シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はしません(@code{shell-backward-command})。

@item M-x dirs
シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレクトリーを更新します。@ref{Directory
Tracking}を参照してください。

@item M-x send-invisible @key{RET} @var{text} @key{RET}
@findex send-invisible
エコーなしで@var{text}を読み取った後、それをシェルの入力として送ります。これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便利です。

デフォルトではEmacsはパスワードをエコーしないことに注意してください。もし本当にエコーさせたいときは、以下のLisp式を評価します(@ref{Lisp
Eval}を参照してください):

@example
(remove-hook 'comint-output-filter-functions
             'comint-watch-for-password-prompt)
@end example

@item M-x comint-continue-subjob
@findex comint-continue-subjob
シェルプロセスを継続します。これは間違ってシェルプロセスをサスペンドしてしまったときなどに便利です。@footnote{シェルプロセスをサスペンドするべきではありません。これはシェルのサブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりません。このコマンドはそれを行ないません。}

@item M-x comint-strip-ctrl-m
@findex comint-strip-ctrl-m
シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受け取ったときに自動的に実行されるようにする方法です。これを行なうには、以下のLisp式を評価します:

@example
(add-hook 'comint-output-filter-functions
          'comint-strip-ctrl-m)
@end example

@item M-x comint-truncate-buffer
@findex comint-truncate-buffer
このコマンドはシェルバッファーを、変数@code{comint-buffer-maximum-size}により指定される、特定の最大行数に切り詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこれを行なう方法です:

@example
(add-hook 'comint-output-filter-functions
          'comint-truncate-buffer)
@end example
@end table

@cindex Comint mode
@cindex mode, Comint
  Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けのComintモードから派生したモードです。上記のコマンド名からも判るとおり、Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモードの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマンドが含まれます。

  Comintモードの変種を使う他のEmacs機能には、GUD (@ref{Debuggers}を参照してください)や、@kbd{M-x
run-lisp} (@ref{External Lisp}を参照してください)が含まれます。

@findex comint-run
  サブプロセスとして選択した任意のプログラムを実行するために、Shellモードに特化しない未修正のComintモードを使用するには、@kbd{M-x
comint-run}を使用することができます。

@node Shell Prompts
@subsection Shellプロンプト

@cindex prompt, shell
  プロンプトとは、新しいユーザー入力を受け取る準備ができたことを表す、プログラムによるテキスト出力のことです。Comintモード(したがってShellモードも)は通常、サブプロセスからの出力にもとづいて、バッファーの一部をプロンプトとして自動的に判断します(具体的には、改行で終端されていない任意の出力行を受け取ったときは、プロンプトとみなします)。

  Comintモードは、バッファーを2つのタイプの@dfn{フィールド(fields)}に分けます。1つは入力フィールド(ユーザーの入力がタイプされるところ)で、もう1つは出力フィールド(入力フィールド以外)です。プロンプトは出力フィールドの一部です。ほとんどのEmacs移動コマンドは、そのコマンドが複数行を移動しない限り、フィールド境界を超えることはありません。たとえば、ポイントがシェルコマンドの入力フィールドにある場合、@kbd{C-a}はポイントを入力フィールドの先頭、プロンプトの後に配します。内部的には、フィールドはテキストプロパティー@code{field}を使って実装されています(@ref{Text
Properties,,, elisp, the Emacs Lisp Reference Manual}を参照してください)。

@vindex comint-use-prompt-regexp
@vindex shell-prompt-pattern
  変数@code{comint-use-prompt-regexp}を非@code{nil}値に変更した場合、Comintモードは正規表現を使ってプロンプトを認識します(@ref{Regexps}を参照してください)。Shellモードでは、その正規表現は変数@code{shell-prompt-pattern}により指定されます。@code{comint-use-prompt-regexp}のデフォルト値は@code{nil}です。なぜならプロンプト認識のためのこの方法は信頼性が低いためです。しかし特殊な状況では、これを非@code{nil}値にセットしたいと思うこともあるでしょう。そのような場合、EmacsはComintバッファーをフィールドに分割しないので、一般的な移動コマンドは、テキストプロパティーを使用せず、それらのコマンドがバッファーで通常行なうように振る舞います。しかし、バッファーを便利に操作するために、パラグラフ移動コマンドを使うことができます(@ref{Paragraphs}を参照してください)。Shellモードでは、Emacsはパラグラフ境界に@code{shell-prompt-pattern}を使用します。

@node Shell History
@subsection Shellコマンドヒストリー

  Shellバッファーは、以前のコマンドを繰り返す3つの方法をサポートします。1つ目はミニバッファーヒストリーにたいして使うのと同じようなキーを使う方法です。つまり、これらはミニバッファーで行なうのと同じように、前のコマンドからテキストを挿入して、ポイントを常にバッファーの最後に保ちます。2つ目は、バッファーを移動して元の場所から前の入力を取得して、それらを再実行したり、バッファーの最後にコピーする方法です。3つ目は@samp{!}スタイルのヒストリー参照を使う方法です。

@menu
* Ring: Shell Ring.          ヒストリーリストからコマンドを取り出す。
* Copy: Shell History Copying.  コマンドに移動して、それをコピーする。
* History References::       @samp{!}スタイルのヒストリー参照の展開。
@end menu

@node Shell Ring
@subsubsection Shellヒストリーリング

@table @kbd
@findex comint-previous-input
@kindex M-p @r{(Shell mode)}
@item M-p
@itemx C-@key{UP}
以前のシェルコマンドから、次に古いコマンドを取り出します。

@kindex M-n @r{(Shell mode)}
@findex comint-next-input
@item M-n
@itemx C-@key{DOWN}
以前のシェルコマンドから、次に新しいコマンドを取り出します。

@kindex M-r @r{(Shell mode)}
@findex comint-history-isearch-backward-regexp
@item M-r
以前のシェルコマンドにたいして、インクリメンタルregexp検索を開始します。

@item C-c C-x
@kindex C-c C-x @r{(Shell mode)}
@findex comint-get-next-from-history
ヒストリーから次のコマンドを取り出します。

@item C-c .
@kindex C-c . @r{(Shell mode)}
@findex comint-input-previous-argument
以前のシェルコマンドから引数を1つ取り出します。

@item C-c C-l
@kindex C-c C-l @r{(Shell mode)}
@findex comint-dynamic-list-input-ring
そのバッファーのシェルコマンドのヒストリーを、別のウィンドウに表示します(@code{comint-dynamic-list-input-ring})。
@end table

  Shellバッファーは、以前に入力したシェルコマンドのヒストリーを提供します。ヒストリーからシェルコマンドを再利用するには、編集コマンド@kbd{M-p}、@kbd{M-n}、@kbd{M-r}、@kbd{M-s}を使用します。これらは、ミニバッファーではなくShellバッファーを操作する点を除き、ミニバッファーヒストリーコマンド(@ref{Minibuffer
History}を参照してください)と同じように機能します。

  @kbd{M-p}は、シェルバッファーの最後から以前のシェルコマンドを取り出します。連続して@kbd{M-p}を使用すると、古いシェルコマンドを連続して取り出し、その度にシェル入力の候補として表示されているテキストを置き換えます。@kbd{M-n}も同様に機能しますが、これはバッファーから、より新しいシェルコマンドを連続して探します。@kbd{C-@key{UP}}は@kbd{M-p}と同様に機能し、@kbd{C-@key{DOWN}}は@kbd{M-n}と同様に機能します。

  ヒストリー検索コマンド@kbd{M-r}は、以前のシェルコマンドにたいしてインクリメンタル正規表現検索を開始します。@kbd{M-r}とタイプした後に、検索したい文字列か正規表現のタイプを開始します。するとマッチする最後のシェルコマンドがカレント行に表示されます。インクリメンタル検索コマンドは通常の効果をもちます
--- たとえば@kbd{C-s}および@kbd{C-r}は前方または後方に、次のマッチを検索します(@ref{Incremental
Search}を参照してください)。探している入力が見つかったら、検索を終了するために@key{RET}をタイプします。これにより、入力がコマンドラインに配されます。ヒストリーリストを操作する前にタイプしていた入力の一部は、ヒストリーリングの先頭または最後に達したときに復元されます。

  以前に実行した一連のシェルコマンドを、同じ順番で再実行できたら便利なこともあります。これを行なうには、最初に順番に再実行する1番目のコマンドを検索します。その後@kbd{C-c
C-x}とタイプします。これは次のコマンド ---
つまり再実行したコマンドの次のコマンドを取り出します。それから@key{RET}でそのコマンドを実行します。@kbd{C-c C-x
@key{RET}}を繰り返しタイプすることにより、連続する複数のコマンドを再実行することができます。

  コマンド@kbd{C-c .} (@code{comint-input-previous-argument})は、Bashの@kbd{@key{ESC}
.}のように、以前のコマンドから個別に引数をコピーします。一番簡単な使い方は、以前のシェルコマンドから最後の引数をコピーする方法です。プレフィクス引数@var{n}を指定すると、@var{n}番目の引数をコピーします。繰り返し@kbd{C-c
.}とタイプすることにより、さらに古いシェルコマンドからコピーします。この場合、常に同じ@var{n}の値を使用します(@kbd{C-c
.}を繰り返すときは、プレフィクス引数を与えないでください)。

  これらのコマンドは、以前のシェルコマンドのテキストを、シェルバッファー自身からではなく、特別なヒストリーリストから取得します。したがってシェルバッファーを編集したり、広い範囲をkillしても、これらのコマンドがアクセスするヒストリーに影響はありません。

@vindex shell-input-ring-file-name
  シェルの中には、コマンドヒストリーをファイルに保存して、以前のシェルセッションからコマンドを参照できるようにするものがあります。Emacsは選択されたシェルにたいして、コマンドヒストリーを初期化するために、コマンドヒストリーファイルを読み込みます。ヒストリーファイル名は、bashでは@file{~/.bash_history}、kshでは@file{~/.sh_history}、他のシェルでは@file{~/.history}です。

@node Shell History Copying
@subsubsection Shellヒストリーのコピー

@table @kbd
@kindex C-c C-p @r{(Shell mode)}
@findex comint-previous-prompt
@item C-c C-p
前のプロンプトにポイントを移動します(@code{comint-previous-prompt})。

@kindex C-c C-n @r{(Shell mode)}
@findex comint-next-prompt
@item C-c C-n
次のプロンプトにポイントを移動します(@code{comint-next-prompt})。

@kindex C-c RET @r{(Shell mode)}
@findex comint-copy-old-input
@item C-c @key{RET}
ポイント位置の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(@code{comint-copy-old-input})。これは以前のコマンドにポイントを移動したときに便利です。コマンドをコピーした後、@key{RET}でそのコピーを入力として実行することができます。再実行する前に、そのコピーを編集することもできます。このコマンドを出力行で使用した場合、その行をバッファーの最後にコピーします。

@item Mouse-2
@code{comint-use-prompt-regexp}が@code{nil}(デフォルト)の場合、クリックした以前の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入します(@code{comint-insert-input})。@code{comint-use-prompt-regexp}が非@code{nil}、または以前の入力以外の場所をクリックしたときは、通常のようにyankします。
@end table

  以前の入力に移動して、@kbd{C-c
@key{RET}}または@kbd{Mouse-2}でコピーすることは、@kbd{M-p}を充分な回数使用して、ヒストリーリングから以前の入力を取り出したときと同じ結果
--- つまり同じバッファー内容 --- を生成します。しかし@kbd{C-c
@key{RET}}は、バッファーからテキストをコピーするので、入力をシェルに送信した後に入力テキストを編集していた場合は、ヒストリーリストと異なります。

@node History References
@subsubsection Shellヒストリーの参照
@cindex history reference

  cshやbashを含むさまざまなシェルは、@samp{!}や@samp{^}で始まる@dfn{ヒストリー参照(history
references)}をサポートします。Shellモードはこれらを認識して、ヒストリーの置き換える処理をします。

  ヒストリー参照を挿入して@key{TAB}とタイプすると、これは入力ヒストリーからマッチするコマンドを検索して、必要なら置換を行い、結果をバッファー内のヒストリー参照の場所に配します。たとえば、一番最近の@samp{mv}で始まるコマンドを取り出すには、@kbd{!
m v @key{TAB}}とタイプします。必要ならコマンドを編集して、@key{RET}でシェルにたいしてコマンドを再実行できます。

@vindex comint-input-autoexpand
@findex comint-magic-space
  Shellモードはヒストリー参照をシェルに送るとき、オプションでヒストリー参照を展開できます。これを行なうには、変数@code{comint-input-autoexpand}を@code{input}にセットします。@key{SPC}を@code{comint-magic-space}にバインドすれば、@key{SPC}でヒストリー参照を展開できます。

  Shellモードは、ヒストリー参照がプロンプトの後にあればヒストリー参照を認識します。Shellモードがプロンプトを認識する方法については、@ref{Shell
Prompts}を参照してください。

@node Directory Tracking
@subsection ディレクトリーの追跡
@cindex directory tracking

@vindex shell-pushd-regexp
@vindex shell-popd-regexp
@vindex shell-cd-regexp
  Shellモードは、Shellバッファーのデフォルトディレクトリー(@ref{File
Names}を参照してください)をシェルの作業ディレクトリーと同一に保つために、サブシェルに与えられる@samp{cd}、@samp{pushd}、@samp{popd}のコマンドを追跡します。これは、送信する入力行を調べることにより認識されます。

  これらのコマンドにたいしてエイリアスを使用する場合、変数@code{shell-pushd-regexp}、@code{shell-popd-regexp}、@code{shell-cd-regexp}に適切な正規表現(@ref{Regexps}を参照してください)をセットすることにより、それらも認識するようEmacsに指示できます。たとえば、@code{shell-pushd-regexp}がシェルコマンドラインの先頭にマッチした場合、その行は@code{pushd}コマンドとして記録されます。これらのコマンドは、シェルコマンドラインの先頭だけで認識されます。

@findex dirs
  Emacsが作業ディレクトリーの変更に際して混乱した場合は、@kbd{M-x
dirs}を試してください。このコマンドはシェルに作業ディレクトリーを尋ねて、それに対応してデフォルトディレクリーを更新します。これは、一般的なコマンド構文のほとんどをサポートするシェルでは機能しますが、特殊なシェルでは機能しないかもしれません。

@findex dirtrack-mode
@cindex Dirtrack mode
@cindex mode, Dirtrack
@vindex dirtrack-list
  シェルの作業ディレクトリーを追跡する他の方法を実装した、バッファーローカルなマイナーモードの、Dirtrackモードを使うこともできます。この方法を使うには、シェルプロンプトに常に作業ディレクトリーが含まれていなければならず、プロンプトのどの部分が作業ディレクトリーを含むか認識するための正規表現を与えなければなりません。詳細は、変数@code{dirtrack-list}のドキュメントを参照してください。Dirtrackモードを使用するには、Shellバッファーで@kbd{M-x
dirtrack-mode}とタイプするか、@code{shell-mode-hook}に@code{dirtrack-mode}を追加します(@ref{Hooks}を参照してください)。

@node Shell Options
@subsection Shellモードのオプション

@vindex comint-scroll-to-bottom-on-input
  変数@code{comint-scroll-to-bottom-on-input}が非@code{nil}の場合、挿入およびyankコマンドは、挿入する前に選択されたウィンドウを、バッファーの最後までスクロールします。デフォルトは@code{nil}です。

@vindex comint-scroll-show-maximum-output
  @code{comint-scroll-show-maximum-output}が非@code{nil}の場合、ポイントが最後にあるとき到着した出力は、可能な限り有用なテキストを表示するために、テキストの最後の行がウィンドウの一番下になるようなスクロールを試みます(これはほとんどの端末のスクロール動作を真似た動作です)。デフォルトは@code{t}です。

@vindex comint-move-point-for-output
  @code{comint-move-point-for-output}をセットすることにより、出力が到着したときにバッファーの最後にポイントをジャンプさせることができます
---
その前にポイントがバッファーのどこにあろうと関係ありません。値が@code{this}の場合、選択されたウィンドウ内でポイントがジャンプします。値が@code{all}の場合、Comintバッファーを表示するすべてのウィンドウでポイントがジャンプします。値が@code{other}の場合、カレントバッファーを表示する、選択されていないすべてのウィンドウでポイントがジャンプします。デフォルト値は@code{nil}で、これはポイントが最後にジャンプしないことを意味します。

@vindex comint-prompt-read-only
  @code{comint-prompt-read-only}をセットした場合、Comintバッファーのプロンプトは読み取り専用になります。

@vindex comint-input-ignoredups
  変数@code{comint-input-ignoredups}は、連続する同じ入力を入力ヒストリーに保存するかを制御します。非@code{nil}値は、入力が前の入力と同じ場合は省略することを意味します。デフォルトは@code{nil}で、これは入力が前の入力と同じでも保存することを意味します。

@vindex comint-completion-addsuffix
@vindex comint-completion-recexact
@vindex comint-completion-autolist
  ファイル名の補完をカスタマイズする3つの変数があります。変数@code{comint-completion-addsuffix}は、完全に補完されたファイル名またはディレクトリー名の最後にスペースまたはスラッシュを挿入するかを制御します(非@code{nil}は、スペースまたはスラッシュを挿入することを意味します)。@code{comint-completion-recexact}が非@code{nil}の場合、通常のEmacs補完アルゴリズムが1文字も追加できないようなときは、@key{TAB}で一番短い利用可能な補完を選択するよう指示します。@code{comint-completion-autolist}が非@code{nil}の場合、補完が完全でないときは、利用可能なすべての候補をリストするよう指示します。

@vindex shell-completion-execonly
  コマンド補完は通常、実行可能ファイルだけを考慮します。@code{shell-completion-execonly}を@code{nil}にセットした場合は、実行可能ファイル以外も同様に考慮します。

@vindex shell-completion-fignore
@vindex comint-completion-fignore
変数@code{shell-completion-fignore}は、Shellモードで無視するファイル名の拡張子のリストを指定します。デフォルトは@code{nil}ですが、@samp{~}、@samp{#}、@samp{%}で終わるファイル名を無視するために@code{("~"
"#"
"%")}をセットするユーザーもいます。他のComintモードに関連するモードは、かわりに変数@code{comint-completion-fignore}を使用します。

@findex shell-dynamic-complete-command
シェルコマンド補完の実装の詳細は、@code{shell-dynamic-complete-command}関数のlispドキュメントで見ることもできます。

@findex shell-pushd-tohome
@findex shell-pushd-dextract
@findex shell-pushd-dunique
  @samp{pushd}の動作を設定することができます。@code{shell-pushd-tohome}は、引数を与えない場合に@samp{pushd}が@samp{cd}のように振る舞うかを制御します。@code{shell-pushd-dextract}は、数引数を与えたときローテートするのではなくpopするかを制御します。@code{shell-pushd-dunique}は、ディレクトリースタックにディレクトリーがない場合だけ追加するかを制御します。もちろん選択する値は背後のシェルに適合する必要があります。

@node Terminal emulator
@subsection Emacsの端末エミュレーター
@findex term

  テキスト端末エミュレーターでサブシェルを実行するには、@kbd{M-x
term}を使用します。これは@file{*terminal*}という名前のバッファーを作成(または再利用)して、キーボードを入力とするサブシェルを実行し、出力はそのバッファーになります。

@cindex line mode @r{(terminal emulator)}
@cindex char mode @r{(terminal emulator)}
  端末エミュレーターは、2つの入力モードをもつTermモードを使用します。@dfn{lineモード(line
mode)}では、Termは基本的にShellモードのように振る舞います(@ref{Shell
Mode}を参照してください)。@dfn{charモード(char
mode)}では、文字は端末入力として直接サブシェルに送られます。唯一の例外は端末エスケープ文字で、デフォルトは@kbd{C-c}です(@ref{Term
Mode}を参照してください)。入力をエコーするのはサブシェルの役目です。サブシェルからの端末出力は、バッファーのポイントの後に送られます。

  (Emacsのような)いくつかのプログラムでは、端末スクリーンで詳細に外観を制御する必要があります。これらのプログラムは特別な制御コードを送ることによりこれを行ないます。Termモードは、@command{xterm}を含むほとんどの現代的な端末で使用できる、ANSI標準のVT100スタイルのエスケープシーケンスを認識・処理します(したがって、実際にEmacsのTermウィンドウ内でEmacsを実行することもできます)。

  @code{term}フェイスは、端末エミュレーターのテキストのデフォルトの外観を指定します(デフォルトは@code{default}フェイスと同じ外観です)。端末の制御コードがテキストの外観を変更するために使用される場合、これらは端末エミュレーター内で、フェイス@code{term-color-black}、@code{term-color-red}、@code{term-color-green}、@code{term-color-yellow}、@code{term-color-blue}、@code{term-color-magenta}、@code{term-color-cyan}、@code{term-color-white}、@code{term-color-underline}、@code{term-color-bold}で表示されます。@ref{Faces}を参照してください。

  シリアルポートに接続されたデバイスと通信するために、Termモードを使うこともできます。@ref{Serial Terminal}を参照してください。

  サブシェルをロードするために使用されるファイル名は、Shellモードと同じ方法で決定されます。複数の端末エミュレーターを作成するには、Shellモードと同じように、@kbd{M-x
rename-uniquely}を使って、バッファー@file{*terminal*}を違う名前にリネームします。

  Shellモードとは異なり、Termモードは入力を調べてカレントディレクトリーを追跡することはしません。しかし、いくつかのシェルはカレントディレクトリーをTermに告げることができます。これは@code{bash}のバージョン1.15以降では自動的に行なわれます。




@node Term Mode
@subsection Termモード
@cindex Term mode
@cindex mode, Term

  端末エミュレーターは、2つの入力モードをもつTermモードを使用します。lineモードでは、Termは基本的にShellモードのように振る舞います(@ref{Shell
Mode}を参照してください)。charモードでは、Termのエスケープ文字(通常は@kbd{C-c})を除き、文字は直接サブシェルに送られます。

  lineモードとcharモードを切り替えるには、以下のコマンドを使用します:

@table @kbd
@kindex C-c C-j @r{(Term mode)}
@findex term-line-mode
@item C-c C-j
lineモードに切り替えます(@code{term-line-mode})。すでにlineモードのときは何もしません。

@kindex C-c C-k @r{(Term mode)}
@findex term-char-mode
@item C-c C-k
charモードに切り替えます(@code{term-char-mode})。すでにcharモードのときは何もしません。
@end table

  以下のコマンドはcharモードだけで利用可能です:

@table @kbd
@item C-c C-c
サブシェルに、リテラルの@kbd{C-c}を送ります。

@item C-c @var{char}
これは通常のEmacsでの@kbd{C-x @var{char}}と等価です。たとえば@kbd{C-c o}は、通常@kbd{C-x
o}にグローバルにバインドされている@samp{other-window}を呼び出します。
@end table

@cindex paging in Term mode
  Termモードにはpage-at-a-time(1度に1ページ)機能があります。これが有効な場合、出力の画面の最後で一時停止します。

@table @kbd
@kindex C-c C-q @r{(Term mode)}
@findex term-pager-toggle
@item C-c C-q
page-at-a-timeを切り替えます。このコマンドはlineモードとcharモードの両方で機能します。この機能が有効な場合、モードラインには単語@samp{page}が表示され、Termが1画面に収まらない出力を受け取ったときは、一時停止してモードラインに@samp{**MORE**}を表示します。@key{SPC}とタイプすると次の1画面分の出力を表示し、@kbd{?}でオプションを見ることができます。このインターフェースは、@code{more}プログラムと同様です。
@end table

@node Remote Host
@subsection リモートホストのシェル
@cindex remote host
@cindex connecting to remote host
@cindex Telnet
@cindex Rlogin

  Termウィンドウから、通常の端末から使うコマンド(たとえば@code{telnet}や@code{rlogin})で、リモートコンピューターにログインすることができます。

  パスワードを尋ねるようなプログラムは、通常パスワードをエコーしないので、パスワードはバッファーにも表示されません。バッファーがcharモードの場合、実際の端末で使用しているのと同じ動作になります。lineモードの場合、パスワードは一時的に表示されますが、リターンをタイプするとパスワードは消去されます(これは自動的に行なわれます。特別なパスワード処理は行なっていません)。

  別のマシンにログインしているときは、リモートログインコマンドのために、環境変数@env{TERM}をセットすることにより、端末タイプを指定する必要があります(bashを使用している場合、リモートログインコマンドの前に、カンマで区切らず値割り当てを記述することにより、これを行なうことができます)。端末タイプ@samp{ansi}または@samp{vt100}は、ほとんどのシステムで動作するでしょう。

@node Serial Terminal
@subsection シリアル端末
@cindex terminal, serial
@findex serial-term

  コンピューターに、シリアルポートに接続されたデバイスがあるとき、@kbd{M-x
serial-term}とタイプすることにより、デバイスと通信することができます。このコマンドは新しいTermモードのバッファーのために、ポート番号、スピード、スイッチを尋ねます。Emacsは、通常のTermモードの端末で行なうのと同じように、このバッファーを通じてシリアルデバイスと通信します。

  シリアルポートのスピードはビット毎秒で計ります。もっとも一般的なスピードは9600ビット毎秒です。モードラインをクリックすることにより、このスピードを対話的に変更できます。

  シリアルポートはモードラインの``8N1''をクリックしても設定できます。デフォルトでは、シリアルポートは``8N1''に設定されており、これは各バイトは8ビットからなり、パリティービットチェックなし、ストップビットが1であることを意味します。

  スピードや設定が間違っている場合、デバイスと通信できず、おそらくウィンドウにはゴミが出力されるでしょう。

@node Emacs Server
@section サーバーとしてのEmacsの使用
@pindex emacsclient
@cindex Emacs as a server
@cindex server, using Emacs as
@cindex @env{EDITOR} environment variable

  さまざまなプログラムが、特定のテキスト断片を編集するために、あなたが選択したエディターを呼び出すことができます。たとえば、バージョンコントロールシステム(@ref{Version
Control}を参照してください)は、バージョンコントロールログを入力するためのエディターを呼び出し、Unixの@command{mail}ユーティリティーは送信メッセージの入力にエディターを呼び出します。慣例により、選択するエディターは、環境変数@env{EDITOR}で指定されます。しかし@env{EDITOR}を@samp{emacs}にセットした場合、Emacsが呼び出されますが、これは便利な方法ではありません
---
なぜなら新しいEmacsプロセスが開始されるからです。なぜこれが不便かというと、新たなEmacsプロセスは、既存のEmacsプロセスのバッファー、コマンドヒストリー、その他の情報を共有しないからです。

  Emacsを@dfn{edit
server(編集サーバー)}としてセットアップして、Emacsが外部からの編集リクエストを``listen''し、それに応じて動作させることにより、この問題を解決できます。Emacsサーバーを開始するには2つの方法があります:

@itemize
@findex server-start
@item
@kbd{M-x server-start}とタイプするか、initファイル(@ref{Init
File}を参照してください)に式@code{(server-start)}を記述して、既存のEmacsプロセスでコマンド@code{server-start}を実行します。既存のEmacsプロセスがサーバーになり、Emacsを終了すると、サーバーはそのEmacsプロセスとともに終了します。

@cindex daemon, Emacs
@item
コマンドラインオプション@samp{--daemon}を使用して、Emacsを@dfn{daemon}として実行します。@ref{Initial
Options}を参照してください。Emacsがこの方法で開始された場合、初期化の後に@code{server-start}を呼び出し、初期フレームを開くかわりに、呼び出した端末に制御を戻します。その後バックグラウンドで待機(wait)して、編集リクエストを待ちます(listen)。
@end itemize

@cindex @env{TEXEDIT} environment variable
  どちらの方法も、1度Emacsサーバーを開始すると、@command{emacsclient}というシェルコマンドを使用してEmacsに接続し、ファイルをvisitするよう指示できます。環境変数@env{EDITOR}に@samp{emacsclient}をセットすれば、外部プログラムは編集のために既存のEmacsプロセスを使用できます。@footnote{別の環境変数を使うプログラムもいくつかあります。たとえば、@TeX{}が@samp{emacsclient}を使うようにするには、環境変数@env{TEXEDIT}を@samp{emacsclient
+%d %s}にセットします。}

@vindex server-name
  変数@code{server-name}を使って、一意な``サーバー名''を与えることにより、同一マシン上で複数のEmacsサーバーを実行することができます。たとえば@kbd{M-x
set-variable @key{RET} server-name @key{RET} foo
@key{RET}}は、サーバー名を@samp{foo}にセットします。@code{emacsclient}プログラムは、@samp{-s}オプションで、名前によりサーバーを指定できます(@ref{emacsclient
Options}を参照してください)。

@findex server-eval-at
  一意なサーバー名によりサーバーを定義した場合、他のEmacsインスタンスからそのサーバーに接続し、@code{server-eval-at}関数を使用して、そのサーバーでLisp式を評価できます。たとえば@code{(server-eval-at
"foo" '(+ 1 2))}は、式@code{(+ 1
2)}をサーバー@samp{foo}で評価して、@code{3}を返します(そのような名前のサーバーが存在しない場合はエラーをシグナルします)。現在のところ、これは主に開発者に有用な機能です。

@menu
* Invoking emacsclient::     Emacsサーバーへの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。
@end menu

@node Invoking emacsclient
@subsection @code{emacsclient}の呼び出し
@cindex @code{emacsclient} invocation

  @command{emacsclient}プログラムを使う一番簡単な方法は、シェルコマンド@samp{emacsclient
@var{file}}を実行する方法です。ここで@var{file}はファイル名です。これはEmacsサーバーに接続して、Emacsプロセスの既存のフレームの1つ
--- グラフィカルなフレーム、またはテキスト端末のフレーム(@ref{Frames}を参照してください) ---
で@var{file}をvisitするよう指示します。それから、そのフレームを選択して編集を開始できます。

  Emacsサーバーが存在しない場合、@command{emacsclient}はエラーメッセージと共に終了します。Emacsプロセスに既存のフレームがない場合
--- これはサーバーがデーモン(@ref{Emacs Server}を参照してください)として開始されたときに発生し得ます ---
は、@command{emacsclient}を呼び出した端末でEmacsフレームをオープンします。

  オプション@samp{-c}および@samp{-t}を使用して、新しいフレームをグラフィカルなディスプレーまたはテキスト端末で開くように、@command{emacsclient}に強制することもできます。@ref{emacsclient
Options}を参照してください。

  単一のテキスト端末で実行している場合、@command{emacsclient}のシェルとEmacsサーバーを、次の2つの方法で切り替えることができます。1つ目は、Emacsサーバーと、別の仮想端末で@command{emacsclient}を実行して、@command{emacsclient}を呼び出した後にEmacsサーバーの仮想端末に切り替える方法です。2つ目は、Emacsサーバー自身からShellモード(@ref{Interactive
Shell}を参照してください)、またはTermモード(@ref{Term
Mode}を参照してください)を使って@command{emacsclient}を呼び出す方法です。@code{emacsclient}は、Emacs配下のサブシェルのときだけブロックするので、依然としてファイルの編集にEmacsを使用できます。

@kindex C-x #
@findex server-edit
  Emacsサーバーで@var{file}の編集を終えたら、そのバッファーで@kbd{C-x #}
(@code{server-edit})とタイプします。これはファイルを保存して、@command{emacsclient}プログラムに終了を告げるメッセージを送り返します。通常、@env{EDITOR}を使うプログラムは、何か他のことを行なう前に``エディター''
--- この場合は@command{emacsclient} --- の終了を待ちます。

  複数のファイル名を引数にして@command{emacsclient}を呼び出すこともできます。@samp{emacsclient
@var{file1} @var{file2}
...}は、Emacsサーバーに@var{file1}、@var{file2}、...をvisitするよう指示します。Emacsは@var{file1}をvisitしているバッファーを選択して、他のバッファーをバッファーリストの最後に隠します(@ref{Buffers}を参照してください)。指定されたすべてのファイルを終了したら(たとえば各サーバーバッファーで@kbd{C-x
#}をタイプしたら)、@command{emacsclient}プログラムは終了します。

@vindex server-kill-new-buffers
@vindex server-temp-file-regexp
  サーバーバッファーを終了すると、そのバッファーがサーバーバッファーを作成する前から存在していたバッファーでないかぎり、そのバッファーもkillされます。しかし@code{server-kill-new-buffers}を@code{nil}にセットした場合、別の基準が使用されます。この場合、サーバーバッファーの終了は、ファイル名が正規表現@code{server-temp-file-regexp}にマッチするときは、バッファーをkillします。これはある種の``一時ファイル''を区別するための仕組みです。

  各@kbd{C-x
#}は、さまざまなファイルを編集する、保留されている外部要求が他にないかチェックして、次のそのようなファイルを選択します。サーバーバッファーに辿り着くのに、@kbd{C-x
#}だけを使わなければならない訳ではありません。サーバーバッファーに手動で切り替えることもできます。しかし@kbd{C-x
#}は、@command{emacsclient}に終了したことを告げる方法なのです。

@vindex server-window
  変数@code{server-window}の値をウィンドウやフレームにした場合、@kbd{C-x
#}は常に次のサーバーバッファーを、そのウィンドウまたはそのフレームに表示します。

@node emacsclient Options
@subsection @code{emacsclient}のオプション
@cindex @code{emacsclient} options

  以下のようなオプション引数を@command{emacsclient}プログラムに渡すことができます:

@example
emacsclient -c +12 @var{file1} +4:3 @var{file2}
@end example

@noindent
引数@samp{+@var{line}}および@samp{+@var{line}:@var{column}}は、その後に続くファイルの行番号、または行番号と列番号を指定します。これらはEmacs自身に対するコマンドライン引数と同じように機能します。
@ref{Action Arguments}を参照してください。

  その他の@command{emacsclient}により認識されるオプション引数を以下にリストします:

@table @samp
@item -a @var{command}
@itemx --alternate-editor=@var{command}
@code{emacsclient}が、Emacsとの接続に失敗したとき実行するコマンドを指定します。これはスクリプト内で@code{emacsclient}を実行するとき便利です。

特別な例外として、@var{command}が空文字列の場合、接続に失敗したら@code{emacsclient}は(@command{emacs
--daemon}のように)Emacsをデーモンモードで開始して、再度接続を試みます。

@cindex @env{ALTERNATE_EDITOR} environment variable
環境変数@env{ALTERNATE_EDITOR}は、@samp{-a}オプションと同じ効果をもちます。両方が指定された場合は、後者のオプションが優先されます。

@cindex client frame
@item -c
既存のEmacsフレームを使うかわりに、新しいグラフィカルな@dfn{クライアントフレーム(client
frame)}を作成します。クライアントフレームでの、@kbd{C-x
C-c}の特別な振る舞いについては、以下を参照してください。(Xサーバーに接続できない等で)新たにグラフィカルなフレームを作成しない場合、あたかも@samp{-t}オプションが指定されたかのように、テキスト端末でクライアントフレームの作成を試みます。

MS-Windowsでは、単一のEmacsセッションがグラフィカルなフレームとテキスト端末のフレームの両方を表示することはできず、複数のテキスト端末のフレームを表示することもできません。したがってEmacsサーバーがテキスト端末で実行されている場合、@samp{-c}オプションは@samp{-t}オプションのように、サーバーのカレントテキスト端末で新たなフレームを作成します。@ref{Windows
Startup}を参照してください。

@samp{-c}オプションを指定するときに、ファイル名の引数を省略した場合、新しいフレームはデフォルトで@file{*scratch*}バッファーを表示します。変数@code{initial-buffer-choice}でこの振る舞いをカスタマイズできます(@ref{Entering
Emacs}を参照してください)。

@item -F @var{alist}
@itemx --frame-parameters=@var{alist}
新たに作成される、グラフィカルなフレームのパラメーターをセットします(@ref{Frame Parameters}を参照してください)。

@item -d @var{display}
@itemx --display=@var{display}
与えられたファイルを、(複数のXディスプレーがあることを想定して)Xディスプレー@var{display}で開くようEmacsに指示します。

@item -e
@itemx --eval
ファイルをvisitするかわりに、Emacs
Lispコードを評価するようEmacsに指示します。このオプションが与えられた場合、@command{emacsclient}は引数をvisitするファイルではなく、式のリストと解釈します。

@item -f @var{server-file}
@itemx --server-file=@var{server-file}
@cindex @env{EMACS_SERVER_FILE} environment variable
TCPを通じてEmacsサーバーに接続するための、@dfn{サーバーファイル(server file)}を指定します。

Emacsサーバーは通常、接続をlistenするために、オペレーティングシステムの``ローカルソケット(local
socket)''と呼ばれる仕組みを使用します。Microsoft
Windowsのようないくつかのシステムは、ローカルソケットをサポートしません。このような場合、サーバーはTCPを通じて@command{emacsclient}と通信します。

@vindex server-auth-dir
@cindex server file
@vindex server-port
TCP
Emacsサーバーを開始したとき、Emacsは@command{emacsclient}がサーバーに接続するために使用する、TCP情報を含む@dfn{サーバーファイル(server
file)}を作成します。デフォルトでは、これは@file{~/.emacs.d/server/}です。@command{emacsclient}が特定のサーバーファイルを使ってTCPでサーバーに接続するよう指示するには、オプション@samp{-f}または@samp{--server-file}を使用するか、環境変数@env{EMACS_SERVER_FILE}をセットしてください。

@item -n
@itemx --no-wait
すべてのサーバーバッファーが終了するのを待つかわりに、@command{emacsclient}が即座に終了するようにします。Emacsのサーバーバッファーで編集したいときに、このオプションを指定します。@kbd{C-x
#}をタイプしても、これらはkillされません。

@item --parent-id @var{id}
XEmbedプロトコルを通じて、IDが@var{id}の親Xウィンドウでクライアントフレームとして、@command{emacsclient}フレームをオープンします。現在のところ、これは主に開発者に有用なオプションです。

@item -q
@itemx --quiet
@command{emacsclient}がEmacsを待つメッセージ、またはリモートのサーバーソケットに接続するメッセージを表示しないようにします。

@item -s @var{server-name}
@itemx --socket-name=@var{server-name}
名前が@var{server-name}のEmacsサーバーに接続します。サーバー名は、Emacsサーバー上の変数@code{server-name}により与えられます。このオプションが省略された場合、@command{emacsclient}は見つかったサーバーに接続します(このオプションはMS-Windowsではサポートされません)。

@item -t
@itemx --tty
@itemx -nw
既存のEmacsフレームを使うかわりに、カレントテキスト端末に新たなクライアントフレームを作成します。これはテキスト端末のフレームを作成する点を除き、上記で説明した@samp{-c}と同じように振る舞います(@ref{Non-Window
Terminals}を参照してください)。

MS-Windowsでは、Emacsサーバーがグラフィカルなディスプレーを使っている場合は@samp{-c}のように振る舞いますが、Emacsサーバーがテキスト端末で実行されている場合は、カレントテキスト端末に新たなフレームを作成します。
@end table

  オプション@samp{-c}または@samp{-t}で作成された、グラフィカルなフレームおよびテキスト端末のフレームは、@dfn{クライアントフレーム(client
frames)}とみなされます。クライアントフレームから作成した新たなフレームも、クライアントフレームとみなされます。クライアントフレームで@kbd{C-x
C-c}
(@code{save-buffers-kill-terminal})とタイプした場合、それが通常行なうようなEmacsセッションのkill(@ref{Exiting}を参照してください)は行なわれません。かわりにEmacsはクライアントフレームを削除します。さらに、制御を取り戻すために待っている@command{emacsclient}をクライアントフレームがもつ場合(たとえば@samp{-n}オプションを与えなかった場合)、Emacsは同じくクライアントの他のすべてのフレームを削除し、(それらすべてにたいして@kbd{C-x
#}をタイプしたかのように)クライアントのサーバーバッファーが終了したとマークします。クライアントフレームが削除された後、残ったフレームが存在しない場合、Emacsセッションは終了します。

  例外として、Emacsがデーモンとして開始された場合、すべてのフレームはクライアントフレームとみなされ、@kbd{C-x
C-c}がEmacsをkillすることはありません。デーモンセッションを終了するには、@kbd{M-x kill-emacs}とタイプします。

  @samp{-t}と@samp{-n}は、矛盾するオプションであることに注意してください。@samp{-t}はカレントテキスト端末に新たにクライアントフレームを作成して制御することを指示し、@samp{-n}はテキスト端末で制御を行なわないことを指示するからです。両方のオプションを与えた場合、@samp{-t}の効果は打ち消されて、Emacsは新たにフレームを作成せず、既存のフレームで指定されたファイルをvisitします。

@node Printing
@section ハードコピーの印刷
@cindex hardcopy
@cindex printing

  Emacsは、バッファーの全体、または一部のハードコピーを印刷するコマンドを提供します。以下で詳しく述べるとおり、直接印刷コマンドを呼び出したり、メニューバーの@samp{File}メニューを使うことができます。

@findex htmlfontify-buffer
  このセクションで説明するコマンドとは別に、Dired(@ref{Operating on
Files}を参照してください)からハードコピーを印刷したり、ダイアリー(@ref{Displaying the
Diary}を参照してください)から印刷することもできます。コマンド@kbd{M-x
htmlfontify-buffer}で、EmacsバッファーをHTMLに``印刷''することもできます。これはEmacsのフェイスをCSSベースのマークアップに置換して、カレントバッファーをHTMLに変換します。さらにOrgモード(@ref{Org
Mode}を参照してください)では、OrgファイルをPDFのような様々なフォーマットに``印刷''できます。

@table @kbd
@item M-x print-buffer
ファイル名を含むページヘッダーとともに、カレントバッファーのハードコピーを印刷します。
@item M-x lpr-buffer
ページヘッダーなしで、カレントバッファーのハードコピーを印刷します。
@item M-x print-region
@code{print-buffer}と同様ですが、カレントリージョンだけを印刷します。
@item M-x lpr-region
@code{lpr-buffer}と同様ですが、カレントリージョンだけを印刷します。
@end table

@findex print-buffer
@findex print-region
@findex lpr-buffer
@findex lpr-region
@vindex lpr-switches
@vindex lpr-commands
  ほとんどのオペレーティングシステムでは、上記のハードコピーコマンドは、@command{lpr}プログラムを呼び出して、印刷のためにファイルをサブミットします。印刷プログラムを変更するには、変数@code{lpr-command}をカスタマイズします。追加のスイッチを指定して、印刷プログラムにに与えるには、リスト変数@code{lpr-switches}をカスタマイズします。この変数の値はオプション文字列のリストで、それぞれが@samp{-}で始まります(たとえばオプション文字列@code{"-w80"}は1行に80列を指定します)。デフォルトは、空リスト@code{nil}です。

@vindex printer-name
@vindex lpr-printer-switch
  使用するプリンターを指定するには、変数@code{printer-name}をセットします。デフォルトは@code{nil}で、これはデフォルトプリンターを指定します。これにプリンター名(文字列)をセットした場合、その名前は@samp{-P}スイッチとともに@command{lpr}に渡されます。@command{lpr}コマンドを使用しない場合は、スイッチを@code{lpr-printer-switch}で指定する必要があります。

@vindex lpr-headers-switches
@vindex lpr-add-switches
  同様に変数@code{lpr-headers-switches}は、ページヘッダーを作成するために使用する追加のスイッチを指定します。変数@code{lpr-add-switches}は、印刷プログラムに@samp{-T}および@samp{-J}オプション(@command{lpr}向きのオプションです)を渡すかどうかを制御します。@code{nil}は、これらを追加しないことを意味します(印刷プログラムが@command{lpr})互換でない場合は、この値を使用するべきです)。

@menu
* PostScript::               バッファーまたはリージョンを、PostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。
@end menu

@node PostScript
@subsection PostScriptのハードコピー

  これらのコマンドはバッファーの内容をPostScriptに変換して、それを印刷または別のEmacsバッファーに出力します。

@table @kbd
@item M-x ps-print-buffer
PostScript形式で、カレントバッファーのハードコピーを印刷します。
@item M-x ps-print-region
PostScript形式で、カレントリージョンのハードコピーを印刷します。
@item M-x ps-print-buffer-with-faces
PostScript形式で、カレントバッファーのハードコピーを印刷し、テキストで使用されているフェイスはPostScript機能により表示します。
@item M-x ps-print-region-with-faces
PostScript形式で、カレントリージョンのハードコピーを印刷し、テキストで使用されているフェイスで表示します。
@item M-x ps-spool-buffer
カレントバッファーのテキストにたいするPostScriptイメージを生成およびスプールします。
@item M-x ps-spool-region
カレントリージョンにたいするPostScriptイメージを生成およびスプールします。
@item M-x ps-spool-buffer-with-faces
カレントバッファーにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。
@item M-x ps-spool-region-with-faces
カレントリージョンにたいするPostScriptイメージを生成およびスプールし、使用されているフェイスで表示します。
@item M-x ps-despool
Send the spooled PostScript to the printer.
@item M-x handwrite
カレントバッファーにたいして、手書きされたようなPostScriptを生成・印刷します。
@end table

@findex ps-print-region
@findex ps-print-buffer
@findex ps-print-region-with-faces
@findex ps-print-buffer-with-faces
  @code{ps-print-buffer}および@code{ps-print-region}コマンドは、バッファーの内容をPostScript形式で印刷します。一方はバッファー全体を印刷し、もう一方はリージョンだけを印刷します。コマンド@code{ps-print-buffer-with-faces}および@code{ps-print-region-with-faces}も同様に振る舞いますが、バッファーテキストのフェイス(フォントとカラー)を表示するためにPostScript機能を使用します。

  プレフィクス引数(@kbd{C-u})を使用した場合、このコマンドは対話的にユーザーにファイル名の入力を求め、PostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

@findex ps-spool-region
@findex ps-spool-buffer
@findex ps-spool-region-with-faces
@findex ps-spool-buffer-with-faces
  @samp{print}のかわりに@samp{spool}が名前につくコマンドは、PostScript出力をプリンターに送るかわりに、Emacsバッファーに出力することを意味します。

@findex ps-despool
  コマンド@code{ps-despool}を使用して、スプールされたイメージをプリンターに送ります。このコマンドは@samp{-spool-}コマンド(上記コマンド参照)により生成されたPostScriptをプリンターに送ります。プレフィクス引数(@kbd{C-u})を指定した場合は、ファイル名の入力を求め、スプールされたPostScriptイメージをプリンターに送るかわりに、そのファイルに保存します。

@findex handwrite
@cindex handwriting
  @kbd{M-x
handwrite}はもっと他愛ない機能です。これはカレントバッファーのPostScript表現を、草書体の手書きドキュメントのように生成します。これはグループ@code{handwrite}でカスタマイズできます。この関数はISO
8859-1文字だけサポートします。

@node PostScript Variables
@subsection PostScriptハードコピーにたいする変数

@vindex ps-lpr-command
@vindex ps-lpr-switches
@vindex ps-printer-name
  すべてのPostScriptハードコピーコマンドは、どのように出力を印刷するかの指定に、変数@code{ps-lpr-command}と@code{ps-lpr-switches}を使用します。@code{ps-lpr-command}は実行するコマンド名、@code{ps-lpr-switches}は使用するコマンドラインオプション、@code{ps-printer-name}はプリンターを指定します。最初の2つの変数をセットしない場合、変数の初期値を@code{lpr-command}と@code{lpr-switches}から取得します。@code{ps-printer-name}が@code{nil}の場合、@code{printer-name}が使用されます。

@vindex ps-print-header
  変数@code{ps-print-header}は、これらのコマンドが各ページにヘッダー行を追加するかを制御します。これを@code{nil}にセットするとヘッダーはオフになります。

@cindex color emulation on black-and-white printers
@vindex ps-print-color-p
  プリンターがカラーをサポートしない場合は、@code{ps-print-color-p}を@code{nil}にセットして、カラー処理をオフにするべきです。デフォルトでは、ディスプレーがカラーをサポートしていれば、Emacsはカラー情報をもったハードコピー出力を生成します。モノクロプリンターでは、カラーはグレーの濃淡でエミュレートされます。スクリーンカラーがグレーの濃淡だけしか使用していなくても、これは読みにくい出力を生成するかもしれません。

  かわりに@code{ps-print-color-p}を@code{black-white}にセットして、モノクロプリンターで印刷する色をセットできます。

@vindex ps-use-face-background
  デフォルトでは、変数@code{ps-use-face-background}が非@code{nil}でなければ、PostScript印刷はフェイスのバックグラウンドカラーは無視します。これは望ましくないゼブラストライプや、バックグラウンドイメージとテキストの干渉を避けるためです。

@vindex ps-paper-type
@vindex ps-page-dimensions-database
  変数@code{ps-paper-type}は、フォーマットする用紙サイズを指定します。妥当な値には@code{a4}、@code{a3}、@code{a4small}、@code{b4}、@code{b5}、@code{executive}、@code{ledger}、@code{legal}、@code{letter}、@code{letter-small}、@code{statement}、@code{tabloid}が含まれます。デフォルトは@code{letter}です。変数@code{ps-page-dimensions-database}を変更することにより、追加の用紙サイズを定義できます。

@vindex ps-landscape-mode
  変数@code{ps-landscape-mode}は、ページの印刷向きを指定します。デフォルトは@code{nil}で、これは縦向き印刷モード(portrait
mode)を意味します。非@code{nil}値は横向き印刷モード(landscape mode)を指定します。

@vindex ps-number-of-columns
  変数は列番号を指定します。この変数は横向きモードと縦向きモードの両方で効果をもちます。デフォルトは1です。

@vindex ps-font-family
@vindex ps-font-size
@vindex ps-font-info-database
  変数@code{ps-font-family}は、通常のテキストを印刷するために使用するフォントファミリーを指定します。妥当な値には、@code{Courier}、@code{Helvetica}、@code{NewCenturySchlbk}、@code{Palatino}、@code{Times}が含まれます。変数@code{ps-font-size}は、通常のテキストのためのフォントサイズを指定します。デフォルトは8.5ポイントです。

@vindex ps-multibyte-buffer
@cindex Intlfonts for PostScript printing
@cindex fonts for PostScript printing
  Emacsは、通常のPostScriptプリンターより多くのスクリプトと文字をサポートします。したがってバッファーのいくつかの文字は、プリンターに組み込まれたフォントを使って印刷できないかもしれません。プリンターが提供するフォントをGNU
Intlfontsパッケージのフォントで増強したり、EmacsにIntlfontsフォントだけを使うように命令できます。変数@code{ps-multibyte-buffer}がこれを制御します。デフォルト値の@code{nil}は、@acronym{ASCII}およびLatin-1文字を印刷するのに適しています。@code{non-latin-printer}は、プリンターに@acronym{ASCII}、Latin-1、Japanese、Korean文字にたいするフォントが組み込まれている場合の値です。@emph{すべて}の文字にたいして使用される、IntlfontsパッケージのBDFフォントのための値が@code{bdf-font}です。最後に値@code{bdf-font-except-latin}は、@acronym{ASCII}およびLatin-1文字にたいしては組み込みフォントを使用し、それ以外の文字にたいしてはIntlfontsのBDFフォントを使用するよう指示します。

@vindex bdf-directory-list
  BDFフォントを使えるようにするには、それをどこで見つけることができるかを、Emacsが知る必要があります。変数@code{bdf-directory-list}は、Emacsがこれらのフォントを探すべきディレクトリーのリストを保持します。デフォルト値には、1つのディレクトリー@file{/usr/local/share/emacs/fonts/bdf}が含まれます。

  これらのコマンドに対する、その他多くのカスタマイズ変数は、Lispファイル@file{ps-print.el}および@file{ps-mule.el}で定義・説明されています。

@node Printing Package
@subsection 印刷のためのパッケージ
@cindex Printing package

  ハードコピーを印刷するためのEmacsの基本的な機能は、Printingパッケージを使って拡張できます。これは何を印刷するかの選択、印刷前のPostScriptファイルのプレビュー、プリントヘッダーなどのさまざまな印刷オプションの設定、横向きモードや縦向きモード、duplexモードにたいする使いやすいインターフェースを提供します。GNU/LinuxシステムまたはUnixシステムでは、Printingパッケージは、GhostScriptプログラムの一部として配布される、@file{gs}および@file{gv}ユーティリティーに依存しています。MS-Windowsでは、Ghostscriptのポート版の@file{gstools}が使用されます。

@findex pr-interface
  Printingパッケージを使用するには、initファイル(@ref{Init File}を参照してください)に@code{(require
'printing)}を追加して、その後に@code{(pr-update-menus)}と記述します。この関数はメニューバーの通常の印刷コマンドを、さまざまな印刷オプションを含む@samp{Printing}サブメニューに置き換えます。@kbd{M-x
pr-interface @key{RET}}とタイプすることもできます。これはカスタマイズバッファーに似た@file{*Printing
Interface*}バッファーを作成し、そこで印刷オプションをセットできます。何をどのようにして印刷するかセットした後、@samp{Print}ボタン(それを@kbd{Mouse-2}でクリックするか、その上にポイントを移動して@key{RET}をタイプします)で印刷ジョブを開始します。さまざまなオプションについての詳細は、@samp{Interface
Help}ボタンを使用してください。

@node Sorting
@section テキストのソート
@cindex sorting

  Emacsは、バッファーのテキストをソートするためのコマンドをいくつか提供しています。これらはすべて、リージョンの内容にたいして処理を行ないます。これらのコマンドはリージョンのテキストを、多数の@dfn{ソートレコード(sort
records)}に分割し、各レコードを@dfn{ソートキー(sort
key)}で識別した後、ソートキーにより決定される順序にレコードを並び替えます。レコードは並び替えられ、レコードのキーはアルファベット順、または数値ソートでは数値順になります。アルファベット順のソートでは、@acronym{ASCII}文字順にしたがい、@samp{A}から@samp{Z}のすべての大文字は、小文字の@samp{a}の前になります。

  種々のソートコマンドは、テキストをどのようにソートレコードに分割するか、そして各レコードのどの部分がソートキーとして使用されるかという点で異なります。ほとんどのコマンドは行ごとにソートレコードを分割しますが、ソートレコードとしてパラグラフやページを使うコマンドもあります。ほとんどのソートコマンドは、ソートレコード全体をソートキーとして使用しますが、レコードの一部をソートキーとして使用するものもあります。

@findex sort-lines
@findex sort-paragraphs
@findex sort-pages
@findex sort-fields
@findex sort-numeric-fields
@vindex sort-numeric-base
@table @kbd
@item M-x sort-lines
リージョンを行に分割して、行のテキスト全体を比較してソートします。数引数は降順でソートすることを意味します。

@item M-x sort-paragraphs
リージョンをパラグラフに分割して、パラグラフのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

@item M-x sort-pages
リージョンをページに分割して、ページのテキスト全体(先頭の空行は除く)を比較してソートします。数引数は降順にソートすることを意味します。

@item M-x sort-fields
リージョンを行に分割して、各行のあるフィールドの内容を比較することによりソートします。フィールドは空白で区切ることにより定義されるので、ある行の最初の連続する非空白文字がフィールド1を構成し、2番目のそのような文字構成がフィールド2、...となります。

どのフィールドでソートするかは数引数で指定します。1はフィールド1、2はフィールド2、...となります。負の引数はフィールドを左からではなく右から数えることを意味します。したがって、-1は最後のフィールドでソートするという意味です。ソートされるフィールドの内容が同じ行が複数存在する場合、バッファーの元の並び順が維持されます。

@item M-x sort-numeric-fields
@kbd{M-x
sort-fields}と同様ですが、各行の指定されたフィールドを整数に変換して、その数字を比較します。テキストとして比較したとき@samp{10}は@samp{2}の前になりますが、数字として比較すると@samp{2}の後になります。デフォルトでは、数字は@code{sort-numeric-base}により解釈されますが、@samp{0x}または@samp{0}で始まる数字は16進および8進で解釈されます。

@item M-x sort-columns
@kbd{M-x sort-fields}と同様ですが、各行で比較に使用されるテキストは固定長の列範囲です。以下の説明を参照してください。

@findex reverse-region
@item M-x reverse-region
リージョンの行を逆順にソートします。フィールドまたは列でソートするコマンドは降順でソートする機能がないので、フィールドまたは列で降順にソートできるのは便利です。
@end table

  たとえば、以下のようなバッファー内容のとき:

@smallexample
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
whether the file has changed on disk since it was last visited or
saved.  If it has, you are asked to confirm that you want to change
the buffer.
@end smallexample

@noindent
バッファー全体に@kbd{M-x sort-lines}を適用すると以下のようになります:

@smallexample
On systems where clash detection (locking of files being edited) is
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
whether the file has changed on disk since it was last visited or
@end smallexample

@noindent
大文字の@samp{O}はすべての小文字の前にソートされます。かわりに@kbd{C-u 2 M-x
sort-fields}を使用すると、以下が得られます:

@smallexample
implemented, Emacs also checks the first time you modify a buffer
saved.  If it has, you are asked to confirm that you want to change
the buffer.
On systems where clash detection (locking of files being edited) is
whether the file has changed on disk since it was last visited or
@end smallexample

@noindent
ここで、ソートキーは@samp{Emacs}、@samp{If}、@samp{buffer}、@samp{systems}、@samp{the}です。

@findex sort-columns
  @kbd{M-x
sort-columns}は説明が必要でしょう。ある列にポイントを配し、別の列をマークして、ソート列を指定します。ソートしたいテキストの最初の行の先頭にポイントまたはマークを配すことはできないので、このコマンドは特殊な``リージョン''の定義を使用します。ポイントがある行はすべてリージョンの一部と判断されます。マークがある行もすべてリージョンの一部と判断されます。同様にその間にあるすべての行もリージョンの一部となります。

  たとえば、10列目から15列目までの情報でテーブルをソートするには、テーブルの最初の行の10列目にマークを置き、最後の行の15列目にポイントを置いて、@code{sort-columns}を実行します。最初の行の15列目にマークを置き、最後の行の10列目にポイントを置いても、同じように実行できます。

  これはポイントとマークで指定された矩形領域をソートすると考えることができます。1つ違うのは、各行の矩形領域の左右にあるテキストも、矩形領域内のテキストとともに移動するという点です。@ref{Rectangles}を参照してください。

@vindex sort-fold-case
  @code{sort-fold-case}が非@code{nil}の場合、多くのソートコマンドは比較時の大文字小文字の違いを無視します。

@c Picture Mode documentation
@ifnottex
@include picture-xtra.texi
@end ifnottex


@node Editing Binary Files
@section バイナリーファイルの編集

@cindex Hexl mode
@cindex mode, Hexl
@cindex editing binary files
@cindex hex editing
  バイナリーファイルを編集する特別なメジャーモードに、Hexlモードがあります。これを使用するには、ファイルをvisitするのに。@kbd{C-x
C-f}のかわりに@kbd{M-x
hexl-find-file}を使用します。このコマンドはファイル内容を16進に変換して、その変換結果を編集できるようにします。ファイルを保存するときは、自動的にバイナリーに変換されます。

  既存のバッファーをhexに変換するために、@kbd{M-x
hexl-mode}を使用することもできます。これは普通にファイルをvisitしてから、それがバイナリーファイルだと気づいた場合などに便利です。

  Hexlモードでは通常のテキスト文字は上書きです。これはファイル内のデータのアラインメントを意図せず壊してしまう危険を減らすためです。挿入のためには特別なコマンドがあります。以下はHexlモードのコマンドのリストです:

@c I don't think individual index entries for these commands are useful--RMS.
@table @kbd
@item C-M-d
10進でタイプされたバイトコードを挿入します。

@item C-M-o
8進でタイプされたバイトコードを挿入します。

@item C-M-x
16進でタイプされたバイトコードを挿入します。

@item C-x [
1Kバイト``ページ''の先頭に移動します。

@item C-x ]
1Kバイト``ページ''の最後に移動します。

@item M-g
16進で指定されたアドレスに移動します。

@item M-j
10進で指定されたアドレスに移動します。

@item C-c C-c
Hexlモードを抜けて、@code{hexl-mode}モードを呼び出す前の、このバッファーのメジャーモードに戻ります。
@end table

@noindent
他のHexlコマンドには、バイナリーバイトの文字列(シーケンス)の挿入、@code{short}、@code{int}単位での移動などがあります。詳細については、@kbd{C-h
a hexl-@key{RET}}とタイプしてください。


@node Saving Emacs Sessions
@section Emacsセッションの保存
@cindex saving sessions
@cindex restore session
@cindex remember editing session
@cindex reload files
@cindex desktop

@vindex desktop-restore-frames
   Emacsの状態を1つのセッションから別のセッションのために保存するためには、desktopライブラリーを使用します。1度Emacsの@dfn{デスクトップ(desktop)}
--- バッファーと、それらのファイル名、メジャーモード、バッファーでの位置など ---
を保存すると、後のEmacsセッションで、保存されたデスクトップをリロードできます。デフォルトでは、デスクトップはフレームとウィンドウ設定も保存しようと試みます。これを無効にするには、@code{desktop-restore-frames}を@code{nil}にセットします(この振る舞いを調整するためにマスタマイズできる関連オプションについては、変数のドキュメントを参照してください)。

@findex desktop-save
@vindex desktop-save-mode
  コマンド@kbd{M-x
desktop-save}で、デスクトップを手動で保存できます。Emacs終了時のデスクトップの自動保存を有効にすることもできます。またEmacs開始時に最後に保存されたデスクトップを自動的に復元することもできます。将来のセッションのためには、Customizationバッファー(@ref{Easy
Customization}を参照してください)を使用して、@code{desktop-save-mode}を@code{t}にセットするか、initファイル(@ref{Init
File}を参照してください)に以下の行を追加します:

@example
(desktop-save-mode 1)
@end example

@vindex desktop-auto-save-timeout
@noindent
@code{desktop-save-mode}がアクティブで、desktopファイルが存在する場合、Emacsは@code{desktop-auto-save-timeout}秒ごと(非@code{nil}かつ非0の場合)にデスクトップを自動保存します。

@findex desktop-change-dir
@findex desktop-revert
@vindex desktop-path
  initファイルで@code{desktop-save-mode}をオンにした場合、Emacsはカレントディレクトリーで保存されたデスクトップを探します(より正確には、@var{desktop-path}で指定されたディレクトリーを探して、最初に見つかったデスクトップを使用します)。したがって異なるディレクトリーに別のデスクトップを保存でき、開始ディレクトリーによりEmacsがリロードするデスクトップを決定できます。@kbd{M-x
desktop-change-dir}とタイプすることにより、カレントデスクトップを保存して、他のディレクトリーに保存されたデスクトップをリロードできます。@kbd{M-x
desktop-revert}とタイプすることにより、前にリロードされたデスクトップをリバートできます。

  保存されたデスクトップをリロードしたくないときは、コマンドラインでオプション@samp{--no-desktop}を指定します。これはカレントセッションにたいして、@code{desktop-save-mode}をオフにします。@samp{--no-init-file}オプションを指定してEmacsを開始することにより、通常@code{desktop-save-mode}をオンにしているinitファイルをバイパスして、デスクトップのリロードを無効にすることもできます。

@vindex desktop-restore-eager
  デフォルトでは、デスクトップのすべてのバッファーは1度に復元されます。しかし、デスクトップにたくさんのバッファーがあるときは遅くなるかもしれません。変数@code{desktop-restore-eager}で、即座に復元するバッファーの最大数を指定できます。残りのバッファーはEmacsのアイドル時に、``ゆっくり(lazily)''と復元されます。

@findex desktop-clear
@vindex desktop-globals-to-clear
@vindex desktop-clear-preserve-buffers-regexp
  Emacsのデスクトップを空にするには、@kbd{M-x
desktop-clear}とタイプします。これは内部バッファーを除いてすべてのバッファーをkillし、@code{desktop-globals-to-clear}にリストされたグローバル変数をクリアーします。特定のバッファーを残したい場合は、変数@code{desktop-clear-preserve-buffers-regexp}をカスタマイズします。この変数の値には、killしないバッファーの名前にマッチする正規表現を指定します。

  あるセッションから別のセッションへ、ミニバッファーのヒストリーを保存したい場合は、@code{savehist}ライブラリーを使用してください。

@node Recursive Edit
@section 再帰編集レベル
@cindex recursive editing level
@cindex editing level, recursive

  @dfn{再帰編集(recursive
edit)}とは、あるEmacsコマンドの途中で、別のEmacsコマンドを使用して自由に編集を行なうような状況を指します。たとえば@code{query-replace}の途中で@kbd{C-r}をタイプすると、カレントバッファーを変更することができる再帰編集に入ります。再帰編集から抜けると、@code{query-replace}に戻ります。@ref{Query
Replace}を参照してください。

@kindex C-M-c
@findex exit-recursive-edit
@cindex exiting recursive edit
  再帰編集を@dfn{抜ける(exit)}とは、実行を継続中の、終了していないコマンドに戻ることを意味します。再帰編集を抜けるコマンドは@kbd{C-M-c}
(@code{exit-recursive-edit})です。

  再帰編集を@dfn{中断(abort)}することもできます。これはexitと似ていますが、終了していないコマンドも即座に終了します。これを行なうには、コマンド@kbd{C-]}
(@code{abort-recursive-edit})を使用します。@ref{Quitting}を参照してください

  モードラインで常にメジャーモードとマイナーモードの周りを囲む丸カッコ(parentheses)を、さらに角カッコ(square
brackets)で囲んで表示することにより、再帰編集中であることが示されます。再帰編集は特定のウィンドウやバッファーにたいするものではなく、Emacs全体が再帰編集中であるため、すべてのウィンドウのモードラインは同じように表示されます。

  再帰編集中に、さらに再帰編集に入ることも可能です。たとえば@code{query-replace}の途中で@kbd{C-r}とタイプした後、デバッガーに入るコマンドをタイプしたとします。これは@kbd{C-r}にたいする再帰編集レベルから、デバッガーにたいする再帰編集を開始します。モードラインには、現在進行中の再帰編集レベルが角カッコのペアで表示されます。

  (デバッガーでの@kbd{c}コマンドのように)内側の再帰編集を抜けると、次に上のレベルのコマンドの実行が再開されます。コマンドが終了したら、他の再帰編集レベルに抜けるために@kbd{C-M-c}を使用することができます。exitは最内レベルだけに適用されます。abortも1レベルの再帰編集だけを抜けて、前の再帰編集レベルのコマンドに即座に戻ります。もし望むなら次の再帰編集レベルもabortできます。

  かわりにコマンド@kbd{M-x
top-level}は、すべてのレベルの再帰編集をabortして、即座にトップレベルのコマンドリーダーに戻ります。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。

  再帰編集の中で編集されるテキストは、トップレベルで編集しているテキストと同じである必要はありません。これは、何にたいしての再帰編集かに依存します。再帰編集を呼び出したコマンドが最初に別のバッファーを選択する場合、そのバッファーが再帰編集を行なうバッファーになります。どんな場合でも再帰編集中に、(バッファーを切り替えるキーがリバインドされていないかぎり)通常の方法でバッファーを切り替えることができます。再帰編集の中で、ファイルをvisitしたりその他のことを行ない、残りのすべての編集を行なうことも、おそらく可能です。しかしこれは、(スタックオーバーフローのような)驚くべき効果をもたらすことがあります。そのため必要なくなったときは、再帰編集をexitまたはabortすることを忘れないでください。

  一般的に、わたしたちはGNU Emacsでは再帰編集レベルを最小限にしようと努めています。これは、特定の順 ---
最内のレベルからトップレベルに向かって ---
で``戻る''ことをあなたに強いるからです。可能な場合は、異なる作業には別のバッファーを供し、それらを切り替えられるようにします。いくつかのコマンドは、元のメジャーモードに戻るコマンドを提供する、新しいメジャーモードに切り替えます。これらの試みは、あなたの選択にしたがい、まだ終了していないタスクにもどる、柔軟性を与えます。

@ignore
@c Apart from edt and viper, this is all obsolete.
@c (Can't believe we were saying ``most other editors'' into 2014!)
@c There seems no point having a node just for those, which both have
@c their own manuals.
@node Emulation
@section エミュレーション
@cindex emulating other editors
@cindex other editors
@cindex EDT
@cindex vi
@cindex WordStar

  GNU Emacs can be programmed to emulate (more or less) some other
editors.  Standard facilities can emulate these:

@table @asis
@item CRiSP/Brief (PC editor)
@findex crisp-mode
@vindex crisp-override-meta-x
@findex scroll-all-mode
@cindex CRiSP mode
@cindex Brief emulation
@cindex emulation of Brief
@cindex mode, CRiSP
@kbd{M-x crisp-mode}はCRiSP/Briefエディターをエミュレートするキーバインドを有効にします。変数@code{crisp-override-meta-x}をセットしない場合、@kbd{M-x}はEmacsの終了にリバインドされることに注意してください。CRiSPのscroll-all機能(すべてのウィンドウを一緒にスクロールする)をエミュレートするために、コマンド@kbd{M-x scroll-all-mode}を使用したり、変数@code{crisp-load-scroll-all}をセットすることもできます。@item EDT (DEC VMS editor)
@findex edt-emulation-on
@findex edt-emulation-off
@kbd{M-x edt-emulation-on}はEDTエミュレーションをオンにします。@kbd{M-x edt-emulation-off}で通常のコマンドバインディングに復元します。ほとんどのEDTエミュレーションコマンドはキーパッドキーで、標準のEmacsのキーバインディングのほとんどは有効です。EDTエミュレーションのリバインディングはグローバルキーマップにより行なわれるので、EDTエミュレーション中にバッファーを切り替えたりメジャーモードを変更しても問題はありません。@item TPU (DEC VMS editor)
@findex tpu-edt-on
@cindex TPU
@kbd{M-x tpu-edt-on}はEDTをエミュレートするTPUエディターのエミュレートをオンにします。@item vi (Berkeley editor)
@findex viper-mode
Viperはviにたいするエミュレーターです。これは複数レベルのエミュレーションを実装します。レベル1はvi自身とほぼ同じで、レベル5はシビアなエミュレーションからは外れるが、Emacsの能力による利点を生かせます。Viperを呼び出すには、@kbd{M-x viper-mode}とタイプします。これは使い方のガイドを表示して、エミュレーションのレベルを尋ねます。@inforef{Top, Viper, viper}.@item vi (another emulator)
@findex vi-mode
@kbd{M-x vi-mode}は、前に確立されたメジャーモードを置き換えるメジャーモードに入ります。``input''モードに入るすべての(実際のviでの)viコマンドは、かわりに前のメジャーモードに戻るようにプログラムされています。したがって、通常のEmacsはviの``input''モードになります。viエミュレーションはメジャーモードを通じて機能するので、エミュレーションの間にバッファーを切り替えると機能しません。先に通常のEmacsに戻るようにしてください。viエミュレーションを多用したい場合は、おそらく@code{vi-mode}コマンドにキーをバインドしたいと思うでしょう。@item vi (alternate emulator)
@findex vip-mode
@kbd{M-x vip-mode}は、@kbd{M-x vi-mode}モードより実際のviに似ている、別のviエミュレーターを呼び出します。このエミュレーターの``input''モードは、通常のEmacsから変更されているので、エミュレートされたviコマンドモードから@key{ESC}で戻ることができます。エミュレートされたviコマンドモードから通常のEmacsモードに戻るには、@kbd{C-z}とタイプします。このエミュレーションはメジャーモードを通じて機能しないので、エミュレーター内でさまざまな方法でバッファーを切り替えることが可能です。@code{vi-mode}モードとは異なり、挿入モードを終了しても終了しないので、@code{vip-mode}にキーを割り当てる必要はありません。@inforef{Top, VIP, vip}, for full information.

@item WordStar (old wordprocessor)
@findex wordstar-mode
@kbd{M-x wordstar-mode}はWordStarのようなキーバインドを提供するメジャーモードです。@end table
@end ignore


@node Hyperlinking
@section ハイパーリンクと操作機能

  以下のサブセクションでは、URLや、Emacsバッファーのテキスト内にある他の種類のリンクを扱う便利な機能を説明します。

@menu
* Browse-URL::               URLをフォローするには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。
@end menu

@node Browse-URL
@subsection URLのフォロー
@cindex World Wide Web
@cindex Web
@findex browse-url
@findex browse-url-at-point
@findex browse-url-at-mouse
@cindex Browse-URL
@cindex URLs

@table @kbd
@item M-x browse-url @key{RET} @var{url} @key{RET}
ウェブブラウザーへのURLのロード。
@end table

  Browse-URLパッケージは、Emacsで簡単にURLをフォロー(辿る)することを可能にします。ほとんどのURLは、ウェブブラウザーを呼び出すことによりフォローされます。@samp{mailto:}のURLは、指定されたアドレスにメールを送るために、Emacsコマンドの@code{compose-mail}でフォローされます。

  コマンド@kbd{M-x
browse-url}は、URLの入力を求め、それをフォローします。ポイントがURLのようなテキストの近くにある場合、そのURLがデフォルトとして提示されます。Browse-URLパッケージは、@code{browse-url-at-point}や@code{browse-url-at-mouse}のような、キーにバインドしたいと思うような、他のコマンドも提供します。

@vindex browse-url-mailto-function
@vindex browse-url-browser-function
  Customizeグループ@code{browse-url}の、さまざまなオプションを通じて、Browse-URLの振る舞いをカスタマイズできます。特に、オプション@code{browse-url-mailto-function}では@samp{mailto:}のURL、@code{browse-url-browser-function}ではそれ以外のタイプのURLにたいして、どのような方法でフォローするか定義することができます。詳細は、@kbd{C-h
P browse-url @key{RET}}とタイプすることにより表示される、パッケージのコメントを参照してください。

@node Goto Address mode
@subsection URLのアクティブ化
@findex goto-address-mode
@cindex mode, Goto Address
@cindex Goto Address mode
@cindex URLs, activating

@table @kbd
@item M-x goto-address-mode
カレントバッファーのURLとメールアドレスをアクティブにします。
@end table

@kindex C-c RET @r{(Goto Address mode)}
@findex goto-address-at-point
  @kbd{M-x
goto-address-mode}とタイプすることにより、EmacsにカレントバッファーのURLを特別にマークさせることができます。このバッファーローカルなマイナーモードが有効な場合、バッファーのすべてのURLを探して、それらをハイライトするとともに、クリックできるボタンに変更します。そのようなテキストの上にポイントを移動して@kbd{C-c
@key{RET}}
(@code{goto-address-at-point})とタイプするか、@kbd{Mouse-2}をクリック、または@kbd{Mouse-1}を素早くクリックすることにより(@ref{Mouse
References}を参照してください)、そのURLをフォローできます。URLのフォローは、@code{browse-url}をサブルーチンとして呼び出すことにより行なわれます(@ref{Browse-URL}を参照してください)。

  モードフックや受信メッセージを表示するフック(たとえばRmailの@code{rmail-show-message-hook}や、MH-Eの@code{mh-show-mode-hook})に@code{goto-address-mode}を追加するのは便利かもしれません。Gnusには類似の機能があるので必要ありません。

@node FFAP
@subsection ポイント位置のファイルやURLを開く
@findex find-file-at-point
@findex ffap
@findex dired-at-point
@findex ffap-next
@findex ffap-menu
@cindex finding file at point

  FFAPパッケージは、@kbd{C-x
C-f}のようなファイルを探すためのキーにバインドされているコマンドを、よりセンシティブなデフォルトを提供するコマンドに置き換えます。これらのコマンドにプレフィクス引数を与えたときは、通常のコマンドと同様に振る舞います。それ以外の場合、ポイント周辺のテキストからデフォルトのファイル名を取得します。バッファーから見つかったのがファイル名ではなくURLの場合、このコマンドはそれを閲覧するために@code{browse-url}を使用します(@ref{Browse-URL}を参照してください)。

  この機能は、メールバッファーやニュースバッファー内の参照、@file{README}ファイル、@file{MANIFEST}ファイルなどをフォローするのに便利です。詳細については、@kbd{C-h
P ffap @key{RET}}とタイプして、パッケージのコメントを参照してください。

@cindex FFAP minor mode
@findex ffap-mode
  FFAPを有効にするには、@kbd{M-x
ffap-bindings}とタイプします。これにより、以下のキーバインドが作成され、Rmail、Gnus、VMアーティクルバッファーでの、追加FFAP機能にたいするフックもインストールされます。

@table @kbd
@item C-x C-f @var{filename} @key{RET}
@kindex C-x C-f @r{(FFAP)}
@var{filename}を検索します(@code{find-file-at-point})。デフォルトのファイル名は、ポイント周辺のテキストから推測します。
@item C-x C-r
@kindex C-x C-r @r{(FFAP)}
@code{ffap-read-only}。@code{find-file-read-only}に相当します。
@item C-x C-v
@kindex C-x C-v @r{(FFAP)}
@code{ffap-alternate-file}。@code{find-alternate-file}に相当します。
@item C-x d @var{directory} @key{RET}
@kindex C-x d @r{(FFAP)}
ポイント位置のディレクトリー名をデフォルトとして、@var{directory}でDiredを開始します(@code{dired-at-point})。
@item C-x C-d
@code{ffap-list-directory}。@code{list-directory}に相当します。
@item C-x 4 f
@kindex C-x 4 f @r{(FFAP)}
@code{ffap-other-window}。@code{find-file-other-window}に相当します。
@item C-x 4 r
@code{ffap-read-only-other-window}。@code{find-file-read-only-other-window}に相当します。
@item C-x 4 d
@code{ffap-dired-other-window}。@code{dired-other-window}と同様です。
@item C-x 5 f
@kindex C-x 5 f @r{(FFAP)}
@code{ffap-other-frame}。@code{find-file-other-frame}に相当します。
@item C-x 5 r
@code{ffap-read-only-other-frame}。@code{find-file-read-only-other-frame}に相当します。
@item C-x 5 d
@code{ffap-dired-other-frame}。@code{dired-other-frame}に相当します。
@item M-x ffap-next
バッファーから次のファイル名またはURLを検索して、そのファイルまたはURLを開きます。
@item S-Mouse-3
@kindex S-Mouse-3 @r{(FFAP)}
@code{ffap-at-mouse}は、マウスがクリックされた周辺のテキストから推測されたファイルを開きます。
@item C-S-Mouse-3
@kindex C-S-Mouse-3 @r{(FFAP)}
カレントバッファーに記述されたファイルとURLのメニューを表示して、選択されたものを開きます(@code{ffap-menu})。
@end table

@node Amusements
@section その他の娯楽
@cindex boredom

@findex animate-birthday-present
@cindex animate
  @code{animate}パッケージは、テキストをダンスさせます(たとえば@kbd{M-x animate-birthday-present})。

@findex blackbox
@findex mpuz
@findex 5x5
@cindex puzzles
  @kbd{M-x blackbox}、@kbd{M-x mpuz}、@kbd{M-x
5x5}はパズルです。@code{blackbox}はボックス内のボールの位置を、トモグラフィー(断層撮影)により当てるパズルです。@code{mpuz}は掛け算パズルを表示します。掛け算の中の英字が何の数字かを当てなければなりません。数字を入力するには、英字をタイプしてから、その数字をタイプします。@code{5x5}の目標は、すべてのマスを埋めることです。

@findex bubbles
  @kbd{M-x bubbles}は、より少ない回数の移動で、多くのbubble(シャボン玉)を取り除くゲームです。

@findex decipher
@cindex ciphers
@cindex cryptanalysis
  @kbd{M-x decipher}は、単純なアルファベット置換で暗号化されたバッファーを解読するのに役立ちます。

@findex dissociated-press
  @kbd{M-x
dissociated-press}は、Emacsのカレントバッファーのテキストをスクランブルします。スクランブルは単語単位または文字単位で行なわれ、@file{*Dissociation*}という名前のバッファーに出力されます。正の引数は文字単位での操作を指定し、数にはオーバーラップする文字数を指定します。負の引数は単語単位での操作を指定し、数にはオーバーラップする単語数を指定します。Dissociated
Pressはマルコフ連鎖と酷似した結果を生成しますが、それとは独自のigオリジナルな創案です。手法としては、単語または文字の後ろにランダムにジャンプするマルコフ連鎖とは異なり、ランダムなジャンプの間にあるサンプルから、連続する複数の文字をコピーします。ユーザーに受け入れられ、正確でありたいなら、ドキュメントにはdissociwordsを使用しないでください。

@findex dunnet
  @kbd{M-x dunnet}は、テキストベースのアドベンチャーゲームを開始します。

@findex gomoku
@cindex Go Moku
  個人的な満足感を得たいなら、@kbd{M-x gomoku}に挑戦してみてください。これはあなたと五目並べゲームを対戦します。

@cindex tower of Hanoi
@findex hanoi
  少し退屈していたら@kbd{M-x
hanoi}に挑戦してみてください。かなり退屈しているなら、数引数を指定します。とてもとても退屈なら、引数9に挑戦してみましょう。さあ、座って眺めましょう。

@findex life
@cindex Life
  @kbd{M-x life}は、Conwayの``Life'' cellular automatonを実行します。

@findex landmark
@cindex landmark game
  @kbd{M-x
landmark}は比較的に非参加型なゲームを実行します。これは4方向からの一意な嗅覚の合図にもとづいて、中央のツリーを目指して操縦されるロボットです。

@findex morse-region
@findex unmorse-region
@findex nato-region
@cindex Morse code
@cindex --/---/.-./.../.
  @kbd{M-x morse-region}は、リージョンのテキストをモールス信号に変換し、@kbd{M-x
unmorse-region}で元に戻します。@kbd{M-x nato-region}は、リージョンのテキストをNATO発音記号(NATO
phonetic alphabet)に変換し、@kbd{M-x denato-region}で元に戻します。

@findex pong
@cindex Pong game
@findex tetris
@cindex Tetris
@findex snake
@cindex Snake
  @kbd{M-x pong}、@kbd{M-x snake}、@kbd{M-x tetris}は、有名なPong、Snake、Tetrisの実装です。

@findex solitaire
@cindex solitaire
  @kbd{M-x solitaire}はソリティアーゲームをプレーします。これはピンを他のピンを超えてジャンプさせるゲームです。

@findex zone
  @kbd{M-x zone}は、Emacsがアイドル時にプレーするゲームです。

@findex doctor
@cindex Eliza
  最後に、もし不満を感じているときは、有名な精神分析医のElizaに問題の説明を試みてください。これは@kbd{M-x
doctor}とタイプするだけです。各入力の最後には、@key{RET}を2回タイプしてください。

@ifnottex
@lowersections
@end ifnottex
