# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-06-25 01:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: node
#: killing.texi.orig:6
#, no-wrap
msgid "Killing"
msgstr ""

#. type: chapter
#: killing.texi.orig:7
#, no-wrap
msgid "Killing and Moving Text"
msgstr ""

#. type: Plain text
#: killing.texi.orig:15
msgid ""
"In Emacs, @dfn{killing} means erasing text and copying it into the @dfn{kill "
"ring}.  @dfn{Yanking} means bringing text from the kill ring back into the "
"buffer.  (Some applications use the terms ``cutting'' and ``pasting'' for "
"similar operations.)  The kill ring is so-named because it can be visualized "
"as a set of blocks of text arranged in a ring, which you can access in "
"cyclic order.  @xref{Kill Ring}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:19
msgid ""
"Killing and yanking are the most common way to move or copy text within "
"Emacs.  It is very versatile, because there are commands for killing many "
"different types of syntactic units."
msgstr ""

#. type: section
#: killing.texi.orig:27 killing.texi.orig:29 killing.texi.orig:30
#, no-wrap
msgid "Deletion and Killing"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Commands that remove text."
msgstr ""

#. type: section
#: killing.texi.orig:27 killing.texi.orig:270 killing.texi.orig:271
#, no-wrap
msgid "Yanking"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Commands that insert text."
msgstr ""

#. type: node
#: killing.texi.orig:27 killing.texi.orig:447
#, no-wrap
msgid "Cut and Paste"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Clipboard and selections on graphical displays."
msgstr ""

#. type: section
#: killing.texi.orig:27 killing.texi.orig:631 killing.texi.orig:632
#, no-wrap
msgid "Accumulating Text"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Other methods to add text to the buffer."
msgstr ""

#. type: section
#: killing.texi.orig:27 killing.texi.orig:702 killing.texi.orig:703
#, no-wrap
msgid "Rectangles"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Operating on text in rectangular areas."
msgstr ""

#. type: section
#: killing.texi.orig:27 killing.texi.orig:856 killing.texi.orig:857
#, no-wrap
msgid "CUA Bindings"
msgstr ""

#. type: menuentry
#: killing.texi.orig:27
msgid "Using @kbd{C-x}/@kbd{C-c}/@kbd{C-v} to kill and yank."
msgstr ""

#. type: cindex
#: killing.texi.orig:32
#, no-wrap
msgid "killing text"
msgstr ""

#. type: cindex
#: killing.texi.orig:33
#, no-wrap
msgid "cutting text"
msgstr ""

#. type: cindex
#: killing.texi.orig:34
#, no-wrap
msgid "deletion"
msgstr ""

#. type: Plain text
#: killing.texi.orig:43
msgid ""
"Most commands which erase text from the buffer save it in the kill ring.  "
"These are known as @dfn{kill} commands, and their names normally contain the "
"word @samp{kill} (e.g., @code{kill-line}).  The kill ring stores several "
"recent kills, not just the last one, so killing is a very safe operation: "
"you don't have to worry much about losing text that you previously killed.  "
"The kill ring is shared by all buffers, so text that is killed in one buffer "
"can be yanked into another buffer."
msgstr ""

#. type: Plain text
#: killing.texi.orig:47
msgid ""
"When you use @kbd{C-/} (@code{undo}) to undo a kill command (@pxref{Undo}), "
"that brings the killed text back into the buffer, but does not remove it "
"from the kill ring."
msgstr ""

#. type: Plain text
#: killing.texi.orig:50
msgid ""
"On graphical displays, killing text also copies it to the system clipboard.  "
"@xref{Cut and Paste}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:58
msgid ""
"Commands that erase text but do not save it in the kill ring are known as "
"@dfn{delete} commands; their names usually contain the word @samp{delete}.  "
"These include @kbd{C-d} (@code{delete-char}) and @key{DEL} "
"(@code{delete-backward-char}), which delete only one character at a time, "
"and those commands that delete only spaces or newlines.  Commands that can "
"erase significant amounts of nontrivial data generally do a kill operation "
"instead."
msgstr ""

#. type: Plain text
#: killing.texi.orig:60
msgid "You can also use the mouse to kill and yank.  @xref{Cut and Paste}."
msgstr ""

#. type: subsection
#: killing.texi.orig:68 killing.texi.orig:70 killing.texi.orig:71
#, no-wrap
msgid "Deletion"
msgstr ""

#. type: menuentry
#: killing.texi.orig:68
msgid "Commands for deleting small amounts of text and blank areas."
msgstr ""

#. type: subsection
#: killing.texi.orig:68 killing.texi.orig:153 killing.texi.orig:154
#, no-wrap
msgid "Killing by Lines"
msgstr ""

#. type: menuentry
#: killing.texi.orig:68
msgid "How to kill entire lines of text at one time."
msgstr ""

#. type: subsection
#: killing.texi.orig:68 killing.texi.orig:201 killing.texi.orig:202
#, no-wrap
msgid "Other Kill Commands"
msgstr ""

#. type: menuentry
#: killing.texi.orig:68
msgid ""
"Commands to kill large regions of text and syntactic units such as words and "
"sentences."
msgstr ""

#. type: node
#: killing.texi.orig:68 killing.texi.orig:251
#, no-wrap
msgid "Kill Options"
msgstr ""

#. type: menuentry
#: killing.texi.orig:68
msgid "Options that affect killing."
msgstr ""

#. type: findex
#: killing.texi.orig:72
#, no-wrap
msgid "delete-backward-char"
msgstr ""

#. type: findex
#: killing.texi.orig:73
#, no-wrap
msgid "delete-char"
msgstr ""

#. type: Plain text
#: killing.texi.orig:78
msgid ""
"Deletion means erasing text and not saving it in the kill ring.  For the "
"most part, the Emacs commands that delete text are those that erase just one "
"character or only whitespace."
msgstr ""

#. type: key{#1}
#: killing.texi.orig:80
#, no-wrap
msgid "DEL"
msgstr ""

#. type: key{#1}
#: killing.texi.orig:81
#, no-wrap
msgid "BACKSPACE"
msgstr ""

#. type: table
#: killing.texi.orig:84
msgid ""
"Delete the previous character, or the text in the region if it is active "
"(@code{delete-backward-char})."
msgstr ""

#. type: key{#1}
#: killing.texi.orig:85
#, no-wrap
msgid "Delete"
msgstr ""

#. type: table
#: killing.texi.orig:88
msgid ""
"Delete the next character, or the text in the region if it is active "
"(@code{delete-forward-char})."
msgstr ""

#. type: item
#: killing.texi.orig:89
#, no-wrap
msgid "C-d"
msgstr ""

#. type: table
#: killing.texi.orig:91
msgid "Delete the next character (@code{delete-char})."
msgstr ""

#. type: kindex
#: killing.texi.orig:92 killing.texi.orig:112
#, no-wrap
msgid "M-\\"
msgstr ""

#. type: table
#: killing.texi.orig:94
msgid "Delete spaces and tabs around point (@code{delete-horizontal-space})."
msgstr ""

#. type: item
#: killing.texi.orig:94
#, no-wrap
msgid "M-@key{SPC}"
msgstr ""

#. type: table
#: killing.texi.orig:97
msgid ""
"Delete spaces and tabs around point, leaving one space "
"(@code{just-one-space})."
msgstr ""

#. type: item
#: killing.texi.orig:97
#, no-wrap
msgid "C-x C-o"
msgstr ""

#. type: table
#: killing.texi.orig:99
msgid "Delete blank lines around the current line (@code{delete-blank-lines})."
msgstr ""

#. type: item
#: killing.texi.orig:99
#, no-wrap
msgid "M-^"
msgstr ""

#. type: table
#: killing.texi.orig:102
msgid ""
"Join two lines by deleting the intervening newline, along with any "
"indentation following it (@code{delete-indentation})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:111
msgid ""
"We have already described the basic deletion commands @key{DEL} "
"(@code{delete-backward-char}), @key{delete} (@code{delete-forward-char}), "
"and @kbd{C-d} (@code{delete-char}).  @xref{Erasing}.  With a numeric "
"argument, they delete the specified number of characters.  If the numeric "
"argument is omitted or one, they delete all the text in the region if it is "
"active (@pxref{Using Region})."
msgstr ""

#. type: findex
#: killing.texi.orig:113
#, no-wrap
msgid "delete-horizontal-space"
msgstr ""

#. type: kindex
#: killing.texi.orig:114
#, no-wrap
msgid "M-SPC"
msgstr ""

#. type: findex
#: killing.texi.orig:115
#, no-wrap
msgid "just-one-space"
msgstr ""

#. type: findex
#: killing.texi.orig:116
#, no-wrap
msgid "cycle-spacing"
msgstr ""

#. type: Plain text
#: killing.texi.orig:132
msgid ""
"The other delete commands are those that delete only whitespace characters: "
"spaces, tabs and newlines.  @kbd{M-\\} (@code{delete-horizontal-space}) "
"deletes all the spaces and tab characters before and after point.  With a "
"prefix argument, this only deletes spaces and tab characters before point.  "
"@kbd{M-@key{SPC}} (@code{just-one-space}) does likewise but leaves a single "
"space before point, regardless of the number of spaces that existed "
"previously (even if there were none before).  With a numeric argument "
"@var{n}, it leaves @var{n} spaces before point if @var{n} is positive; if "
"@var{n} is negative, it deletes newlines in addition to spaces and tabs, "
"leaving @var{-n} spaces before point.  The command @code{cycle-spacing} acts "
"like a more flexible version of @code{just-one-space}.  It does different "
"things if you call it repeatedly in succession.  The first call acts like "
"@code{just-one-space}, the next removes all whitespace, and a third call "
"restores the original whitespace."
msgstr ""

#. type: Plain text
#: killing.texi.orig:137
msgid ""
"@kbd{C-x C-o} (@code{delete-blank-lines}) deletes all blank lines after the "
"current line.  If the current line is blank, it deletes all blank lines "
"preceding the current line as well (leaving one blank line, the current "
"line).  On a solitary blank line, it deletes that line."
msgstr ""

#. type: Plain text
#: killing.texi.orig:141
msgid ""
"@kbd{M-^} (@code{delete-indentation}) joins the current line and the "
"previous line, by deleting a newline and all surrounding spaces, usually "
"leaving a single space.  @xref{Indentation,M-^}."
msgstr ""

#. type: findex
#: killing.texi.orig:143
#, no-wrap
msgid "delete-duplicate-lines"
msgstr ""

#. type: Plain text
#: killing.texi.orig:152
msgid ""
"The command @code{delete-duplicate-lines} searches the region for identical "
"lines, and removes all but one copy of each.  Normally it keeps the first "
"instance of each repeated line, but with a @kbd{C-u} prefix argument it "
"keeps the last.  With a @kbd{C-u C-u} prefix argument, it only searches for "
"adjacent identical lines.  This is a more efficient mode of operation, "
"useful when the lines have already been sorted.  With a @kbd{C-u C-u C-u} "
"prefix argument, it retains repeated blank lines."
msgstr ""

#. type: kindex
#: killing.texi.orig:157 killing.texi.orig:163
#, no-wrap
msgid "C-k"
msgstr ""

#. type: table
#: killing.texi.orig:159
msgid "Kill rest of line or one or more lines (@code{kill-line})."
msgstr ""

#. type: kindex
#: killing.texi.orig:159 killing.texi.orig:194
#, no-wrap
msgid "C-S-backspace"
msgstr ""

#. type: table
#: killing.texi.orig:161
msgid "Kill an entire line at once (@code{kill-whole-line})"
msgstr ""

#. type: findex
#: killing.texi.orig:164
#, no-wrap
msgid "kill-line"
msgstr ""

#. type: Plain text
#: killing.texi.orig:171
msgid ""
"The simplest kill command is @kbd{C-k} (@code{kill-line}).  If used at the "
"end of a line, it kills the line-ending newline character, merging the next "
"line into the current one (thus, a blank line is entirely removed).  "
"Otherwise, @kbd{C-k} kills all the text from point up to the end of the "
"line; if point was originally at the beginning of the line, this leaves the "
"line blank."
msgstr ""

#. type: Plain text
#: killing.texi.orig:177
msgid ""
"Spaces and tabs at the end of the line are ignored when deciding which case "
"applies.  As long as point is after the last visible character in the line, "
"you can be sure that @kbd{C-k} will kill the newline.  To kill an entire "
"non-blank line, go to the beginning and type @kbd{C-k} twice."
msgstr ""

#. type: Plain text
#: killing.texi.orig:180
msgid ""
"In this context, ``line'' means a logical text line, not a screen line "
"(@pxref{Continuation Lines})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:188
msgid ""
"When @kbd{C-k} is given a positive argument @var{n}, it kills @var{n} lines "
"and the newlines that follow them (text on the current line before point is "
"not killed).  With a negative argument @minus{}@var{n}, it kills @var{n} "
"lines preceding the current line, together with the text on the current line "
"before point.  @kbd{C-k} with an argument of zero kills the text before "
"point on the current line."
msgstr ""

#. type: findex
#: killing.texi.orig:189 killing.texi.orig:195
#, no-wrap
msgid "kill-whole-line"
msgstr ""

#. type: Plain text
#: killing.texi.orig:193
msgid ""
"If the variable @code{kill-whole-line} is non-@code{nil}, @kbd{C-k} at the "
"very beginning of a line kills the entire line including the following "
"newline.  This variable is normally @code{nil}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:200
msgid ""
"@kbd{C-S-backspace} (@code{kill-whole-line}) kills a whole line including "
"its newline, regardless of the position of point within the line.  Note that "
"many text terminals will prevent you from typing the key sequence "
"@kbd{C-S-backspace}."
msgstr ""

#. type: findex
#: killing.texi.orig:203 killing.texi.orig:227
#, no-wrap
msgid "kill-region"
msgstr ""

#. type: kindex
#: killing.texi.orig:204 killing.texi.orig:207 killing.texi.orig:226
#, no-wrap
msgid "C-w"
msgstr ""

#. type: table
#: killing.texi.orig:209
msgid "Kill the region (@code{kill-region})."
msgstr ""

#. type: kindex
#: killing.texi.orig:209 killing.texi.orig:228
#, no-wrap
msgid "M-w"
msgstr ""

#. type: table
#: killing.texi.orig:211
msgid "Copy the region into the kill ring (@code{kill-ring-save})."
msgstr ""

#. type: item
#: killing.texi.orig:211
#, no-wrap
msgid "M-d"
msgstr ""

#. type: table
#: killing.texi.orig:213
msgid "Kill the next word (@code{kill-word}).  @xref{Words}."
msgstr ""

#. type: item
#: killing.texi.orig:213
#, no-wrap
msgid "M-@key{DEL}"
msgstr ""

#. type: table
#: killing.texi.orig:215
msgid "Kill one word backwards (@code{backward-kill-word})."
msgstr ""

#. type: item
#: killing.texi.orig:215
#, no-wrap
msgid "C-x @key{DEL}"
msgstr ""

#. type: table
#: killing.texi.orig:218
msgid ""
"Kill back to beginning of sentence (@code{backward-kill-sentence}).  "
"@xref{Sentences}."
msgstr ""

#. type: item
#: killing.texi.orig:218
#, no-wrap
msgid "M-k"
msgstr ""

#. type: table
#: killing.texi.orig:220
msgid "Kill to the end of the sentence (@code{kill-sentence})."
msgstr ""

#. type: item
#: killing.texi.orig:220
#, no-wrap
msgid "C-M-k"
msgstr ""

#. type: table
#: killing.texi.orig:222
msgid ""
"Kill the following balanced expression (@code{kill-sexp}).  "
"@xref{Expressions}."
msgstr ""

#. type: item
#: killing.texi.orig:222
#, no-wrap
msgid "M-z @var{char}"
msgstr ""

#. type: table
#: killing.texi.orig:224
msgid "Kill through the next occurrence of @var{char} (@code{zap-to-char})."
msgstr ""

#. type: findex
#: killing.texi.orig:229
#, no-wrap
msgid "kill-ring-save"
msgstr ""

#. type: Plain text
#: killing.texi.orig:237
msgid ""
"One of the commonly-used kill commands is @kbd{C-w} (@code{kill-region}), "
"which kills the text in the region (@pxref{Mark}).  Similarly, @kbd{M-w} "
"(@code{kill-ring-save}) copies the text in the region into the kill ring "
"without removing it from the buffer.  If the mark is inactive when you type "
"@kbd{C-w} or @kbd{M-w}, the command acts on the text between point and where "
"you last set the mark (@pxref{Using Region})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:242
msgid ""
"Emacs also provides commands to kill specific syntactic units: words, with "
"@kbd{M-@key{DEL}} and @kbd{M-d} (@pxref{Words}); balanced expressions, with "
"@kbd{C-M-k} (@pxref{Expressions}); and sentences, with @kbd{C-x @key{DEL}} "
"and @kbd{M-k} (@pxref{Sentences})."
msgstr ""

#. type: kindex
#: killing.texi.orig:243
#, no-wrap
msgid "M-z"
msgstr ""

#. type: findex
#: killing.texi.orig:244
#, no-wrap
msgid "zap-to-char"
msgstr ""

#. type: Plain text
#: killing.texi.orig:250
msgid ""
"The command @kbd{M-z} (@code{zap-to-char}) combines killing with searching: "
"it reads a character and kills from point up to (and including) the next "
"occurrence of that character in the buffer.  A numeric argument acts as a "
"repeat count; a negative argument means to search backward and kill text "
"before point."
msgstr ""

#. type: subsection
#: killing.texi.orig:252
#, no-wrap
msgid "Options for Killing"
msgstr ""

#. type: vindex
#: killing.texi.orig:254
#, no-wrap
msgid "kill-read-only-ok"
msgstr ""

#. type: cindex
#: killing.texi.orig:255
#, no-wrap
msgid "read-only text, killing"
msgstr ""

#. type: Plain text
#: killing.texi.orig:264
msgid ""
"Some specialized buffers contain @dfn{read-only text}, which cannot be "
"modified and therefore cannot be killed.  The kill commands work specially "
"in a read-only buffer: they move over text and copy it to the kill ring, "
"without actually deleting it from the buffer.  Normally, they also beep and "
"display an error message when this happens.  But if you set the variable "
"@code{kill-read-only-ok} to a non-@code{nil} value, they just print a "
"message in the echo area to explain why the text has not been erased."
msgstr ""

#. type: vindex
#: killing.texi.orig:265
#, no-wrap
msgid "kill-do-not-save-duplicates"
msgstr ""

#. type: Plain text
#: killing.texi.orig:269
msgid ""
"If you change the variable @code{kill-do-not-save-duplicates} to a "
"non-@code{nil} value, identical subsequent kills yield a single kill-ring "
"entry, without duplication."
msgstr ""

#. type: cindex
#: killing.texi.orig:272
#, no-wrap
msgid "moving text"
msgstr ""

#. type: cindex
#: killing.texi.orig:273
#, no-wrap
msgid "copying text"
msgstr ""

#. type: cindex
#: killing.texi.orig:274
#, no-wrap
msgid "kill ring"
msgstr ""

#. type: cindex
#: killing.texi.orig:275
#, no-wrap
msgid "yanking"
msgstr ""

#. type: cindex
#: killing.texi.orig:276
#, no-wrap
msgid "pasting"
msgstr ""

#. type: Plain text
#: killing.texi.orig:280
msgid ""
"@dfn{Yanking} means reinserting text previously killed.  The usual way to "
"move or copy text is to kill it and then yank it elsewhere."
msgstr ""

#. type: kindex
#: killing.texi.orig:282 killing.texi.orig:292
#, no-wrap
msgid "C-y"
msgstr ""

#. type: table
#: killing.texi.orig:284
msgid "Yank the last kill into the buffer, at point (@code{yank})."
msgstr ""

#. type: kindex
#: killing.texi.orig:284 killing.texi.orig:352
#, no-wrap
msgid "M-y"
msgstr ""

#. type: table
#: killing.texi.orig:287
msgid ""
"Replace the text just yanked with an earlier batch of killed text "
"(@code{yank-pop}).  @xref{Earlier Kills}."
msgstr ""

#. type: kindex
#: killing.texi.orig:287 killing.texi.orig:431
#, no-wrap
msgid "C-M-w"
msgstr ""

#. type: table
#: killing.texi.orig:290
msgid ""
"Cause the following command, if it is a kill command, to append to the "
"previous kill (@code{append-next-kill}).  @xref{Appending Kills}."
msgstr ""

#. type: findex
#: killing.texi.orig:293
#, no-wrap
msgid "yank"
msgstr ""

#. type: Plain text
#: killing.texi.orig:299
msgid ""
"The basic yanking command is @kbd{C-y} (@code{yank}).  It inserts the most "
"recent kill, leaving the cursor at the end of the inserted text.  It also "
"sets the mark at the beginning of the inserted text, without activating the "
"mark; this lets you jump easily to that position, if you wish, with @kbd{C-u "
"C-@key{SPC}} (@pxref{Mark Ring})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:305
msgid ""
"With a plain prefix argument (@kbd{C-u C-y}), the command instead leaves the "
"cursor in front of the inserted text, and sets the mark at the end.  Using "
"any other prefix argument specifies an earlier kill; e.g., @kbd{C-u 4 C-y} "
"reinserts the fourth most recent kill.  @xref{Earlier Kills}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:313
msgid ""
"On graphical displays, @kbd{C-y} first checks if another application has "
"placed any text in the system clipboard more recently than the last Emacs "
"kill.  If so, it inserts the clipboard's text instead.  Thus, Emacs "
"effectively treats ``cut'' or ``copy'' clipboard operations performed in "
"other applications like Emacs kills, except that they are not recorded in "
"the kill ring.  @xref{Cut and Paste}, for details."
msgstr ""

#. type: node
#: killing.texi.orig:318 killing.texi.orig:320
#, no-wrap
msgid "Kill Ring"
msgstr ""

#. type: menuentry
#: killing.texi.orig:318
msgid "Where killed text is stored."
msgstr ""

#. type: node
#: killing.texi.orig:318 killing.texi.orig:342
#, no-wrap
msgid "Earlier Kills"
msgstr ""

#. type: menuentry
#: killing.texi.orig:318
msgid "Yanking something killed some time ago."
msgstr ""

#. type: subsection
#: killing.texi.orig:318 killing.texi.orig:390 killing.texi.orig:391
#, no-wrap
msgid "Appending Kills"
msgstr ""

#. type: menuentry
#: killing.texi.orig:318
msgid "Several kills in a row all yank together."
msgstr ""

#. type: subsection
#: killing.texi.orig:321
#, no-wrap
msgid "The Kill Ring"
msgstr ""

#. type: Plain text
#: killing.texi.orig:330
msgid ""
"The @dfn{kill ring} is a list of blocks of text that were previously "
"killed.  There is only one kill ring, shared by all buffers, so you can kill "
"text in one buffer and yank it in another buffer.  This is the usual way to "
"move text from one buffer to another.  (There are several other methods: for "
"instance, you could store the text in a register; see @ref{Registers}.  "
"@xref{Accumulating Text}, for some other ways to move text around.)"
msgstr ""

#. type: vindex
#: killing.texi.orig:331
#, no-wrap
msgid "kill-ring-max"
msgstr ""

#. type: Plain text
#: killing.texi.orig:336
msgid ""
"The maximum number of entries in the kill ring is controlled by the variable "
"@code{kill-ring-max}.  The default is 60.  If you make a new kill when this "
"limit has been reached, Emacs makes room by deleting the oldest entry in the "
"kill ring."
msgstr ""

#. type: vindex
#: killing.texi.orig:337
#, no-wrap
msgid "kill-ring"
msgstr ""

#. type: Plain text
#: killing.texi.orig:341
msgid ""
"The actual contents of the kill ring are stored in a variable named "
"@code{kill-ring}; you can view the entire contents of the kill ring with "
"@kbd{C-h v kill-ring}."
msgstr ""

#. type: subsection
#: killing.texi.orig:343
#, no-wrap
msgid "Yanking Earlier Kills"
msgstr ""

#. type: cindex
#: killing.texi.orig:344
#, no-wrap
msgid "yanking previous kills"
msgstr ""

#. type: Plain text
#: killing.texi.orig:351
msgid ""
"As explained in @ref{Yanking}, you can use a numeric argument to @kbd{C-y} "
"to yank text that is no longer the most recent kill.  This is useful if you "
"remember which kill ring entry you want.  If you don't, you can use the "
"@kbd{M-y} (@code{yank-pop}) command to cycle through the possibilities."
msgstr ""

#. type: findex
#: killing.texi.orig:353
#, no-wrap
msgid "yank-pop"
msgstr ""

#. type: Plain text
#: killing.texi.orig:360
msgid ""
"If the previous command was a yank command, @kbd{M-y} takes the text that "
"was yanked and replaces it with the text from an earlier kill.  So, to "
"recover the text of the next-to-the-last kill, first use @kbd{C-y} to yank "
"the last kill, and then use @kbd{M-y} to replace it with the previous kill.  "
"@kbd{M-y} is allowed only after a @kbd{C-y} or another @kbd{M-y}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:370
msgid ""
"You can understand @kbd{M-y} in terms of a ``last yank'' pointer which "
"points at an entry in the kill ring.  Each time you kill, the ``last yank'' "
"pointer moves to the newly made entry at the front of the ring.  @kbd{C-y} "
"yanks the entry which the ``last yank'' pointer points to.  @kbd{M-y} moves "
"the ``last yank'' pointer to a different entry, and the text in the buffer "
"changes to match.  Enough @kbd{M-y} commands can move the pointer to any "
"entry in the ring, so you can get any entry into the buffer.  Eventually the "
"pointer reaches the end of the ring; the next @kbd{M-y} loops back around to "
"the first entry again."
msgstr ""

#. type: Plain text
#: killing.texi.orig:374
msgid ""
"@kbd{M-y} moves the ``last yank'' pointer around the ring, but it does not "
"change the order of the entries in the ring, which always runs from the most "
"recent kill at the front to the oldest one still remembered."
msgstr ""

#. type: Plain text
#: killing.texi.orig:379
msgid ""
"@kbd{M-y} can take a numeric argument, which tells it how many entries to "
"advance the ``last yank'' pointer by.  A negative argument moves the pointer "
"toward the front of the ring; from the front of the ring, it moves "
"``around'' to the last entry and continues forward from there."
msgstr ""

#. type: Plain text
#: killing.texi.orig:386
msgid ""
"Once the text you are looking for is brought into the buffer, you can stop "
"doing @kbd{M-y} commands and it will stay there.  It's just a copy of the "
"kill ring entry, so editing it in the buffer does not change what's in the "
"ring.  As long as no new killing is done, the ``last yank'' pointer remains "
"at the same place in the kill ring, so repeating @kbd{C-y} will yank another "
"copy of the same previous kill."
msgstr ""

#. type: Plain text
#: killing.texi.orig:389
msgid ""
"When you call @kbd{C-y} with a numeric argument, that also sets the ``last "
"yank'' pointer to the entry that it yanks."
msgstr ""

#. type: cindex
#: killing.texi.orig:393
#, no-wrap
msgid "appending kills in the ring"
msgstr ""

#. type: Plain text
#: killing.texi.orig:398
msgid ""
"Normally, each kill command pushes a new entry onto the kill ring.  However, "
"two or more kill commands in a row combine their text into a single entry, "
"so that a single @kbd{C-y} yanks all the text as a unit, just as it was "
"before it was killed."
msgstr ""

#. type: Plain text
#: killing.texi.orig:403
msgid ""
"Thus, if you want to yank text as a unit, you need not kill all of it with "
"one command; you can keep killing line after line, or word after word, until "
"you have killed it all, and you can still get it all back at once."
msgstr ""

#. type: Plain text
#: killing.texi.orig:410
msgid ""
"Commands that kill forward from point add onto the end of the previous "
"killed text.  Commands that kill backward from point add text onto the "
"beginning.  This way, any sequence of mixed forward and backward kill "
"commands puts all the killed text into one entry without rearrangement.  "
"Numeric arguments do not break the sequence of appending kills.  For "
"example, suppose the buffer contains this text:"
msgstr ""

#. type: example
#: killing.texi.orig:413
#, no-wrap
msgid "This is a line @point{}of sample text.\n"
msgstr ""

#. type: Plain text
#: killing.texi.orig:422
msgid ""
"with point shown by @point{}.  If you type @kbd{M-d M-@key{DEL} M-d "
"M-@key{DEL}}, killing alternately forward and backward, you end up with "
"@samp{a line of sample} as one entry in the kill ring, and @samp{This is@ @ "
"text.} in the buffer.  (Note the double space between @samp{is} and "
"@samp{text}, which you can clean up with @kbd{M-@key{SPC}} or @kbd{M-q}.)"
msgstr ""

#. type: Plain text
#: killing.texi.orig:430
msgid ""
"Another way to kill the same text is to move back two words with @kbd{M-b "
"M-b}, then kill all four words forward with @kbd{C-u M-d}.  This produces "
"exactly the same results in the buffer and in the kill ring.  @kbd{M-f M-f "
"C-u M-@key{DEL}} kills the same text, all going backward; once again, the "
"result is the same.  The text in the kill ring entry always has the same "
"order that it had in the buffer before you killed it."
msgstr ""

#. type: findex
#: killing.texi.orig:432
#, no-wrap
msgid "append-next-kill"
msgstr ""

#. type: Plain text
#: killing.texi.orig:443
msgid ""
"If a kill command is separated from the last kill command by other commands "
"(not just numeric arguments), it starts a new entry on the kill ring.  But "
"you can force it to combine with the last killed text, by typing @kbd{C-M-w} "
"(@code{append-next-kill}) right beforehand.  The @kbd{C-M-w} tells its "
"following command, if it is a kill command, to treat the kill as part of the "
"sequence of previous kills.  As usual, the kill is appended to the previous "
"killed text if the command kills forward, and prepended if the command kills "
"backward.  In this way, you can kill several separated pieces of text and "
"accumulate them to be yanked back in one place."
msgstr ""

#. type: Plain text
#: killing.texi.orig:446
msgid ""
"A kill command following @kbd{M-w} (@code{kill-ring-save}) does not append "
"to the text that @kbd{M-w} copied into the kill ring."
msgstr ""

#. type: section
#: killing.texi.orig:448
#, no-wrap
msgid "``Cut and Paste'' Operations on Graphical Displays"
msgstr ""

#. type: cindex
#: killing.texi.orig:449
#, no-wrap
msgid "cut"
msgstr ""

#. type: cindex
#: killing.texi.orig:450
#, no-wrap
msgid "copy"
msgstr ""

#. type: cindex
#: killing.texi.orig:451
#, no-wrap
msgid "paste"
msgstr ""

#. type: Plain text
#: killing.texi.orig:460
msgid ""
"In most graphical desktop environments, you can transfer data (usually text) "
"between different applications using a system facility called the "
"@dfn{clipboard}.  On X, two other similar facilities are available: the "
"primary selection and the secondary selection.  When Emacs is run on a "
"graphical display, its kill and yank commands integrate with these "
"facilities, so that you can easily transfer text between Emacs and other "
"graphical applications."
msgstr ""

#. type: Plain text
#: killing.texi.orig:467
msgid ""
"By default, Emacs uses UTF-8 as the coding system for inter-program text "
"transfers.  If you find that the pasted text is not what you expected, you "
"can specify another coding system by typing @kbd{C-x @key{RET} x} or "
"@kbd{C-x @key{RET} X}.  You can also request a different data type by "
"customizing @code{x-select-request-type}.  @xref{Communication Coding}."
msgstr ""

#. type: node
#: killing.texi.orig:472 killing.texi.orig:474
#, no-wrap
msgid "Clipboard"
msgstr ""

#. type: menuentry
#: killing.texi.orig:472
msgid "How Emacs uses the system clipboard."
msgstr ""

#. type: node
#: killing.texi.orig:472 killing.texi.orig:537
#, no-wrap
msgid "Primary Selection"
msgstr ""

#. type: menuentry
#: killing.texi.orig:472
msgid "The temporarily selected text selection."
msgstr ""

#. type: subsection
#: killing.texi.orig:472 killing.texi.orig:579 killing.texi.orig:580
#, no-wrap
msgid "Secondary Selection"
msgstr ""

#. type: menuentry
#: killing.texi.orig:472
msgid "Cutting without altering point and mark."
msgstr ""

#. type: subsection
#: killing.texi.orig:475
#, no-wrap
msgid "Using the Clipboard"
msgstr ""

#. type: cindex
#: killing.texi.orig:476
#, no-wrap
msgid "clipboard"
msgstr ""

#. type: Plain text
#: killing.texi.orig:481
msgid ""
"The @dfn{clipboard} is the facility that most graphical applications use for "
"``cutting and pasting''.  When the clipboard exists, the kill and yank "
"commands in Emacs make use of it."
msgstr ""

#. type: Plain text
#: killing.texi.orig:486
msgid ""
"When you kill some text with a command such as @kbd{C-w} "
"(@code{kill-region}), or copy it to the kill ring with a command such as "
"@kbd{M-w} (@code{kill-ring-save}), that text is also put in the clipboard."
msgstr ""

#. type: vindex
#: killing.texi.orig:487
#, no-wrap
msgid "save-interprogram-paste-before-kill"
msgstr ""

#. type: Plain text
#: killing.texi.orig:494
msgid ""
"When an Emacs kill command puts text in the clipboard, the existing "
"clipboard contents are normally lost.  Optionally, you can change "
"@code{save-interprogram-paste-before-kill} to @code{t}.  Then Emacs will "
"first save the clipboard to its kill ring, preventing you from losing the "
"old clipboard data---at the risk of high memory consumption if that data "
"turns out to be large."
msgstr ""

#. type: Plain text
#: killing.texi.orig:500
msgid ""
"Yank commands, such as @kbd{C-y} (@code{yank}), also use the clipboard.  If "
"another application ``owns'' the clipboard---i.e., if you cut or copied text "
"there more recently than your last kill command in Emacs---then Emacs yanks "
"from the clipboard instead of the kill ring."
msgstr ""

#. type: vindex
#: killing.texi.orig:501
#, no-wrap
msgid "yank-pop-change-selection"
msgstr ""

#. type: Plain text
#: killing.texi.orig:506
msgid ""
"Normally, rotating the kill ring with @kbd{M-y} (@code{yank-pop})  does not "
"alter the clipboard.  However, if you change "
"@code{yank-pop-change-selection} to @code{t}, then @kbd{M-y} saves the new "
"yank to the clipboard."
msgstr ""

#. type: vindex
#: killing.texi.orig:507
#, no-wrap
msgid "x-select-enable-clipboard"
msgstr ""

#. type: Plain text
#: killing.texi.orig:510
msgid ""
"To prevent kill and yank commands from accessing the clipboard, change the "
"variable @code{x-select-enable-clipboard} to @code{nil}."
msgstr ""

#. type: cindex
#: killing.texi.orig:511
#, no-wrap
msgid "clipboard manager"
msgstr ""

#. type: vindex
#: killing.texi.orig:512
#, no-wrap
msgid "x-select-enable-clipboard-manager"
msgstr ""

#. type: Plain text
#: killing.texi.orig:521
msgid ""
"Many X desktop environments support a feature called the @dfn{clipboard "
"manager}.  If you exit Emacs while it is the current ``owner'' of the "
"clipboard data, and there is a clipboard manager running, Emacs transfers "
"the clipboard data to the clipboard manager so that it is not lost.  In some "
"circumstances, this may cause a delay when exiting Emacs; if you wish to "
"prevent Emacs from transferring data to the clipboard manager, change the "
"variable @code{x-select-enable-clipboard-manager} to @code{nil}."
msgstr ""

#. type: vindex
#: killing.texi.orig:522
#, no-wrap
msgid "x-select-enable-primary"
msgstr ""

#. type: findex
#: killing.texi.orig:523
#, no-wrap
msgid "clipboard-kill-region"
msgstr ""

#. type: findex
#: killing.texi.orig:524
#, no-wrap
msgid "clipboard-kill-ring-save"
msgstr ""

#. type: findex
#: killing.texi.orig:525
#, no-wrap
msgid "clipboard-yank"
msgstr ""

#. type: Plain text
#: killing.texi.orig:536
msgid ""
"Prior to Emacs 24, the kill and yank commands used the primary selection "
"(@pxref{Primary Selection}), not the clipboard.  If you prefer this "
"behavior, change @code{x-select-enable-clipboard} to @code{nil}, "
"@code{x-select-enable-primary} to @code{t}, and "
"@code{mouse-drag-copy-region} to @code{t}.  In this case, you can use the "
"following commands to act explicitly on the clipboard: "
"@code{clipboard-kill-region} kills the region and saves it to the clipboard; "
"@code{clipboard-kill-ring-save} copies the region to the kill ring and saves "
"it to the clipboard; and @code{clipboard-yank} yanks the contents of the "
"clipboard at point."
msgstr ""

#. type: subsection
#: killing.texi.orig:538
#, no-wrap
msgid "Cut and Paste with Other Window Applications"
msgstr ""

#. type: cindex
#: killing.texi.orig:539
#, no-wrap
msgid "X cutting and pasting"
msgstr ""

#. type: cindex
#: killing.texi.orig:540
#, no-wrap
msgid "X selection"
msgstr ""

#. type: cindex
#: killing.texi.orig:541
#, no-wrap
msgid "primary selection"
msgstr ""

#. type: cindex
#: killing.texi.orig:542
#, no-wrap
msgid "selection, primary"
msgstr ""

#. type: Plain text
#: killing.texi.orig:552
msgid ""
"Under the X Window System, there exists a @dfn{primary selection} containing "
"the last stretch of text selected in an X application (usually by dragging "
"the mouse).  Typically, this text can be inserted into other X applications "
"by @kbd{mouse-2} clicks.  The primary selection is separate from the "
"clipboard.  Its contents are more ``fragile''; they are overwritten each "
"time you select text with the mouse, whereas the clipboard is only "
"overwritten by explicit ``cut'' or ``copy'' commands."
msgstr ""

#. type: Plain text
#: killing.texi.orig:558
msgid ""
"Under X, whenever the region is active (@pxref{Mark}), the text in the "
"region is saved in the primary selection.  This applies regardless of "
"whether the region was made by dragging or clicking the mouse (@pxref{Mouse "
"Commands}), or by keyboard commands (e.g., by typing @kbd{C-@key{SPC}} and "
"moving point; @pxref{Setting Mark})."
msgstr ""

#. type: vindex
#: killing.texi.orig:559
#, no-wrap
msgid "select-active-regions"
msgstr ""

#. type: Plain text
#: killing.texi.orig:566
msgid ""
"If you change the variable @code{select-active-regions} to @code{only}, "
"Emacs saves only temporarily active regions to the primary selection, i.e., "
"those made with the mouse or with shift selection (@pxref{Shift "
"Selection}).  If you change @code{select-active-regions} to @code{nil}, "
"Emacs avoids saving active regions to the primary selection entirely."
msgstr ""

#. type: Plain text
#: killing.texi.orig:570
msgid ""
"To insert the primary selection into an Emacs buffer, click @kbd{mouse-2} "
"(@code{mouse-yank-primary}) where you want to insert it.  @xref{Mouse "
"Commands}."
msgstr ""

#. type: cindex
#: killing.texi.orig:571
#, no-wrap
msgid "MS-Windows, and primary selection"
msgstr ""

#. type: Plain text
#: killing.texi.orig:578
msgid ""
"MS-Windows provides no primary selection, but Emacs emulates it within a "
"single Emacs session by storing the selected text internally.  Therefore, "
"all the features and commands related to the primary selection work on "
"Windows as they do on X, for cutting and pasting within the same session, "
"but not across Emacs sessions or with other applications."
msgstr ""

#. type: cindex
#: killing.texi.orig:581
#, no-wrap
msgid "secondary selection"
msgstr ""

#. type: Plain text
#: killing.texi.orig:587
msgid ""
"In addition to the primary selection, the X Window System provides a second "
"similar facility known as the @dfn{secondary selection}.  Nowadays, few X "
"applications make use of the secondary selection, but you can access it "
"using the following Emacs commands:"
msgstr ""

#. type: findex
#: killing.texi.orig:589
#, no-wrap
msgid "mouse-set-secondary"
msgstr ""

#. type: item
#: killing.texi.orig:590 killing.texi.orig:592
#, no-wrap
msgid "M-Drag-Mouse-1"
msgstr ""

#. type: cindex
#: killing.texi.orig:591
#, no-wrap
msgid "secondary-selection face"
msgstr ""

#. type: table
#: killing.texi.orig:599
msgid ""
"Set the secondary selection, with one end at the place where you press down "
"the button, and the other end at the place where you release it "
"(@code{mouse-set-secondary}).  The selected text is highlighted, using the "
"@code{secondary-selection} face, as you drag.  The window scrolls "
"automatically if you drag the mouse off the top or bottom of the window, "
"just like @code{mouse-set-region} (@pxref{Mouse Commands})."
msgstr ""

#. type: table
#: killing.texi.orig:601
msgid "This command does not alter the kill ring."
msgstr ""

#. type: findex
#: killing.texi.orig:602
#, no-wrap
msgid "mouse-start-secondary"
msgstr ""

#. type: item
#: killing.texi.orig:603 killing.texi.orig:604
#, no-wrap
msgid "M-Mouse-1"
msgstr ""

#. type: table
#: killing.texi.orig:607
msgid ""
"Set one endpoint for the @dfn{secondary selection} "
"(@code{mouse-start-secondary})."
msgstr ""

#. type: findex
#: killing.texi.orig:608
#, no-wrap
msgid "mouse-secondary-save-then-kill"
msgstr ""

#. type: item
#: killing.texi.orig:609 killing.texi.orig:610
#, no-wrap
msgid "M-Mouse-3"
msgstr ""

#. type: table
#: killing.texi.orig:616
msgid ""
"Set the secondary selection, with one end at the position clicked and the "
"other at the position specified with @kbd{M-Mouse-1} "
"(@code{mouse-secondary-save-then-kill}).  This also puts the selected text "
"in the kill ring.  A second @kbd{M-Mouse-3} at the same place kills the "
"secondary selection just made."
msgstr ""

#. type: findex
#: killing.texi.orig:617
#, no-wrap
msgid "mouse-yank-secondary"
msgstr ""

#. type: item
#: killing.texi.orig:618 killing.texi.orig:619
#, no-wrap
msgid "M-Mouse-2"
msgstr ""

#. type: table
#: killing.texi.orig:622
msgid ""
"Insert the secondary selection where you click, placing point at the end of "
"the yanked text (@code{mouse-yank-secondary})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:626
msgid ""
"Double or triple clicking of @kbd{M-Mouse-1} operates on words and lines, "
"much like @kbd{Mouse-1}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:630
msgid ""
"If @code{mouse-yank-at-point} is non-@code{nil}, @kbd{M-Mouse-2} yanks at "
"point.  Then it does not matter precisely where you click, or even which of "
"the frame's windows you click on.  @xref{Mouse Commands}."
msgstr ""

#. type: findex
#: killing.texi.orig:633
#, no-wrap
msgid "append-to-buffer"
msgstr ""

#. type: findex
#: killing.texi.orig:634
#, no-wrap
msgid "prepend-to-buffer"
msgstr ""

#. type: findex
#: killing.texi.orig:635
#, no-wrap
msgid "copy-to-buffer"
msgstr ""

#. type: findex
#: killing.texi.orig:636
#, no-wrap
msgid "append-to-file"
msgstr ""

#. type: cindex
#: killing.texi.orig:638
#, no-wrap
msgid "accumulating scattered text"
msgstr ""

#. type: Plain text
#: killing.texi.orig:644
msgid ""
"Usually we copy or move text by killing it and yanking it, but there are "
"other convenient methods for copying one block of text in many places, or "
"for copying many scattered blocks of text into one place.  Here we describe "
"the commands to accumulate scattered pieces of text into a buffer or into a "
"file."
msgstr ""

#. type: item
#: killing.texi.orig:646
#, no-wrap
msgid "M-x append-to-buffer"
msgstr ""

#. type: table
#: killing.texi.orig:648
msgid "Append region to the contents of a specified buffer."
msgstr ""

#. type: item
#: killing.texi.orig:648
#, no-wrap
msgid "M-x prepend-to-buffer"
msgstr ""

#. type: table
#: killing.texi.orig:650
msgid "Prepend region to the contents of a specified buffer."
msgstr ""

#. type: item
#: killing.texi.orig:650
#, no-wrap
msgid "M-x copy-to-buffer"
msgstr ""

#. type: table
#: killing.texi.orig:652
msgid "Copy region into a specified buffer, deleting that buffer's old contents."
msgstr ""

#. type: item
#: killing.texi.orig:652
#, no-wrap
msgid "M-x insert-buffer"
msgstr ""

#. type: table
#: killing.texi.orig:654
msgid "Insert the contents of a specified buffer into current buffer at point."
msgstr ""

#. type: item
#: killing.texi.orig:654
#, no-wrap
msgid "M-x append-to-file"
msgstr ""

#. type: table
#: killing.texi.orig:656
msgid "Append region to the contents of a specified file, at the end."
msgstr ""

#. type: Plain text
#: killing.texi.orig:665
msgid ""
"To accumulate text into a buffer, use @kbd{M-x append-to-buffer}.  This "
"reads a buffer name, then inserts a copy of the region into the buffer "
"specified.  If you specify a nonexistent buffer, @code{append-to-buffer} "
"creates the buffer.  The text is inserted wherever point is in that buffer.  "
"If you have been using the buffer for editing, the copied text goes into the "
"middle of the text of the buffer, starting from wherever point happens to be "
"at that moment."
msgstr ""

#. type: Plain text
#: killing.texi.orig:673
msgid ""
"Point in that buffer is left at the end of the copied text, so successive "
"uses of @code{append-to-buffer} accumulate the text in the specified buffer "
"in the same order as they were copied.  Strictly speaking, "
"@code{append-to-buffer} does not always append to the text already in the "
"buffer---it appends only if point in that buffer is at the end.  However, if "
"@code{append-to-buffer} is the only command you use to alter a buffer, then "
"point is always at the end."
msgstr ""

#. type: Plain text
#: killing.texi.orig:680
msgid ""
"@kbd{M-x prepend-to-buffer} is just like @code{append-to-buffer} except that "
"point in the other buffer is left before the copied text, so successive "
"prependings add text in reverse order.  @kbd{M-x copy-to-buffer} is similar, "
"except that any existing text in the other buffer is deleted, so the buffer "
"is left containing just the text newly copied into it."
msgstr ""

#. type: Plain text
#: killing.texi.orig:688
msgid ""
"The command @kbd{M-x insert-buffer} can be used to retrieve the accumulated "
"text from another buffer.  This prompts for the name of a buffer, and "
"inserts a copy of all the text in that buffer into the current buffer at "
"point, leaving point at the beginning of the inserted text.  It also adds "
"the position of the end of the inserted text to the mark ring, without "
"activating the mark.  @xref{Buffers}, for background information on buffers."
msgstr ""

#. type: Plain text
#: killing.texi.orig:693
msgid ""
"Instead of accumulating text in a buffer, you can append text directly into "
"a file with @kbd{M-x append-to-file}.  This prompts for a filename, and adds "
"the text of the region to the end of the specified file.  The file is "
"changed immediately on disk."
msgstr ""

#. type: Plain text
#: killing.texi.orig:698
msgid ""
"You should use @code{append-to-file} only with files that are @emph{not} "
"being visited in Emacs.  Using it on a file that you are editing in Emacs "
"would change the file behind Emacs's back, which can lead to losing some of "
"your editing."
msgstr ""

#. type: Plain text
#: killing.texi.orig:701
msgid ""
"Another way to move text around is to store it in a register.  "
"@xref{Registers}."
msgstr ""

#. type: findex
#: killing.texi.orig:704 killing.texi.orig:824
#, no-wrap
msgid "rectangle"
msgstr ""

#. type: cindex
#: killing.texi.orig:705
#, no-wrap
msgid "columns (and rectangles)"
msgstr ""

#. type: cindex
#: killing.texi.orig:706
#, no-wrap
msgid "killing rectangular areas of text"
msgstr ""

#. type: Plain text
#: killing.texi.orig:714
msgid ""
"@dfn{Rectangle} commands operate on rectangular areas of the text: all the "
"characters between a certain pair of columns, in a certain range of lines.  "
"Emacs has commands to kill rectangles, yank killed rectangles, clear them "
"out, fill them with blanks or text, or delete them.  Rectangle commands are "
"useful with text in multicolumn formats, and for changing text into or out "
"of such formats."
msgstr ""

#. type: cindex
#: killing.texi.orig:715
#, no-wrap
msgid "mark rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:721
msgid ""
"To specify a rectangle for a command to work on, set the mark at one corner "
"and point at the opposite corner.  The rectangle thus specified is called "
"the @dfn{region-rectangle}.  If point and the mark are in the same column, "
"the region-rectangle is empty.  If they are in the same line, the "
"region-rectangle is one line high."
msgstr ""

#. type: Plain text
#: killing.texi.orig:726
msgid ""
"The region-rectangle is controlled in much the same way as the region is "
"controlled.  But remember that a given combination of point and mark values "
"can be interpreted either as a region or as a rectangle, depending on the "
"command that uses them."
msgstr ""

#. type: kindex
#: killing.texi.orig:728 killing.texi.orig:767
#, no-wrap
msgid "C-x r k"
msgstr ""

#. type: table
#: killing.texi.orig:731
msgid ""
"Kill the text of the region-rectangle, saving its contents as the ``last "
"killed rectangle'' (@code{kill-rectangle})."
msgstr ""

#. type: kindex
#: killing.texi.orig:731 killing.texi.orig:786
#, no-wrap
msgid "C-x r M-w"
msgstr ""

#. type: table
#: killing.texi.orig:734
msgid ""
"Save the text of the region-rectangle as the ``last killed rectangle'' "
"(@code{copy-rectangle-as-kill})."
msgstr ""

#. type: kindex
#: killing.texi.orig:734 killing.texi.orig:768
#, no-wrap
msgid "C-x r d"
msgstr ""

#. type: table
#: killing.texi.orig:736
msgid "Delete the text of the region-rectangle (@code{delete-rectangle})."
msgstr ""

#. type: kindex
#: killing.texi.orig:736 killing.texi.orig:792
#, no-wrap
msgid "C-x r y"
msgstr ""

#. type: table
#: killing.texi.orig:739
msgid ""
"Yank the last killed rectangle with its upper left corner at point "
"(@code{yank-rectangle})."
msgstr ""

#. type: kindex
#: killing.texi.orig:739 killing.texi.orig:807
#, no-wrap
msgid "C-x r o"
msgstr ""

#. type: table
#: killing.texi.orig:743
msgid ""
"Insert blank space to fill the space of the region-rectangle "
"(@code{open-rectangle}).  This pushes the previous contents of the "
"region-rectangle to the right."
msgstr ""

#. type: kindex
#: killing.texi.orig:743 killing.texi.orig:823
#, no-wrap
msgid "C-x r N"
msgstr ""

#. type: table
#: killing.texi.orig:747
msgid ""
"Insert line numbers along the left edge of the region-rectangle "
"(@code{rectangle-number-lines}).  This pushes the previous contents of the "
"region-rectangle to the right."
msgstr ""

#. type: kindex
#: killing.texi.orig:747 killing.texi.orig:809
#, no-wrap
msgid "C-x r c"
msgstr ""

#. type: table
#: killing.texi.orig:750
msgid ""
"Clear the region-rectangle by replacing all of its contents with spaces "
"(@code{clear-rectangle})."
msgstr ""

#. type: item
#: killing.texi.orig:750
#, no-wrap
msgid "M-x delete-whitespace-rectangle"
msgstr ""

#. type: table
#: killing.texi.orig:753
msgid ""
"Delete whitespace in each of the lines on the specified rectangle, starting "
"from the left edge column of the rectangle."
msgstr ""

#. type: item
#: killing.texi.orig:753
#, no-wrap
msgid "C-x r t @var{string} @key{RET}"
msgstr ""

#. type: table
#: killing.texi.orig:756
msgid ""
"Replace rectangle contents with @var{string} on each line "
"(@code{string-rectangle})."
msgstr ""

#. type: item
#: killing.texi.orig:756
#, no-wrap
msgid "M-x string-insert-rectangle @key{RET} @var{string} @key{RET}"
msgstr ""

#. type: table
#: killing.texi.orig:758
msgid "Insert @var{string} on each line of the rectangle."
msgstr ""

#. type: item
#: killing.texi.orig:758
#, no-wrap
msgid "C-x @key{SPC}"
msgstr ""

#. type: table
#: killing.texi.orig:762
msgid ""
"Toggle Rectangle Mark mode (@code{rectangle-mark-mode}).  When this mode is "
"active, the region-rectangle is highlighted and can be shrunk/grown, and the "
"standard kill and yank commands operate on it."
msgstr ""

#. type: Plain text
#: killing.texi.orig:766
msgid ""
"The rectangle operations fall into two classes: commands to erase or insert "
"rectangles, and commands to make blank rectangles."
msgstr ""

#. type: findex
#: killing.texi.orig:769
#, no-wrap
msgid "kill-rectangle"
msgstr ""

#. type: findex
#: killing.texi.orig:770
#, no-wrap
msgid "delete-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:778
msgid ""
"There are two ways to erase the text in a rectangle: @kbd{C-x r d} "
"(@code{delete-rectangle}) to delete the text outright, or @kbd{C-x r k} "
"(@code{kill-rectangle}) to remove the text and save it as the @dfn{last "
"killed rectangle}.  In both cases, erasing the region-rectangle is like "
"erasing the specified text on each line of the rectangle; if there is any "
"following text on the line, it moves backwards to fill the gap."
msgstr ""

#. type: Plain text
#: killing.texi.orig:785
msgid ""
"``Killing'' a rectangle is not killing in the usual sense; the rectangle is "
"not stored in the kill ring, but in a special place that only records the "
"most recent rectangle killed.  This is because yanking a rectangle is so "
"different from yanking linear text that different yank commands have to be "
"used.  Yank-popping is not defined for rectangles."
msgstr ""

#. type: findex
#: killing.texi.orig:787
#, no-wrap
msgid "copy-rectangle-as-kill"
msgstr ""

#. type: Plain text
#: killing.texi.orig:791
msgid ""
"@kbd{C-x r M-w} (@code{copy-rectangle-as-kill}) is the equivalent of "
"@kbd{M-w} for rectangles: it records the rectangle as the ``last killed "
"rectangle'', without deleting the text from the buffer."
msgstr ""

#. type: findex
#: killing.texi.orig:793
#, no-wrap
msgid "yank-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:799
msgid ""
"To yank the last killed rectangle, type @kbd{C-x r y} "
"(@code{yank-rectangle}).  The rectangle's first line is inserted at point, "
"the rectangle's second line is inserted at the same horizontal position one "
"line vertically below, and so on.  The number of lines affected is "
"determined by the height of the saved rectangle."
msgstr ""

#. type: Plain text
#: killing.texi.orig:803
msgid ""
"For example, you can convert two single-column lists into a double-column "
"list by killing one of the single-column lists as a rectangle, and then "
"yanking it beside the other list."
msgstr ""

#. type: Plain text
#: killing.texi.orig:806
msgid ""
"You can also copy rectangles into and out of registers with @kbd{C-x r r "
"@var{r}} and @kbd{C-x r i @var{r}}.  @xref{Rectangle Registers}."
msgstr ""

#. type: findex
#: killing.texi.orig:808
#, no-wrap
msgid "open-rectangle"
msgstr ""

#. type: findex
#: killing.texi.orig:810
#, no-wrap
msgid "clear-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:815
msgid ""
"There are two commands you can use for making blank rectangles: @kbd{C-x r "
"c} (@code{clear-rectangle}) blanks out existing text in the "
"region-rectangle, and @kbd{C-x r o} (@code{open-rectangle}) inserts a blank "
"rectangle."
msgstr ""

#. type: findex
#: killing.texi.orig:816
#, no-wrap
msgid "delete-whitespace-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:822
msgid ""
"@kbd{M-x delete-whitespace-rectangle} deletes horizontal whitespace starting "
"from a particular column.  This applies to each of the lines in the "
"rectangle, and the column is specified by the left edge of the rectangle.  "
"The right edge of the rectangle does not make any difference to this "
"command."
msgstr ""

#. type: Plain text
#: killing.texi.orig:832
msgid ""
"The command @kbd{C-x r N} (@code{rectangle-number-lines}) inserts line "
"numbers along the left edge of the region-rectangle.  Normally, the "
"numbering begins from 1 (for the first line of the rectangle).  With a "
"prefix argument, the command prompts for a number to begin from, and for a "
"format string with which to print the numbers (@pxref{Formatting Strings,,, "
"elisp, The Emacs Lisp Reference Manual})."
msgstr ""

#. type: kindex
#: killing.texi.orig:833
#, no-wrap
msgid "C-x r t"
msgstr ""

#. type: findex
#: killing.texi.orig:834
#, no-wrap
msgid "string-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:841
msgid ""
"The command @kbd{C-x r t} (@code{string-rectangle}) replaces the contents of "
"a region-rectangle with a string on each line.  The string's width need not "
"be the same as the width of the rectangle.  If the string's width is less, "
"the text after the rectangle shifts left; if the string is wider than the "
"rectangle, the text after the rectangle shifts right."
msgstr ""

#. type: findex
#: killing.texi.orig:842
#, no-wrap
msgid "string-insert-rectangle"
msgstr ""

#. type: Plain text
#: killing.texi.orig:846
msgid ""
"The command @kbd{M-x string-insert-rectangle} is similar to "
"@code{string-rectangle}, but inserts the string on each line, shifting the "
"original text to the right."
msgstr ""

#. type: findex
#: killing.texi.orig:847
#, no-wrap
msgid "rectangle-mark-mode"
msgstr ""

#. type: Plain text
#: killing.texi.orig:855
msgid ""
"The command @kbd{C-x @key{SPC}} (@code{rectangle-mark-mode}) toggles whether "
"the region-rectangle or the standard region is highlighted (first activating "
"the region if necessary).  When this mode is enabled, commands that resize "
"the region (@kbd{C-f}, @kbd{C-n} etc.) do so in a rectangular fashion, and "
"killing and yanking operate on the rectangle.  @xref{Killing}.  The mode "
"persists only as long as the region is active."
msgstr ""

#. type: vindex
#: killing.texi.orig:858 killing.texi.orig:859
#, no-wrap
msgid "cua-mode"
msgstr ""

#. type: cindex
#: killing.texi.orig:860
#, no-wrap
msgid "CUA key bindings"
msgstr ""

#. type: vindex
#: killing.texi.orig:861
#, no-wrap
msgid "cua-enable-cua-keys"
msgstr ""

#. type: Plain text
#: killing.texi.orig:865
msgid ""
"The command @kbd{M-x cua-mode} sets up key bindings that are compatible with "
"the Common User Access (CUA) system used in many other applications."
msgstr ""

#. type: Plain text
#: killing.texi.orig:873
msgid ""
"When CUA mode is enabled, the keys @kbd{C-x}, @kbd{C-c}, @kbd{C-v}, and "
"@kbd{C-z} invoke commands that cut (kill), copy, paste (yank), and undo "
"respectively.  The @kbd{C-x} and @kbd{C-c} keys perform cut and copy only if "
"the region is active.  Otherwise, they still act as prefix keys, so that "
"standard Emacs commands like @kbd{C-x C-c} still work.  Note that this means "
"the variable @code{mark-even-if-inactive} has no effect for @kbd{C-x} and "
"@kbd{C-c} (@pxref{Using Region})."
msgstr ""

#. type: Plain text
#: killing.texi.orig:878
msgid ""
"To enter an Emacs command like @kbd{C-x C-f} while the mark is active, use "
"one of the following methods: either hold @kbd{Shift} together with the "
"prefix key, e.g., @kbd{S-C-x C-f}, or quickly type the prefix key twice, "
"e.g., @kbd{C-x C-x C-f}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:882
msgid ""
"To disable the overriding of standard Emacs binding by CUA mode, while "
"retaining the other features of CUA mode described below, set the variable "
"@code{cua-enable-cua-keys} to @code{nil}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:886
msgid ""
"CUA mode by default activates Delete-Selection mode (@pxref{Mouse Commands})  "
"so that typed text replaces the active region.  To use CUA without this "
"behavior, set the variable @code{cua-delete-selection} to @code{nil}."
msgstr ""

#. type: cindex
#: killing.texi.orig:887
#, no-wrap
msgid "rectangle highlighting"
msgstr ""

#. type: Plain text
#: killing.texi.orig:895
msgid ""
"CUA mode provides enhanced rectangle support with visible rectangle "
"highlighting.  Use @kbd{C-@key{RET}} to start a rectangle, extend it using "
"the movement commands, and cut or copy it using @kbd{C-x} or @kbd{C-c}.  "
"@key{RET} moves the cursor to the next (clockwise) corner of the rectangle, "
"so you can easily expand it in any direction.  Normal text you type is "
"inserted to the left or right of each line in the rectangle (on the same "
"side as the cursor)."
msgstr ""

#. type: Plain text
#: killing.texi.orig:899
msgid ""
"You can use this rectangle support without activating CUA by calling the "
"@code{cua-rectangle-mark-mode} command.  But see also the standard "
"@code{rectangle-mark-mode}.  @xref{Rectangles}."
msgstr ""

#. type: Plain text
#: killing.texi.orig:904
msgid ""
"With CUA you can easily copy text and rectangles into and out of registers "
"by providing a one-digit numeric prefix to the kill, copy, and yank "
"commands, e.g., @kbd{C-1 C-c} copies the region into register @code{1}, and "
"@kbd{C-2 C-v} yanks the contents of register @code{2}."
msgstr ""

#. type: cindex
#: killing.texi.orig:905
#, no-wrap
msgid "global mark"
msgstr ""

#. type: Plain text
#: killing.texi.orig:912
msgid ""
"CUA mode also has a global mark feature which allows easy moving and copying "
"of text between buffers.  Use @kbd{C-S-@key{SPC}} to toggle the global mark "
"on and off.  When the global mark is on, all text that you kill or copy is "
"automatically inserted at the global mark, and text you type is inserted at "
"the global mark rather than at the current position."
msgstr ""

#. type: Plain text
#: killing.texi.orig:918
msgid ""
"For example, to copy words from various buffers into a word list in a given "
"buffer, set the global mark in the target buffer, then navigate to each of "
"the words you want in the list, mark it (e.g., with @kbd{S-M-f}), copy it to "
"the list with @kbd{C-c} or @kbd{M-w}, and insert a newline after the word in "
"the target list by pressing @key{RET}."
msgstr ""
