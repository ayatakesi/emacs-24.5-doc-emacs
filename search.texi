@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2000-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@node Search
@chapter 検索と置換
@cindex searching
@cindex finding strings within text

  他のエディターと同様、Emacsには文字列を検索(search)するコマンドがあります。Emacsには、文字列を違う文字列で置き換える(replace)コマンドもあります。また、同じことを行いますが、固定文字列ではなくパターンを検索するコマンドもあります。

  tagsテーブルの制御下にある複数ファイルにたいして検索したり(@ref{Tags
Search}を参照してください)、Diredの@kbd{A}コマンドを通じて検索したり(@ref{Operating on
Files}を参照してください)、@code{grep}コマンドを使った検索(@ref{Grep Searching}を参照してください)も可能です。

@menu
* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の構文について。
* Regexp Backslash::         `\'で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Search Case::              検索で大文字小文字を無視または区別するには。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。
@end menu

@node Incremental Search
@section インクリメンタル検索
@cindex incremental search
@cindex isearch

  Emacsにおける重要な検索コマンドは、@dfn{インクリメンタル検索(isearch: incremental
search)}です。これは検索する文字列の最初の文字をタイプすると、すぐに検索が開始されます。検索文字列をタイプしていくにつれて、Emacsはその文字列(それまでに入力した文字列)がどこにあるかを表示します。望む場所を特定するのに充分な文字列をタイプしたところで、検索をストップできます。次に何をするかによって、明示的な@key{RET}により検索を終えたり、続けることができます。

@table @kbd
@item C-s
前方にインクリメンタル検索します(@code{isearch-forward})。
@item C-r
後方にインクリメンタル検索します(@code{isearch-backward})。
@end table

@menu
* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファーヒストリーのインクリメンタル検索。
@end menu

@node Basic Isearch
@subsection インクリメンタル検索の基本

@table @kbd
@item C-s
インクリメンタル検索を開始します(@code{isearch-forward})。
@item C-r
逆向きのインクリメンタル検索を開始します(@code{isearch-backward})。
@end table

@kindex C-s
@findex isearch-forward
  @kbd{C-s}
(@code{isearch-forward})は、前方へのインクリメンタル検索を開始します。これはキーボードから文字を読み取り、タイプした文字が最初に出現するバッファーの位置に、ポイントを移動します。

  たとえば@kbd{C-s}とタイプした後に@kbd{F}をタイプすると、検索を開始したバッファーのポイント位置より前方にある、最初の@kbd{F}にカーソルを移動します。つぎに@kbd{O}をタイプすると、前方にある最初の@samp{FO}にカーソルが移動します。この場合、@samp{FO}の@samp{F}は、前に見つかった@samp{F}と同じ位置である必要はありません。もう一度@kbd{O}をタイプすると、カーソルは最初の@samp{FOO}に移動します。

@cindex faces for highlighting search matches
@cindex isearch face
  各ステップでEmacsは@dfn{カレントマッチ(current match:
現在のマッチ)}(検索文字列にマッチしたバッファーのテキスト)を、@code{isearch}フェイスでハイライトします(@ref{Faces}を参照してください)。その時点での検索文字列はエコーエリアにも表示されます。

  検索文字列を間違ってタイプしたときは、@key{DEL}をタイプします。@key{DEL}をタイプするごとに、検索文字列の最後の文字が取り消されます。

  検索により到達した位置に満足したら、@key{RET}をタイプします。これは検索をストップして、検索により移動した位置にカーソルを残します。検索とは関係ないコマンドも、検索をストップして、そのコマンドが実行されます。つまり@kbd{C-a}は検索を中止して、行の先頭に移動します。@key{RET}で検索を終える必要があるのは、次のコマンドが印字文字をタイプするコマンドのときだけです。@key{DEL}、@key{RET}および他のいくつかの文字(@kbd{C-q}、@kbd{C-w}、@kbd{C-r}、@kbd{C-s}、@kbd{C-y}、@kbd{M-y}、@kbd{M-r}、@kbd{M-c}、@kbd{M-e}、および以下で説明する文字)は、検索で特別な意味を持っています。

  特別な例外として、検索文字列が空のときに@key{RET}を入力すると、非インクリメンタル検索を開始します(@ref{Nonincremental
Search}を参照してください)。

  インクリメンタル検索を終了するとき、ポイントの元の位置をマークをアクティブにせず(ただしマークがすでにアクティブではなかったときだけ)に、マークリングに追加します。これにより、@kbd{C-u
C-@key{SPC}}を使って、検索を開始する前の位置に戻ることができます。@ref{Mark
Ring}を参照してください。これはマークがすでにアクティブでないときだけ行なわれます。

@kindex C-r
@findex isearch-backward
  後方に検索するには、@kbd{C-s}で検索を開始するかわりに、@kbd{C-r}
(@code{isearch-backward})を使います。前方検索が検索を開始した位置より前方にある最初のマッチを探すように、後方検索は検索を開始した位置より後方にある最後のマッチを探します。

@node Repeat Isearch
@subsection インクリメンタル検索の繰り返し

  前方に@samp{FOO}を検索してマッチしたが、それは探しているマッチではなく、探しているのはバッファーのもっと前方に出現する@samp{FOO}だとしましょう。ここでもう1度@kbd{C-s}をタイプすることにより、検索文字列が次に出現する場所に移動します。これは何回でも繰り返すことができます。もしタイプしすぎたときは、@kbd{C-s}を@key{DEL}で取り消すことができます。同様に後方へのインクリメンタル検索では、@kbd{C-r}により後方検索が繰り返されます。

@cindex lazy search highlighting
@vindex isearch-lazy-highlight
  インクリメンタル検索中に手を止めて眺めてみると、検索文字列にたいするカレントマッチ以外に、スクリーンに表示されている他のマッチもハイライトされていることがわかります。これは検索するために、何回@kbd{C-s}または@kbd{C-r}を繰り返せばよいのか予測しやすくするためです。その他のマッチは、カスタマイズ可能なフェイス@code{lazy-highlight}
(@ref{Faces}を参照してください)を使って、現在のマッチとは異なってハイライトされます。この機能を無効にするには、@code{isearch-lazy-highlight}に@code{nil}をセットしてください。

  検索を終了した後、同じ文字列を再度検索するには、@kbd{C-s
C-s}とタイプします。最初の@kbd{C-s}はインクリメンタル検索を呼び出し、2回目の@kbd{C-s}は``再検索''を意味します。同様に、@kbd{C-r
C-r}は最後に検索した文字列を後方に検索します。最後に検索された文字列の決定では、文字列が@kbd{C-s}で検索されたのか、@kbd{C-r}で検索されたのかは問題ではありません。

  前方に検索していて、検索している対象が検索開始点より後方にあるのに気付いたときは、検索文字列を変更すること無く、@kbd{C-r}で後方検索に切り替えることができます。同様に後方検索で@kbd{C-s}をタイプすると、前方検索に切り替わります。

  検索が失敗したとき、バッファーの先頭から検索を再開するには、もう一度@kbd{C-s}をタイプします。逆向きの繰り返し検索が失敗したときは、@kbd{C-r}でバッファーの最後から検索を再開します。これは@dfn{wrapping
around(巻き直し)}と呼ばれ、これが発生すると、@samp{Wrapped}という単語が検索プロンプトに表示されます。検索を続けて元の検索開始ポイントを通過すると、@samp{Overwrapped}に変化します。これはすでに見たマッチを再訪していることを意味します。

@cindex search ring
@kindex M-n @r{(Incremental search)}
@kindex M-p @r{(Incremental search)}
  以前に検索した文字列を再利用するには、@dfn{サーチリング(search
ring)}を使います。コマンド@kbd{M-p}または@kbd{M-n}で、リングを移動して再使用したい文字列を取り出します。これらのコマンドは、選択されたリング要素の文字列をミニバッファーに残すので、それを編集することができます。

@kindex M-e @r{(Incremental search)}
  ミニバッファーの現在の検索文字列を、サーチリングのアイテムで置き換えずに編集するときは、@kbd{M-e}をタイプします。@key{RET}、@kbd{C-s}、@kbd{C-r}をタイプすれば編集を終了して、それを検索できます。

@node Error in Isearch
@subsection インクリメンタル検索でのエラー

  文字列が見つからなかった場合、エコーエリアに@samp{Failing
I-Search}と表示されて、文字列とできるかぎりマッチした位置に、カーソルが移動します。つまり@samp{FOOT}を検索して@samp{FOOT}がない場合、カーソルは@samp{FOOL}という文字列の@samp{FOO}の後ろに移動します。エコーエリアではマッチに失敗した検索文字列の一部が、フェイス@code{isearch-fail}を使ってハイライトされます。

  その時に行うことができる、いくつかの選択肢があります。もし文字列が間違っている場合は、文字列を訂正するため@key{DEL}でテキストを削除できます。もし見つかった位置が望む位置なら、@key{RET}をタイプしてその位置に留まることができます。または@kbd{C-g}をタイプして、検索文字列から検索できなかった文字(@samp{FOOT}の中の@samp{T})を取り除き、検索された部分の文字列(@samp{FOOT}の中の@samp{FOO})を残します。その位置でもう1回@kbd{C-g}をタイプすると、検索全体を取り消し、ポイントは検索を開始した位置に戻ります。

@cindex quitting (in search)
@kindex C-g @r{(Incremental search)}
  終了コマンドの@kbd{C-g}は、検索において特別な処理を行います。このコマンドの動作は、検索の状況に依存します。もし指定した文字列の検索が成功して、さらに検索文字の入力を待っているとき、@kbd{C-g}は検索全体を取り消して、カーソルを検索を開始したときの位置に移動します。検索文字列に検索に失敗した文字が含まれているときに、@kbd{C-g}がタイプされたときは、検索文字列から検索に失敗した文字が取り除かれます。後に残るのは検索に成功した文字列で、さらに検索文字の入力を待っているので、先のケースと同様、2回目の@kbd{C-g}で検索全体が取り消されます。

@node Special Isearch
@subsection インクリメンタル検索の特別な入力

  インクリメンタル検索のときタイプする文字列の中には、特別な効果をもつものがあります。

@cindex lax space matching
@kindex M-s SPC @r{(Incremental search)}
@kindex SPC @r{(Incremental search)}
@findex isearch-toggle-lax-whitespace
@vindex search-whitespace-regexp
  デフォルトでは、インクリメンタル検索は@dfn{緩いスペースマッチング(lax space
matching)}を行います。これはスペースおよび一連のスペースは、テキスト中の1つまたはそれ以上のスペースにマッチします。したがって@samp{foo
bar}は@samp{foo bar}、@samp{foo@ @ bar}、@samp{foo@ @ @
bar}、...にマッチします(@samp{foobar}にはマッチしません)。正確にいうと、Emacsは検索文字列中の一連のスペースを、変数@code{search-whitespace-regexp}で指定された正規表現にマッチさせます。たとえばスペースを一連の改行とスペースにマッチさせるには、変数に@samp{"[[:space:]\n]+"}をセットします。

  緩いスペースマッチングを切り替えるには、@kbd{M-s @key{SPC}}
(@code{isearch-toggle-lax-whitespace})をタイプします。この機能全体を無効にするには、@code{search-whitespace-regexp}を@code{nil}に変更します。これにより検索文字列中のスペースは、正確に1つのスペースにマッチします。

  検索文字列に小文字しか含まれていないとき、検索は大文字小文字を区別しません。検索文字列に大文字が含まれているとき、検索は大文字小文字を区別します。検索文字列から大文字を削除すると、この効果はなくなります。@ref{Search
Case}を参照してください。

@cindex invisible text, searching for
@kindex M-s i @r{(Incremental search)}
@findex isearch-toggle-invisible
  非表示のテキストを検索するかしないかは、@kbd{M-s i}
(@code{isearch-toggle-invisible})とタイプして切り替えることができます。@ref{Outline
Search}を参照してください。

  改行文字を検索するには@kbd{C-j}とタイプします。

  非@acronym{ASCII}文字を検索するには、以下の方法の1つを使います:

@itemize @bullet
@item
@kbd{C-q}に続けて、非グラフィック文字か8進数字をタイプします。これは@kbd{C-q}を使ってバッファーに文字を挿入するのと同様に、検索文字列にタイプする文字を追加します(@ref{Inserting
Text}を参照してください)。たとえばインクリメンタル検索で@kbd{C-q
C-s}をタイプすると、検索文字列に文字@samp{control-S}が追加されます。

@item
@kbd{C-x 8
@key{RET}}に続けて、Unicode名かコードポイントをタイプします。これは通常の@code{insert-char}コマンドと同様に、検索文字列に指定した文字を追加します(@ref{Inserting
Text}を参照してください)。

@item
入力メソッド(IM: input method)を使います(@ref{Input
Methods}を参照してください)。検索を開始したとき、カレントバッファーで入力メソッドが有効の場合、検索文字列にもそれを使うことができます。検索文字列をタイプするとき、@kbd{C-\}
(@code{isearch-toggle-input-method})で、入力メソッドを切り替えることができます。非デフォルトの入力メソッドに切り替えるには、@kbd{C-^}
(@code{isearch-toggle-specified-input-method})を使います。これは入力メソッドの名前を尋ねます。インクリメンタル検索で入力メソッドがアクティブのとき、検索プロンプトには以下のようなニーモニックが含まれます。

@example
I-search [@var{im}]:
@end example

@noindent
@findex isearch-toggle-input-method
@findex isearch-toggle-specified-input-method
@var{im}はアクティブな入力メソッドのニーモニックです。インクリメンタル検索で入力メソッドを有効にすると、カレントバッファーでも入力メソッドが有効のまま残ります。
@end itemize

@kindex M-% @r{(Incremental search)}
  インクリメンタル検索で@kbd{M-%}をタイプすると、@code{query-replace}または@code{query-replace-regexp}が呼び出され(検索モードに依存します)、現在の検索文字が置換対象になります。負のプレフィクス引数は、後方への置換を意味します。@ref{Query
Replace}を参照してください。

@kindex M-TAB @r{(Incremental search)}
  インクリメンタル検索で@kbd{M-@key{TAB}}をタイプすると、@code{isearch-complete}が呼び出され、サーチリングを補完リストとして使って、検索文字列の補完を試みます。@ref{Completion}を参照してください。多くのオペレーティングシステムでは、キーシーケンス@kbd{M-@key{TAB}}はウィンドウマネージャーに捕えられます。その場合、これを使うには@code{isearch-complete}を、他のキーシーケンスに再バインドする必要があります(@ref{Rebinding}を参照してください)。

@vindex isearch-mode-map
  インクリメンタル検索がアクティブのとき、@kbd{C-h
C-h}とタイプすると、特別なキーバインドのリストを含む、対話的なヘルプにアクセスできます。これらのキーバインドは、キーマップ@code{isearch-mode-map}の一部です(@ref{Keymaps}を参照してください)。

@node Isearch Yank
@subsection インクリメンタル検索でのyank

@kindex C-y @r{(Incremental search)}
@kindex M-y @r{(Incremental search)}
@findex isearch-yank-kill
@findex isearch-yank-pop
  インクリメンタル検索での@kbd{C-y}
(@code{isearch-yank-kill})は、カレントkillを検索文字列に追加します。@kbd{C-y}の後に@kbd{M-y}
(@code{isearch-yank-pop})が呼び出されると、追加するテキストを、もっと前にkillされたものに置き換えます。これは通常の@kbd{M-y}
(@code{yank-pop})コマンドと似ています(@ref{Yanking}を参照してください)。@kbd{Mouse-2}はカレントのX選択を追加します(@ref{Primary
Selection}を参照してください)。

@kindex C-w @r{(Incremental search)}
@findex isearch-yank-word-or-char
  @kbd{C-w}
(@code{isearch-yank-word-or-char})は、検索された文字列のポイントの次の文字または単語を、検索文字列に追加します。これはポイント位置にあるテキストを検索する、簡単な方法です(コピーする対象を文字または単語のどちらにするかの決定は、発見的に行われます)。

@kindex M-s C-e @r{(Incremental search)}
@findex isearch-yank-line
  同様に@kbd{M-s C-e}
(@code{isearch-yank-line})は、検索文字列にカレント行の残りの部分を追加します。ポイントが既に行末にある場合、次の行が追加されます。プレフィクス引数@var{n}を指定すると、次の@var{n}行を追加します。

  もし大文字小文字を区別せずに検索している場合、@kbd{C-w}と@kbd{M-s
C-e}はテキストを小文字に変換してからコピーするので、それ以降も検索は大文字小文字を区別せずに行われます。

@kindex C-M-w @r{(Incremental search)}
@kindex C-M-y @r{(Incremental search)}
@findex isearch-del-char
@findex isearch-yank-char
  @kbd{C-M-w} (@code{isearch-del-char})は検索文字列の最後の文字を削除し、@kbd{C-M-y}
(@code{isearch-yank-char})は検索されたポイントの後ろの文字を追加します。ポイントの後ろの文字を追加する他の方法は、@kbd{M-e}(@ref{Repeat
Isearch}を参照してください)でミニバッファーに移動してから、検索文字列の最後で@kbd{C-f}をタイプします。

@node Not Exiting Isearch
@subsection インクリメンタル検索を終了させない

このサブセクションでは、2つのカテゴリーに属するコマンドを説明します。これらのコマンドはインクリメンタル検索の一部ではありませんが、現在のインクリメンタル検索を終了させずにタイプできます。

@table @asis
@item プレフィクス引数
@vindex isearch-allow-prefix
  インクリメンタル検索でプレフィクス引数を入力すると、デフォルトではその引数は次の検索アクションに適用されるか、検索を終了させるコマンドに渡されます。

  以前のバージョンのEmacsでは、プレフィクス引数の入力は常に検索を終了させていました。この振る舞いに戻すには、変数@code{isearch-allow-prefix}に@code{nil}をセットしてください。

  @code{isearch-allow-scroll}が非@code{nil}のとき(以下を参照)、プレフィクス引数は上で説明したようなデフォルト動作をします。

@item スクロールコマンド
@vindex isearch-allow-scroll
  通常スクロールコマンドは、インクリメンタル検索を終了させます。変数@code{isearch-allow-scroll}を非@code{nil}値に変更すると、スクロールバーや@kbd{C-v}、@kbd{M-v}、@kbd{C-l}のようなスクロールコマンド(@ref{Scrolling}を参照してください)が利用可能になります。これは、これらのコマンドをバウンドされたキーシーケンスで呼び出したときだけ適用されます。つまり@kbd{M-x}は依然として検索を終了させます。これらのコマンドには、通常の方法でプレフィクス引数を与えることができます。この機能ではカレントマッチが表示されない位置にスクロールすることはできません。

  @code{isearch-allow-scroll}の機能は、正確にはスクロールではないが、テキストが表示されるスクリーン位置に影響する、@kbd{C-x
2} (@code{split-window-below})や@kbd{C-x ^}
(@code{enlarge-window})のような、コマンドにも効果を及ぼします。これはコマンド名の@code{isearch-scroll}プロパティが非@code{nil}のコマンドに適用されます。そのため、どのコマンドが影響を受けるかは、それらのプロパティを変更して制御できます。

  たとえば将来のEmacsセッションも含めて、インクリメンタル検索中に@kbd{C-h l}を使えれば便利だと思ったら、まず@kbd{C-h
c}で何のコマンドが実行されるか調べて(@ref{Key
Help}を参照してください)、それが@code{view-lossage}だとわかります。その後はinitファイルに以下を追加します(@ref{Init
File}を参照してください)。

@example
(put 'view-lossage 'isearch-scroll t)
@end example

@noindent
この機能はポイント、バッファー内容、マッチデータ、カレントバッファーや選択されているウィンドウ・フレームを変更しない任意のコマンドに適用できます。そして、そのコマンド自体がインクリメンタル検索を行ってはなりません。
@end table

@node Isearch Minibuffer
@subsection ミニバッファーの検索
@cindex minibuffer history, searching

ミニバッファーがアクティブのときインクリメンタル検索を開始すると、Emacsはミニバッファーの内容を検索します。通常のバッファーにたいする検索とは異なり、エコーエリアはミニバッファーの表示に使われているので、検索文字列はエコーエリアには表示されません。

ミニバッファーでのインクリメンタル検索が失敗すると、ミニバッファーヒストリーを検索します。@ref{Minibuffer
History}を参照してください。ミニバッファーとミニバッファーのヒストリーは、一番古いヒストリー要素が最初で、カレントのミニバッファーが最後にある、一連の``ページ''として視覚化することができます。前方検索の@kbd{C-s}は前方、つまり新しいページを検索し、後方検索の@kbd{C-r}は後方、つまり古いページを検索します。普通のバッファーの検索と同様、検索が失敗すると、最後から最初のページ、またはその逆に巻き直して検索します。

カレントマッチがヒストリーの要素にあった場合、ヒストリーの要素はミニバッファーに取り出されます。インクリメンタル検索を正常に終了(たとえば@key{RET}をタイプ)すれば、それはミニバッファーに残ります。検索を取り消すのは@kbd{C-g}で、これによりミニバッファーの内容は検索を開始したときのものに復元されます。

@node Nonincremental Search
@section 非インクリメンタル検索
@cindex nonincremental search

  Emacsには、従来式の非インクリメンタル検索もあります。これは検索を開始する前に、検索文字列全体を入力する必要があります。

@table @kbd
@item C-s @key{RET} @var{string} @key{RET}
@var{string}を検索します。
@item C-r @key{RET} @var{string} @key{RET}
後方に@var{string}を検索します。
@end table

  非インクリメンタル検索を開始するには、最初に@kbd{C-s
@key{RET}}をタイプします。これにより、検索文字列を読みとるために、ミニバッファーに移動します。検索文字列の入力を終了して検索を開始するには、@key{RET}をタイプします。文字列が見つからなかったとき、検索コマンドはエラーをシグナルします。

@findex search-forward
@findex search-backward
  @kbd{C-s
@key{RET}}とタイプすると、@kbd{C-s}は通常どおりインクリメンタル検索を呼び出します。しかし、このコマンドは指定した文字列が空のとき、非インクリメンタル検索を行うコマンド@code{search-forward}を呼び出すよう、プログラムされています(そのような用途以外に空の引数は無意味です)。@kbd{C-r
@key{RET}}も同様に、コマンド@code{search-backward}を呼び出します。

@node Word Search
@section 単語検索
@cindex word search

  @dfn{単語検索(word
search)}は、単語の並びを、その間にある区切り文字の種類とは無関係に検索します。たとえば検索文字列に、1つのスペースで区切られた2つの単語を入力すると、2つの単語を区切るのが、1つまたはそれ以上のスペース、改行文字、およびそれ以外の区切り文字の場合にもマッチします。これはテキスト文書を検索するとき特に有用です。なぜなら検索する単語が改行で区切られているのか、スペースで区切られているのか考慮しなくてもよいからです。

@table @kbd
@item M-s w
インクリメンタル検索がアクティブのとき、単語検索モードに切り替えます(@code{isearch-toggle-word})。非アクティブのときは、前方へのインクリメンタルな単語検索を開始します(@code{isearch-forward-word})。
@item M-s w @key{RET} @var{words} @key{RET}
非インクリメンタルな単語検索を使って、@var{words}を前方検索します。
@item M-s w C-r @key{RET} @var{words} @key{RET}
非インクリメンタルな単語検索を使って、@var{words}を後方検索します。
@end table

@kindex M-s w
@findex isearch-forward-word
  前方へのインクリメンタルな単語検索を開始するには、@kbd{M-s
w}とタイプします。インクリメンタル検索が非アクティブの場合、これはコマンド@code{isearch-forward-word}を実行します。インクリメンタル検索がすでにアクティブの場合(前方か後方かにかかわらず)、@kbd{M-s
w}は検索の方向と現在の検索文字列は変更せずに、単語検索に切り替えます。単語検索をオフに切り替えるには、再度@kbd{M-s w}をタイプしてください。

@findex word-search-forward
@findex word-search-backward
  非インクリメンタルな単語検索を開始する場合、前方検索は@kbd{M-s w @key{RET}}、後方検索は@kbd{M-s w C-r
@key{RET}}をタイプします。これらはコマンド@code{word-search-forward}、または@code{word-search-backward}を実行します。

  インクリメンタルな単語検索と、非インクリメンタルな単語検索では、マッチを見つける方法に若干の違いがあります。非インクリメンタルな単語検索では、検索文字列の各単語は、単語全体に厳密に一致しなければなりません。インクリメンタルな単語検索では、マッチの規則は緩くなります。検索文字列をタイプするとき、最初と最後の単語は、単語全体にマッチする必要はありません。これはタイプする度にマッチを処理するためです。これは(カーソルがある)カレントマッチ以外のマッチ(lazy
matches)には適用されません。それらは単語全体がマッチしなければハイライトされません。

@node Symbol Search
@section シンボル検索
@cindex symbol search

  @dfn{シンボル検索(symbol
search)}は、通常の検索と似ていますが、検索の境界がシンボルの境界にマッチしていなければなりません。@dfn{シンボル}の意味は、メジャーモードのコンテキストに依存しており、Emacs
LispモードでのLispシンボルのように、通常はソースコードのトークンを参照します。たとえばLispシンボル@code{forward-word}をインクリメンタルなシンボル検索すると、これは@code{isearch-forward-word}にはマッチしません。そのため、この機能は主にソースコードの検索に有用です。

@table @kbd
@item M-s _
インクリメンタル検索がアクティブのとき、シンボル検索モードに切り替えます(@code{isearch-toggle-symbol})。非アクティブのときは、前方へのインクリメンタルなシンボル検索を開始します(@code{isearch-forward-symbol})。
@item M-s .
ポイントの近くにあるシンボルを、検索文字列の初期値に追加して、前方へのインクリメンタルなシンボル検索を開始します。
@item M-s _ @key{RET} @var{symbol} @key{RET}
@var{symbol}にたいして、前方への非インクリメンタルな検索をします。
@item M-s _ C-r @key{RET} @var{symbol} @key{RET}
@var{symbol}にたいして、後方への非インクリメンタルな検索をします。
@end table

@kindex M-s _
@kindex M-s .
@findex isearch-forward-symbol
@findex isearch-forward-symbol-at-point
  前方へのインクリメンタルなシンボル検索を開始するには、@kbd{M-s _}(ポイントの近くにシンボルがあるときは@kbd{M-s
.})をタイプします。インクリメンタル検索が非アクティブのときは、コマンド@code{isearch-forward-symbol}が実行されます。すでにインクリメンタル検索がアクティブのとき、@kbd{M-s
_}は検索方向と現在の検索文字列を維持した状態で、シンボル検索に切り替えます(もう一度@kbd{M-s
_}をタイプすると、シンボル検索を無効にできます)。インクリメンタルなシンボル検索では、検索文字列の先頭がシンボルの先頭にマッチする必要があります。

  非インクリメンタルなシンボル検索は、前方への検索は@kbd{M-s _ @key{RET}}、後方への検索は@kbd{M-s _ C-r
@key{RET}}をタイプします。非インクリメンタル検索では、文字列の先頭と最後が、シンボルの先頭と最後にマッチする必要があります。

@node Regexp Search
@section 正規表現検索
@cindex regexp search
@cindex search for a regular expression

  @dfn{正規表現}(regular expression:
@dfn{regexp}と略します)とは、文字列にマッチさせるための代替の文字列クラスを示すパターンです。Emacsはregexpにマッチする検索を、インクリメンタル、非インクリメンタルの両方で提供します。正規表現の構文は、次のセクションで説明します。

@table @kbd
@item C-M-s
インクリメンタルなregexp検索を開始します(@code{isearch-forward-regexp})。
@item C-M-r
逆方向のインクリメンタルなregexp検索を開始します(@code{isearch-backward-regexp})。
@end table

@kindex C-M-s
@findex isearch-forward-regexp
@kindex C-M-r
@findex isearch-backward-regexp
  regexpにたいするインクリメンタル検索は、@kbd{C-M-s}
(@code{isearch-forward-regexp}をタイプするか、プレフィクス引数(引数の値は何でもよい)を指定して、@kbd{C-s}を呼び出します。前方へのインクリメンタル検索中は、@kbd{M-r}をタイプします。このコマンドは@kbd{C-s}と同様に、検索文字列をインクリメンタルに読みとりますが、検索文字列に正確に一致するバッファーのテキストを検索するのではなく、検索文字列をregexpとして扱います。検索文字列にテキストを追加する度に、regexpは長くなり、新しいregexpを検索します。後方へのregexp検索には、@kbd{C-M-r}(@code{isearch-backward-regexp})またはプレフィクス引数を指定した@kbd{C-r}を使います。後方へのインクリメンタル検索中は@kbd{M-r}を使います。

  通常のインクリメンタル検索の特別なキーシーケンスは、インクリメンタルなregexp検索でも同じようなことを行います。たとえば検索開始直後に@kbd{C-s}をタイプすると、最後に行ったインクリメンタル検索で使ったregexpで、前方検索を行います。インクリメンタルなregexpと非regexp検索は、独立したデフォルトを持ちます。これらは別のサーチリングも持っており、これには@kbd{M-p}と@kbd{M-n}でアクセスできます。

  通常のインクリメンタル検索とは異なり、インクリメンタルregexp検索は、デフォルトでは緩いスペースマッチング(lax space
matching)を使いません。この機能を切り替えるには、@kbd{M-s @key{SPC}}
(@code{isearch-toggle-lax-whitespace})を使います。そうするとインクリメンタルregexp検索での@key{SPC}は、1つ以上の空白文字の並びにマッチするようになります。変数@code{search-whitespace-regexp}は、緩いスペースマッチングにたいするregexpを指定します。@ref{Special
Isearch}を参照してください。

  インクリメンタルregexp検索では、検索文字列の追加によりカーソルが前に戻され、最初から検索しなおされることがありえます。たとえば検索文字列@samp{foo}に@samp{\|bar}を追加すると、カーソルは@samp{foo}から、それより前にある最初の@samp{bar}に戻ります。@ref{Regexps}を参照してください。

  前方および後方へのregexp検索は、対照的ではありません。なぜならEmacsでのregexpに対するマッチは常に前方へ処理され、regexpの先頭から開始されるからです。したがって前方へのregexp検索は前方にスキャンし、可能性のある開始位置から前方へとマッチを試みます。後方へのregexp検索は後方へスキャンし、可能性のある開始位置から前方へとマッチを試みます。これらの検索手法はミラーイメージではありません。

@findex re-search-forward
@findex re-search-backward
  regexpにたいする非インクリメンタルな検索は、コマンド@code{re-search-forward}および@code{re-search-backward}で行われます。これらのコマンドは@kbd{M-x}から呼び出すか、インクリメンタルregexp検索からの@kbd{C-M-s
@key{RET}}および@kbd{C-M-r @key{RET}}で呼び出します。

  プレフィクス引数を指定したインクリメンタルregexp検索は、@code{isearch-forward}や@code{isearch-backward}のような、通常の文字列を検索します。@ref{Incremental
Search}を参照してください。

@node Regexps
@section 正規表現の構文
@cindex syntax of regexps
@cindex regular expression
@cindex regexp

  このマニュアルでは、ユーザーが通常使う正規表現の機能を説明します。主にLispプログラムで使用される追加の機能については、@ref{Regular
Expressions,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

  正規表現は、いくつかの特殊文字と、それ以外の@dfn{普通}の文字からなる構文を持ちます。通常の文字はそれと同じ文字にマッチし、それ以外の文字にはマッチしません。特殊文字は、@samp{$^.*+?[\}です。文字@samp{]}は、文字候補を終了させる場合は特殊文字です(以下参照)。文字@samp{-}は、文字候補の中では特殊文字です。正規表現の中に現れるその他の文字は、前に@samp{\}がついてない限り普通の文字です(Lispプログラム内で正規表現を使う場合、@samp{\}は2つ記述しなければなりません。このセクションの最後にある例を参照してください)。

  たとえば@samp{f}は特殊文字ではなく普通の文字なので、正規表現中の@samp{f}は文字列@samp{f}にマッチし、他の文字列にはマッチしません(文字列@samp{ff}にはマッチ@emph{しません})。同様に正規表現中の@samp{o}は、@samp{o}だけにマッチします(大文字小文字を区別しない場合、これらのregexpは@samp{F}や@samp{O}にもマッチしますが、これを例外としてではなく、``同じ文字列''を一般化したものと考えます)。

  2つの正規表現@var{a}と@var{b}を結合できます。結合した結果は、@var{a}が先頭の適当な部分に一致して、@var{b}が残りの部分に一致する正規表現となります。たとえば@samp{f}と@samp{o}という正規表現を結合すると、正規表現@samp{fo}となり、これは文字列@samp{fo}だけにマッチします。ここまでは普通です。普通でないことを行うには、特殊文字を使う必要があります。以下にリストを示します。

@table @asis
@item @kbd{.}@: @r{(ピリオド)}
これは改行文字以外の任意の1文字にマッチする特殊文字です。たとえば正規表現@samp{a.b}は、最初が@samp{a}で最後が@samp{b}の3文字の文字列にマッチします。

@item @kbd{*}
単独では使用されません。これは接尾演算子で、前の正規表現の任意の回数、可能な限り多くの回数を含めた繰り返しを意味します。したがって@samp{o*}は任意の個数の@samp{o}にマッチし、@samp{o}がない場合(0個の場合)も含めてマッチします。

@samp{*}は常に可能な限り@emph{小さな}、前置表現に適用されます。したがって@samp{fo*}は@samp{fo}の繰り返しではなく@samp{o}の繰り返しです。この正規表現は@samp{f}、@samp{fo}、@samp{foo}、...にマッチします。

マッチングにより構成される@samp{*}は、見つけられるだけの反復回数へと、直ちに処理されます。その後でパターンの残りの部分の処理を続けます。これが失敗すると、バックトラッキングが発生します。@samp{*}の反復回数をいくつか捨てて、パターンの残りの部分がマッチするように構成を変更します。たとえば文字列@samp{caaar}にたいして@samp{ca*ar}をマッチさせる場合、まず最初に@samp{a*}を、3つすべての@samp{a}にマッチさせます。しかしパターンの残りの部分は@samp{ar}ですが、マッチさせるために残っているのは@samp{r}だけなので、このマッチは失敗します。かわりに@samp{a*}を2つの@samp{a*}だけにマッチさせます。この選択により、regexpの残りの部分のマッチが成功します。

@item @kbd{+}
これは@samp{*}と同様に接尾演算子ですが、前置表現に最低1回マッチしなければならない点が異なります。したがって@samp{ca+r}は@samp{car}、@samp{caaaar}にマッチしますが、@samp{cr}にはマッチしません。一方@samp{ca*r}は、これら3つすべての文字列にマッチします。

@item @kbd{?}
これは@samp{*}と同様に接尾演算子ですが、前置表現が1回出現するか、出現しないかいずれかという点が異なります。したがって@samp{ca?r}は、@samp{car}または@samp{cr}のいずれかになります。

@item @kbd{*?}, @kbd{+?}, @kbd{??}
@cindex non-greedy regexp matching
これらは上述した演算子の、非@dfn{貪欲(greedy)}なタイプの演算子です。通常の演算子@samp{*}、@samp{+}、@samp{?}は、regexpがマッチする、できる限り長いマッチを行います。しかしこれらの演算子に@samp{?}を後置すると、できる限り短いマッチを行います。

したがって@samp{ab*}と@samp{ab*?}は、両方とも文字列@samp{a}と文字列@samp{abbbb}にマッチしますが、文字列@samp{abbb}にマッチさせたとき、@samp{ab*}は文字列全体(有効な最長マッチ)にマッチしますが、@samp{ab*?}は@samp{a}(有効な最短マッチ)だけにマッチします。

非貪欲な演算子は、与えられた開始位置から開始される、できるだけ短い文字列にマッチします。前方検索では、利用できる一番最初の開始位置は、常にカーソルの位置となります。したがって末尾が改行のテキスト@samp{abbab}にたいして@samp{a.*?$}を検索すると、文字列全体にマッチします。これはマッチが最初の@samp{a}から開始されので、マッチさせることが@emph{できる}のです。

@item @kbd{\@{@var{n}\@}}
これは@var{n}回の繰り返しを指定する接尾演算子です。つまり前置される正規表現に、正確に@var{n}回連続でマッチしなければなりません。たとえば@samp{x\@{4\@}}は、文字列@samp{xxxx}だけにマッチします。

@item @kbd{\@{@var{n},@var{m}\@}}
これは@var{n}回から@var{m}回の繰り返しを指定する接尾演算子です。つまり前置される正規表現が、最低@var{n}回、最大@var{m}回マッチしなければなりません。@var{m}が省略されたときは、マッチ回数の上限はありませんが、前置される正規表現は少なくとも@var{n}回マッチしなければなりません。@*
@samp{\@{0,1\@}}は、@samp{?}と同じです。@* @samp{\@{0,\@}}は、@samp{*}と同じです.@*
@samp{\@{1,\@}}は、@samp{+}と同じです。

@item @kbd{[ @dots{} ]}
これは@samp{[}で始まり@samp{]}で終わる、@dfn{文字集合(character set)}です。

もっとも簡単なケースでは、2つのカッコの間に指定された文字が、マッチできる文字集合となります。したがって@samp{[ad]}は1つの@samp{a}か1つの@samp{d}にマッチし、@samp{[ad]*}は@samp{a}と@samp{d}からなる任意の文字列にマッチします(空の文字列を含む)。結果として@samp{c[ad]*r}は、@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}、...にマッチします。

文字集合には、開始文字と終了文字の間に@samp{-}を記述することにより、文字の範囲を含めることもできます。したがって@samp{[a-z]}は、@acronym{ASCII}小文字となります。文字の範囲と特定の文字の指定を混ぜることもできます。@samp{[a-z$%.]}は任意の@acronym{ASCII}小文字と@samp{$}、@samp{%}、@samp{.}にマッチします。

いくつかの特別な@dfn{文字クラス(character
classes)}を、文字集合に含めることもできます。文字の候補を含む文字クラスを@samp{[:}と@samp{:]}で囲んで指定します。たとえば@samp{[[:alnum:]]}は、任意のアルファベットと数字にマッチします。文字クラスのリストは、@ref{Char
Classes,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

文字集合に@samp{]}を含めるには、それを最初に記述しなければなりません。たとえば@samp{[]a]}は、@samp{]}または@samp{a}にマッチします。文字集合に@samp{-}を含めるには、@samp{-}を、文字集合の最初または最後に記述するか、文字範囲の外に記述します。したがって@samp{[]-]}は、@samp{]}と@samp{-}の両方にマッチします。

文字集合に@samp{^}を含めるには、集合の最初以外に記述します(最初に記述した場合、補集合を指定したことになります。以下を参照してください)。

大文字小文字を区別しない検索で文字の範囲を使う場合、範囲の先頭と最後を、大文字だけ、または小文字だけで記述するか、先頭と最後をアルファベット以外で記述するべきです。@samp{A-z}のような大文字小文字を混成した範囲指定は不正な定義で、Emacsの将来のバージョンで変更されるかもしれません。

@item @kbd{[^ @dots{} ]}
@samp{[^}は@dfn{文字の補集合complemented character
set}を開始します。つまり指定された文字以外がマッチします。したがって@samp{[^a-z0-9A-Z]}は、@acronym{ASCII}文字と数字@emph{以外}にマッチします。

@samp{^}は文字集合で最初以外で使用された場合、特別な意味をもちません。@samp{^}に続く文字は、先頭にあるものとして扱われます(いいかえると@samp{-}と@samp{]}は、ここでは特別な意味をもちません)。

もしマッチしない文字として改行が記述されていなければ、文字の補集合を改行にマッチさせることができます。これは@code{grep}のようなプログラムにおける、regexpにたいする処理とは対照的です。

@item @kbd{^}
これは空文字列、ただしテキストの行頭だけにマッチする特殊文字です。それ以外ではマッチに失敗します。したがって@samp{^foo}は行の先頭にある@samp{foo}にマッチします。

歴史的な互換性により、この意味での@samp{^}の使用は、正規表現の先頭か、@samp{\(}または@samp{\|}の後に記述された場合に限ります。

@item @kbd{$}
@samp{^}と似ていますが、行末だけにマッチします。したがって@samp{x+$}は、行末にある1つ以上の@samp{x}にマッチします。

歴史的な互換性により、この意味での@samp{$}の使用は、正規表現の最後か、@samp{\)}または@samp{\|}の後に記述された場合に限ります。

@item @kbd{\}
これには2つの機能があります。まず特殊文字(@samp{\}を含む)をクォートすることと、追加の特別な構成を導入することです。

@samp{\}は特殊文字をクォートするので、正規表現中の@samp{\$}は@samp{$}だけにマッチし、@samp{\[}は@samp{[}だけにマッチします。

@samp{\}で始まる特別な構成については、以下のセクションを参照してください。
@end table

  注意:
歴史的な互換性から、特殊文字はそれが特殊な意味をもたないようなコンテキストで使用された場合は、通常の文字として扱われます。たとえば@samp{*foo}は、@samp{*}が特殊文字として動作するための前置された表現がないので、普通の文字として扱われます。このような振る舞いに依存することは、よい習慣ではありません。特殊文字を記述する場合、それがどこに記述されようとクォートするべきです。

文字集合の候補中では@samp{\}は特別ではなく、@samp{-}と@samp{]}のもつ特別な意味を除去することはありません。したがって、これらの文字が特別な意味をもたないような場所にあるときは、これらの文字をクォートすべきではありません。これでは明確ではないかもしれません。これらの特殊文字が特別な意味を@emph{もつ}場所にあるとき、バックスラッシュを前置することによりクォートされるのです。たとえば@samp{[^\]}(Lispの文字記法では@code{"[^\\]"})は、バックスラッシュ以外の任意の一文字にマッチします。

@node Regexp Backslash
@section 正規表現でのバックスラッシュ

  多くの場合、任意の文字を伴う@samp{\}はその文字だけに一致します。しかしいくつか例外があって、@samp{\}で始まる2文字のシーケンスが、特別な意味を持つ場合があります。シーケンス内の2文字目にくる文字は、単独で使った場合には普通の文字として扱われるものです。以下は@samp{\}の構成の表です。

@table @kbd
@item \|
選択肢を指定します。2つの正規表現@var{a}と@var{b}の間に@samp{\|}を記述すると、それは@var{a}または@var{b}のいずれかにマッチする表現を形成します。これはまず@var{a}とのマッチを試み、失敗した場合に@var{b}とのマッチを試みます。

したがって@samp{foo\|bar}は、@samp{foo}または@samp{bar}のいずれかにマッチし、それ以外の文字列にはマッチしません。

@samp{\|}は、周囲の一番大きな表現に適用されます。@samp{\|}のグループ化の能力に制限をかけることができるのは、周囲の@samp{\(
@dots{} \)}によるグループ化だけです。

複数の@samp{\|}使用を処理するための、完全なバックトラッキング能力が存在します。

@item \( @dots{} \)
3つの目的のためのグループ化構成です:

@enumerate
@item
他の操作に使うために、一連の選択肢@samp{\|}を括ります。したがって@samp{\(foo\|bar\)x}は、@samp{foox}または@samp{barx}のいずれかにマッチします。

@item
接尾演算子@samp{*}、@samp{+}、@samp{?}を適用できるように、複雑な正規表現を括ります。したがって@samp{ba\(na\)*}は、@samp{bananana}のように、(0個以上の)文字列@samp{na}にマッチします。

@item
あとで参照できるように、マッチした部分文字列を記録します。
@end enumerate

この最後の使い方は、カッコでグループ化することが重要なのではありません。これは@samp{\( @dots{}
\)}構成の、2番目の意味とは異なる機能です。実際には、これら2つの機能が衝突することは、通常はありません。もし衝突するようなら、``内気(shy)''なグループ化を使うことができます。

@item \(?: @dots{} \)
@cindex shy group, in regexp
マッチした部分文字列を記録しない、``内気(shy)''なグループ化を指定します。マッチした部分文字列は、@samp{\@var{d}}により後方参照できません。この機能は正規表現を機械的にまとめるときに役立ちます。これにより後方参照するためのグループにたいする番号づけに影響することなく、文法的な目的によるグループ化を行うことができます。

@item \@var{d}
@cindex back reference, in regexp
@var{d}番目に@samp{\( @dots{} \)}構成にマッチしたテキストと同じテキストにマッチします。これは@dfn{後方参照(back
reference)}と呼ばれます。

最後の@samp{\( @dots{}
\)}構成の後で、マッチ処理はこの構成にマッチしたテキストの最初と最後を記録します。そして正規表現の後の部分で@samp{\}の後に数字@var{d}を使うことにより、@var{d}番目の@samp{\(
@dots{} \)}構成にマッチしたテキストと同じテキストにマッチさせることができます。

正規表現に記述された最初の9つの@samp{\( @dots{}
\)}にマッチしたテキストは、正規表現で開きカッコが出現した順に、1から9までの数字が割り当てられます。そのため@samp{\1}から@samp{\9}を使うことにより、@samp{\(
@dots{} \)}構成にマッチした、対応するテキストを参照することができます。

たとえば@samp{\(.*\)\1}は改行を含まない、前半と後半が同一の文字列にマッチします。@samp{\(.*\)}は、そのテキストが何であろうと前半にマッチしますが、@samp{\1}は前半と正確に同じテキストにマッチしなければなりません。

もし特定の@samp{\( @dots{}
\)}構成が１回以上マッチする場合(これは@samp{*}が後置されているとき簡単に発生します)、最後のマッチだけが記録されます。

@item \`
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の先頭に限定されます。

@item \'
空の文字列にマッチしますが、文字列またはバッファー(またはアクセスできる部分)の最後に限定されます。

@item \=
空の文字列にマッチしますが、ポイント位置に限定されます。

@item \b
空の文字列にマッチしますが単語の先頭または最後に限定されます。したがって@samp{\bfoo\b}は、区切られた単語@samp{foo}にマッチします。@samp{\bballs?\b}は、別々の単語@samp{ball}または@samp{balls}にマッチします。

@samp{\b}は、そこにどんなテキストが出現しようと、バッファーの先頭または最後にもマッチします。

@item \B
空の文字列にマッチしますが、単語の最初と最後@emph{以外}にマッチします。

@item \<
空の文字列にマッチしますが、単語の先頭に限定されます。@samp{\<}は単語の構成文字が続く場合に限り、バッファーの先頭にマッチします。

@item \>
空の文字列にマッチしますが、単語の最後に限定されます。@samp{\<}は内容が単語の構成文字で終わる場合に限りバッファーの最後にマッチします。

@item \w
任意の単語構成文字にマッチします。どの文字が該当するかは、構文テーブル(syntax table)により決定されます。@ref{Syntax
Tables,, Syntax Tables, elisp, The Emacs Lisp Reference Manual}を参照してください。

@item \W
単語構成文字以外の任意の文字にマッチします。

@item \_<
空の文字列にマッチしますが、シンボルの先頭に限られます。シンボルは１文字以上のシンボル構成文字からなります。シンボル構成文字は、@samp{w}と@samp{_}の構文をもつ文字です。@samp{\_<}はシンボル構成文字が続く場合に限り、バッファーの先頭にもマッチします。

@item \_>
空の文字列にマッチしますが、シンボルの最後に限定されます。@samp{\_>}は内容がシンボル構成文字で終わる場合に限り、バッファーの最後にマッチします。

@item \s@var{c}
構文が@var{c}である、任意の文字にマッチします。ここで@var{c}とは、特定の構文クラスを表す文字です。したがって@samp{w}は単語構成文字、@samp{-}または@samp{
}は空白文字、@samp{.}は通常の区切り文字、などとなります。@ref{Syntax Tables,, Syntax Tables, elisp,
The Emacs Lisp Reference Manual}を参照してください。

@item \S@var{c}
構文が@var{c}以外の、任意の文字にマッチします。

@cindex categories of characters
@cindex characters which belong to a specific language
@findex describe-categories
@item \c@var{c}
カテゴリー@var{c}に属する、任意の文字にマッチします。たとえば@samp{\cc}は中国文字、@samp{\cg}はギリシャ文字にマッチします。既知のカテゴリーについての説明は、@kbd{M-x
describe-categories @key{RET}}をタイプしてください。

@item \C@var{c}
カテゴリー@var{c}に@emph{属さない}、任意の文字にマッチします。
@end table

  単語と構文に関係する構成は構文テーブルのセッティングにより制御されます。@xref{Syntax Tables,, Syntax Tables,
elisp, The Emacs Lisp Reference Manual}.

@node Regexp Example
@section 正規表現の例

  以下にregexpの例を示します。これはEmacsがセンテンスの最後(末尾の空白は含まない)を認識するために、デフォルトで使用するregexp(たとえば変数@code{sentence-end-base})と似ています。

@example
@verbatim
[.?!][]\"')}]*
@end verbatim
@end example

@noindent
これには2つの連続する部分があります。1つは@samp{.}、@samp{?}、@samp{!}にマッチする文字です。もう1つは閉じカッコ、クォート、カッコの0回以上の繰り返しです。

@node Search Case
@section 検索と大文字小文字

  Emacsでの検索では、テキストを小文字で指定した場合、通常は検索するテキストの大文字小文字は区別されません。したがって@samp{foo}を検索すると、@samp{Foo}や@samp{foo}もマッチします。regexp、特に文字集合でも同様に振る舞います。つまり@samp{[ab]}は、@samp{a}、@samp{A}、@samp{b}、@samp{B}もマッチします。

  インクリメンタル検索する文字列のどこかに大文字があると、検索は大文字小文字を区別するようになります。したがって@samp{Foo}を検索すると、@samp{foo}や@samp{FOO}は検索されません。これは正規表現検索でも文字列検索と同様に適用されます。検索文字列から大文字を削除すると、効果はなくなります。

@vindex case-fold-search
  変数@code{case-fold-search}に@code{nil}をセットすると、すべての文字は大文字小文字を含めて、完全にマッチしなければなりません。これはバッファーごとの変数で、変数の変更はデフォルト値を変えない限り、通常はカレントバッファーだけが影響を受けます。@ref{Locals}を参照してください。これは置換コマンド(@ref{Replace}を参照してください)や、ミニバッファーのヒストリー検索(@ref{Minibuffer
History}を参照してください)を処理する、非インクリメンタル検索にも適用されます。

@c isearch-toggle-case-fold
  インクリメンタル検索で@kbd{M-c}をタイプすると、検索が大文字小文字を区別するかが、切り替わります。この効果は、現在の検索を超えて次の検索には引き継がれませんが、現在の検索にたいして大文字を追加・削除したときの効果をオーバーライドします.

  特定のコマンドや操作にたいする検索やマッチングにおいて、大文字小文字の区別を制御する変数がいくつかあります。たとえば@code{tags-case-fold-search}は、@code{find-tag}での大文字小文字の区別を制御します。これらの変数を探すには、@kbd{M-x
apropos-variable @key{RET} case-fold-search @key{RET}}とタイプしてください。

@node Replace
@section 置換コマンド
@cindex replacement
@cindex search-and-replace commands
@cindex string substitution
@cindex global substitution

  Emacsは検索と置換を行うコマンドをいくつか提供します。単純な@kbd{M-x
replace-string}コマンドに加えて、出現するパターンごとに置換するかを問い合わせる@kbd{M-%}
(@code{query-replace})も提供します。

  通常、置換コマンドはポイント位置から、バッファーの最後までのテキストにたいして、処理を行います。リージョンがアクティブのときは、リージョンにたいして処理を行います(@ref{Mark}を参照してください)。基本的な置換コマンドは1つの@dfn{検索文字列}(またはregexp)を、1つの@dfn{置換文字列}で置き換えます。コマンド@code{expand-region-abbrevs}を使用して、複数の置換を並行して処理することが可能です(@ref{Expanding
Abbrevs}を参照してください)。

@vindex replace-lax-whitespace
  インクリメンタル検索とは異なり、置換コマンドはデフォルトでは緩いスペースマッチング(lax space
matching)を行いません(@ref{Special
Isearch}を参照してください)。置換で緩いスペースマッチングを有効にするには、変数@code{replace-lax-whitespace}を@code{t}に変更してください(これはEmacsが置換文字列ではなく、置換するテキストを検索する方法だけに影響を与えます)。

@menu
* Unconditional Replace::    文字列にマッチするすべて置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Case::     置換が大文字小文字を維持する方法。
* Query Replace::            問い合わせの使い方。
@end menu

@node Unconditional Replace
@subsection 無条件の置換
@findex replace-string

@table @kbd
@item M-x replace-string @key{RET} @var{string} @key{RET} @var{newstring} @key{RET}
すべての@var{string}を@var{newstring}で置換します。
@end table

  ポイントの後にある@samp{foo}のすべてのインスタンスを@samp{bar}に置換するには、コマンド@kbd{M-x
replace-string}に2つの引数@samp{foo}と@samp{bar}を指定します。置換はポイントの後だけで発生するので、バッファー全体を置換したい場合は、最初にバッファーの先頭に移動しなければなりません。バッファーの最後までのすべてが置換されます。置換をバッファーの一部に制限したいときは、そのリージョン部分をアクティブにします。リージョンがアクティブのときは、置換はそのリージョンに制限されます(@ref{Mark}を参照してください)。

  @code{replace-string}が終了したとき、ポイントは最後に置換された位置に留まります。以前のポイント位置(@code{replace-string}コマンドを実行した場所)はマークリングに追加されるので(マークは非アクティブ)、@kbd{C-u
C-@key{SPC}}で戻ることができます。@ref{Mark Ring}を参照してください。

  プレフィクス引数を指定すると、置換対象は単語単位に制限されます。

  置換コマンドでの大文字小文字の区別については、@ref{Replacement and Case}を参照してください。

@node Regexp Replace
@subsection 正規表現の置換
@findex replace-regexp

  @kbd{M-x replace-string}コマンドは、正確にマッチする単一の文字列を置換します。コマンド@kbd{M-x
replace-regexp}は指定したパターンにマッチするすべてを置換します。

@table @kbd
@item M-x replace-regexp @key{RET} @var{regexp} @key{RET} @var{newstring} @key{RET}
@var{regexp}にマッチするすべてを@var{newstring}で置換します。
@end table

@cindex back reference, in regexp replacement
  @code{replace-regexp}では、@var{newstring}が定数である必要はありません。@var{regexp}にマッチした全体、または部分を参照することができます。@var{newstring}での@samp{\&}は、置換されるマッチ全体を表します。@var{newstring}での@samp{\@var{d}}(@var{d}は数字)は、@var{regexp}内でカッコでグループ化されたものの、@var{d}番目にマッチします(これは``後方参照(back
reference)と呼ばれます'')。@samp{\#}は、このコマンドですでに置換された件数を10進数で参照します。最初の置換では@samp{\#}は@samp{0}で、2番目の置換では@samp{1}、...のようになります。たとえば、

@example
M-x replace-regexp @key{RET} c[ad]+r @key{RET} \&-safe @key{RET}
@end example

@noindent
これは@samp{cadr}を@samp{cadr-safe}に、@samp{cddr}を@samp{cddr-safe}に置き換えます。

@example
M-x replace-regexp @key{RET} \(c[ad]+r\)-safe @key{RET} \1 @key{RET}
@end example

@noindent
これは逆向きの置換をします。置換するテキストに@samp{\}を含めるときは、@samp{\\}と入力しなければなりません。

  置換する文字列の一部を毎回手入力したいときは、置換文字列で@samp{\?}を使用します。すると置換ごとにミニバッファーで置換文字列を編集できます(ポイント位置は@samp{\?}を記述した場所です。)

  このサブセクションの残りの部分は、Lispの知識が必要となる特別な処理を念頭に書かれています。大半の読者はスキップしても構いません。

  置換文字列の一部を計算するために、Lisp式を使うことができます。これを行うには、置換文字列の中で、@samp{\,}に続けてLisp式を記述します。各置換において式の値が計算され、それをクォートされていない文字列に変換します(もし文字列の場合は、その文字列の内容が使われることを意味します)。そしてそれを置換文字列内で、式が記述された場所に使用します。もし式がシンボルのときは、シンボル名と、置換文字列中のシンボル名の後にあるの間に1つスペースは、両方シンボルの値に置換されます。

  このような式の中では、いくつかの特別なシーケンスを使うことができます。式の中での@samp{\&}や@samp{\@var{n}}は、通常のようにマッチした文字列全体と、部分マッチした文字列を参照します。@var{n}には複数桁の数字を記述でき、@var{n}番目の正規表現がマッチしなかったとき、@samp{\@var{n}}は@code{nil}になります。@samp{\#&}と@samp{\#@var{n}}を使って、それらのマッチを数字で参照することもできます(これはマッチまたは部分マッチが数字書式の場合に有効です)。ここでの@samp{\#}も、すでに置換された数を意味します。

  @samp{x}と@samp{y}の入れ替えは、以下の方法で行うことができます:

@example
M-x replace-regexp @key{RET} \(x\)\|y @key{RET}
\,(if \1 "y" "x") @key{RET}
@end example

  @samp{\,}により置換する文字列を計算するには、@code{format}関数が便利なときがあります(@ref{Formatting
Strings,,, elisp, The Emacs Lisp Reference
Manual}を参照してください)。たとえば73列目@w{から80列目}(もしそこに何もなければ)に、@samp{ABC00042}のような連番を振りたいときは、以下を使うことができます。

@example
M-x replace-regexp @key{RET} ^.\@{0,72\@}$ @key{RET}
\,(format "%-72sABC%05d" \& \#) @key{RET}
@end example

@node Replacement and Case
@subsection 置換コマンドと大文字小文字

  置換コマンドの最初の引数がすべて小文字の場合、置換のための検索において大文字小文字の違いを無視します。これは@code{case-fold-search}が非@code{nil}の場合です。@code{case-fold-search}を@code{nil}にセットすると、すべての検索において常に大文字小文字の違いが有効になります。

@vindex case-replace
  さらに@var{newstring}のすべて、または一部が小文字の場合、置換コマンドは大文字小文字が出現するパターンを維持しようと試みます。したがって以下のコマンド、

@example
M-x replace-string @key{RET} foo @key{RET} bar @key{RET}
@end example

@noindent
は小文字の@samp{foo}を小文字の@samp{bar}で置換し、すべて大文字の@samp{FOO}を@samp{BAR}、そして最初が大文字の@samp{Foo}を@samp{Bar}に置換します。(これら3つの候補、すなわち小文字、すべて大文字、先頭が大文字は、@code{replace-string}が認識できる唯一のパターンです)。

  置換文字列に大文字が使われている場合、テキストが挿入されるときは、常に大文字のままとなります。大文字が最初の引数で使用されている場合、大文字小文字の変換なしで、2番目の引数に与えられたとおりに置換されます。同様に@code{case-replace}と@code{case-fold-search}の両方が@code{nil}にセットされている場合、大文字小文字の変換なしで置換されます。

@node Query Replace
@subsection 問い合わせつき置換
@cindex query replace

@table @kbd
@item M-% @var{string} @key{RET} @var{newstring} @key{RET}
任意の@var{string}を@var{newstring}で置換します。
@item C-M-% @var{regexp} @key{RET} @var{newstring} @key{RET}
@var{regexp}にたいする任意のマッチを@var{newstring}で置換します。
@end table

@kindex M-%
@findex query-replace
  @samp{foo}を@samp{bar}に置換するとき、すべてではなく、そのうちのいくつかだけを置換したいときは、@kbd{M-%}
(@code{query-replace})を使います。このコマンドは@samp{foo}を1つずつ検索して、それを置換するかを毎回尋ねます。この問い合わせを別とすれば、@code{query-replace}は@code{replace-string}と同様に機能します(@ref{Unconditional
Replace}を参照してください)。通常のように、@code{case-replace}が非@code{nil}のときは、大文字小文字を区別します(@ref{Replacement
and Case}を参照してください)。数引数を指定すると、単語区切り文字で区切られた単語だけを考慮します。負のプレフィクス引数は後方に置換します。

@kindex C-M-%
@findex query-replace-regexp
  @kbd{C-M-%}
(@code{query-replace-regexp})は、regexpの検索と置換を行います。これは@code{query-replace}のように問い合わせを行う以外は、@code{replace-regexp}と同様に機能します。

@cindex faces for highlighting query replace
@cindex query-replace face
@cindex lazy-highlight face
  これらのコマンドは、カレントのマッチを、フェイス@code{query-replace}を使ってハイライトします。他のマッチのハイライトにはインクリメンタル検索と同様に、フェイス@code{lazy-highlight}が使われます(@ref{Incremental
Search}を参照してください)。デフォルトでは@code{query-replace-regexp}は、カレントマッチを置換する展開後の文字列を、ミニバッファーに表示します。特別なシーケンス@samp{\&}および@samp{\@var{n}}を展開せずに維持するには、@code{query-replace-show-replacement}変数をカスタマイズしてください。

  以下は文字列またはregexpにたいするマッチが表示されているときにタイプできる文字です:

@ignore @c Not worth it.
@kindex SPC @r{(query-replace)}
@kindex DEL @r{(query-replace)}
@kindex , @r{(query-replace)}
@kindex RET @r{(query-replace)}
@kindex . @r{(query-replace)}
@kindex ! @r{(query-replace)}
@kindex ^ @r{(query-replace)}
@kindex C-r @r{(query-replace)}
@kindex C-w @r{(query-replace)}
@kindex C-l @r{(query-replace)}
@end ignore

@c WideCommands
@table @kbd
@item @key{SPC}
マッチを@var{newstring}で置き換えます。

@item @key{DEL}
カレントマッチを置換せずに次のマッチへスキップします。

@item , @r{(カンマ)}
カレントマッチを置換して、結果を表示します。そして次に何をするかを文字入力するよう促します。置換がすでに行われているので、この状況では@key{DEL}と@key{SPC}は等価で、どちらも次のマッチへ移動します。

ここで@kbd{C-r}(以下を参照)をタイプして、置換されたテキストを編集できます。@kbd{C-x
u}をタイプして、置換を取り消すこともできます。これは@code{query-replace}を終了させるので、さらに置換を行う場合は、@kbd{C-x
@key{ESC} @key{ESC} @key{RET}}で置換を再開しなければなりません(@ref{Repetition}を参照してください)。

@item @key{RET}
これ以上の置換を行わずに終了します。

@item .@: @r{(ピリオド)}
カレントマッチを置換してから、これ以上の検索を行わずに終了します。

@item !
これ以上の問い合わせをせずに、残りのマッチをすべて置換します。

@item Y @r{(大文字)}
複数バッファーの置換で、残りのバッファーの、残りのマッチをすべて置換します(これは選択したファイルにたいして問い合わせつきの置換を行う、Diredの@key{Q}コマンドと似ています)。これはすべての一連の問い合わせにたいして、これ以上のユーザーとの対話なしに"yes"を答えます。

@item N @r{(大文字)}
複数バッファーの置換で、カレントバッファーの残りのマッチを置換せずに、次のバッファーへスキップします。これはカレントバッファーのマッチにたいする問い合わせに"no"を答えて、次のバッファーへと処理を続けます。

@item ^
前のマッチの位置に戻ります。これは間違えて変更したときや、再検証したい場合に使います。

@item C-r
再帰編集レベル(recursive editing
level)に入ります。これはマッチを@var{newstring}で置換するだけでなく、編集したい場合に使用します。編集を終えたら@kbd{C-M-c}で再帰編集レベルを抜けて、次のマッチを処理します。@ref{Recursive
Edit}を参照してください。

@item C-w
マッチを削除してから、@kbd{C-r}と同様に再帰編集レベルに入ります。これは@var{string}を削除してから、テキストを挿入することにより置換を行う場合に使用します。編集を終えたら@kbd{C-M-c}で再帰編集レベルを抜けて、次のマッチを処理します。

@item e
置換文字列をミニバッファーで編集します。@key{RET}でミニバッファーを抜けると、カレントマッチをミニバッファーの内容で置換します。この新しい置換文字列は、残りのマッチにたいしても適用されます。

@item C-l
スクリーンを再描画します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。

@item C-h
上述したオプションの要約を表示します。その後でカレントマッチにたいして何を行うか、別の文字をタイプして指定しなければなりません。
@end table

  上述した文字以外は、上述の文字リストのエイリアスです。たとえば@kbd{y}、@kbd{n}、@kbd{q}は、@key{SPC}、@key{DEL}、@key{RET}と等価です。

  これらのエイリアス文字以外の文字は、@code{query-replace}を終了してから、キーシーケンスの残りの部分を読みとります。したがって@kbd{C-k}とタイプすると、@code{query-replace}を終了してから、行末までをkillします。

  一度終了した@code{query-replace}を再開するには、@kbd{C-x @key{ESC}
@key{ESC}}を使います。@code{query-replace}は引数の読み取りにミニバッファーを使っているので、このキーシーケンスで再開させることができます。@ref{Repetition,
C-x ESC ESC}を参照してください。

@cindex invisible text, and query-replace
  オプション@code{search-invisible}は、@code{query-replace}が非表示のテキストを扱う方法を決定します。@ref{Outline
Search}を参照してください。

  選択されたファイルにたいして問い合わせつきの置換を行う、Diredの@kbd{Q}コマンドについては、@ref{Operating on
Files}を参照してください。regexpにマッチするファイル名にたいして、ファイル名の変更、ファイルのコピー、ファイルのリンクを行うDiredのコマンドについては、@ref{Transforming
File Names}を参照してください。

@node Other Repeating Search
@section その他の検索およびループコマンド

  ここでは正規表現にたいするマッチを検索する、その他のコマンドを説明します。これらのコマンドは、パターンに大文字が含まれていないカ、@code{case-fold-search}が非@code{nil}のときは、マッチングで大文字小文字を区別しません。@code{occur}とその変種をのぞき、これらはすべて、ポイント位置からバッファーの最後まで、リージョンがアクティブなときはリージョンにたいして処理を行います。

@findex list-matching-lines
@findex occur
@findex multi-occur
@findex multi-occur-in-matching-buffers
@findex how-many
@findex flush-lines
@findex keep-lines

@table @kbd
@item M-x multi-isearch-buffers
１つ以上のバッファー名の入力を求め(@key{RET}で終了)、それらのバッファーにたいして複数バッファーのインクリメンタル検索を開始します(あるバッファーでの検索に失敗すると、次の@kbd{C-s}により、指定された次のバッファーへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を求め、regexpにマッチするバッファーにたいして、複数バッファーでのインクリメンタル検索を開始します。

@item M-x multi-isearch-buffers-regexp
このコマンドは@code{multi-isearch-buffers}と同様ですが、インクリメンタルなregexp検索を行います。

@cindex Occur mode
@cindex mode, Occur
@item M-x occur
regexpの入力を求め、それへのマッチを含むバッファー内の各行を一覧表示します。検索をバッファーの一部に制限するには、その部分にナローイングします(@ref{Narrowing}を参照してください)。数引数@var{n}を指定すると、そのコンテキストでマッチした各行の、前後@var{n}行を表示します。

@kindex RET @r{(Occur mode)}
@kindex o @r{(Occur mode)}
@kindex C-o @r{(Occur mode)}
@file{*Occur*}バッファーでは、エントリーをクリックするか、ポイントをそこに移動して@key{RET}をタイプすることにより、検索されたバッファーの対応する位置をvisitします。@kbd{o}と@kbd{C-o}はマッチを他のウィンドウに表示します(@kbd{C-o}はそのウィンドウを選択しません)。かわりに@kbd{C-x
`} (@code{next-error})コマンドを使うことにより、マッチした場所を1つ1つvisitできます(@ref{Compilation
Mode}を参照してください)。

@cindex Occur Edit mode
@cindex mode, Occur Edit
@file{*Occur*}バッファーで@kbd{e}をタイプすることにより、Occur
Editモードに切り替えます。このモードではエントリーにたいする編集結果が、元のバッファーのテキストに適用されます。@kbd{C-c
C-c}とタイプすることにより、Occurモードに戻ります。

コマンド@kbd{M-x list-matching-lines}は、@kbd{M-x occur}の別名です。

@kindex M-s o
@item M-s o
最後にインクリメンタル検索で使った文字列を検索文字列として、@code{occur}を実行します。インクリメンタル検索がアクティブのときは@kbd{M-s
o}を実行して、カレントのサーチリングを使うこともできます。

@item M-x multi-occur
このコマンドは@code{occur}と同じですが、複数のバッファーを検索する点が異なります。このコマンドは、1つずつバッファー名の入力を求めます。

@item M-x multi-occur-in-matching-buffers
このコマンドは@code{multi-occur}と似ていますが、visitしているファイル名にマッチする正規表現を指定することにより、検索するバッファーを指定する点が異なります。プレフィクス引数を指定すると、正規表現にマッチするバッファー名となります。

@item M-x how-many
regexpの入力を求め、バッファーのポイント位置以降に、何個のマッチがあるか表示します。リージョンがアクティブのときは、リージョンにたいして操作を行います。

@item M-x flush-lines
regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチが含まれている行を削除します。カレント行のポイント以降にマッチする文字列が含まれているときは、カレント行を削除します。リージョンがアクティブのときは、リージョンにたいして操作を行います。行の一部ににリージョンが含まれていて、さらにマッチの全体がリージョンに含まれているとき、その行は削除されます。

マッチが行をまたいでいる場合、@code{flush-lines}はそれらの行すべてを削除します。このコマンドは行を削除してから、次のマッチを検索します。したがって、1行にマッチ全体と、次の行にまたがるマッチが両方含まれるとき、次の行にまたがるマッチは無視されます。

@item M-x keep-lines
regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチを@emph{含まない}行を削除します。ポイントが行の先頭でない場合、このコマンドは常にカレント行を維持します。リージョンがアクティブのときは、リージョンにたいして操作を行います。このコマンドは一部がリージョンに含まれるだけの行は削除しません(行を終端する改行は、その行の一部と判断します)。

マッチが行をまたぐ場合、このコマンドはそれらすべての行を維持します。
@end table
