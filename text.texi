@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2000-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@node Text
@chapter Commands for Human Languages
@cindex text
@cindex manipulating text

  このチャプターでは@dfn{テキスト(text)} ---
人間の言語(対照的なものとしてコンピューターのプログラム言語があります)における、文字シーケンスという意味 ---
にたいして動作する、Emacsコマンドを説明します。これらコマンドは、人間の言語の構文および文体の規則に配慮した方法で動作します。単語、センテンス(文)、パラグラフ(段落)、大文字に関する規則があります。@dfn{フィル(filling)}
--- パラグラフの行をおおよそ同じ長さに再配置するという意味 ---
を行うコマンドもあります。これらのコマンドは主にテキストの編集を意図しており、プログラムの編集にも便利なときがあります。

  Emacsには、人間言語のテキストを編集するためのメジャーモードがいくつかあります。ファイルが普通のテキストを含む場合は、Textモードを使います。これはEmacsを、テキストの構文規則にたいして少しカスタマイズしたものです。Outlineモードは。アウトライン構造でテキストを操作する特別なコマンドを提供します。Orgモードは、Outlineモードを拡張してEmacsを本格的なオーガナイザーに変えます。これによりTODOリストを管理したり、ノートを保存して、それを多くのフォーマットで公開することができます。

@iftex
@ref{Outline Mode}を参照してください。
@end iftex

@cindex nXML mode
@cindex mode, XML
@cindex mode, nXML
@findex nxml-mode
  Emacsには@TeX{}や@LaTeX{} (@ref{TeX Mode}を参照してください)、HTMLやSGML (@ref{HTML
Mode}を参照してください)、XML
@ifinfo
(@ref{Top,The nXML Mode Manual,,nxml-mode, nXML Mode}を参照してください)、
@end ifinfo
@ifnotinfo
(Emacsと共に配布されるnXLMモードのマニュアルを参照してください)、
@end ifnotinfo
GroffやNroff (@ref{Nroff
Mode}を参照してください)のような、コマンドが``埋め込まれた''テキストのための、他のメジャーモードがあります。

@cindex ASCII art
  テキスト文字で作られた絵(一般的には``ASCII
art''と呼ばれます)を編集する必要がある場合は、そのような絵を編集するための特別なメジャーモードのPictureモードを使用します
@iftex
@ref{Picture Mode,,, emacs-xtra, Specialized Emacs Features}を参照してください。
@end iftex
@ifnottex
@ref{Picture Mode}を参照してください。
@end ifnottex

@ifinfo
@cindex skeletons
@cindex templates
@cindex autotyping
@cindex automatic typing
  テキストを記述するときは、``自動タイピング''の機能が便利でしょう。@inforef{Top,The Autotype
Manual,autotype}を参照してください。
@end ifinfo

@menu
* Words::                    単語単位の移動とkill。
* Sentences::                センテンス単位の移動とkill。
* Paragraphs::               パラグラフ単位の移動。
* Pages::                    ページ単位の移動。
* Filling::                  テキストのフィルと調整。
* Case::                     テキストの大文字小文字の変更。
* Text Mode::                テキストファイルを編集するためのメジャーモード。
* Outline Mode::             アウトラインの編集。
* Org Mode::                 Emacsオーガナイザー。
* TeX Mode::                 TeXおよびLaTeXファイルの編集。
* HTML Mode::                HTMLおよびSGMLファイルの編集。
* Nroff Mode::               nroffフォーマッターへの入力の編集。
* Enriched Text::            フォント、カラーなどでenrichedテキストを編集する。
* Text Based Tables::        テキストベースのテーブルを編集するためのコマンド。
* Two-Column::               テキスト列を分割して別のウィンドウに表示する。
@end menu

@node Words
@section Words
@cindex words
@cindex Meta commands and words

  Emacsは、単語単位で移動するコマンドをいくつか定義しています:

@table @kbd
@item M-f
1単語前方に移動します(@code{forward-word})。
@item M-b
1単語後方に移動します(@code{backward-word})。
@item M-d
単語の最後までkillします(@code{kill-word})。
@item M-@key{DEL}
単語の先頭までkillします(@code{backward-kill-word})。
@item M-@@
次の単語の最後をマークします(@code{mark-word})。
@item M-t
2つの単語を入れ替える、または他の単語を飛び越えて単語をドラッグします(@code{transpose-words})。
@end table

  これらのキーは文字単位のコマンド@kbd{C-f}、@kbd{C-b}、@kbd{C-d}、@key{DEL}、@kbd{C-t}に類似していることに注目してください。@kbd{M-@@}は@kbd{C-@@}(これは@kbd{C-@key{SPC}}の別名です)が由来です。

@kindex M-f
@kindex M-b
@findex forward-word
@findex backward-word
  コマンド@kbd{M-f} (@code{forward-word})および@kbd{M-b}
(@code{backward-word})は、単語単位で前方または後方に移動します。これらの@key{META}ベースのキーシーケンスは、1文字単位で移動するキーシーケンス@kbd{C-f}および@kbd{C-b}に類似しています。類似点は数引数にも拡張されます。これらは繰り返し回数を指定します。@kbd{M-f}に負の引数を与えると後方に移動し、@kbd{M-b}に負の引数を与えると前方に移動します。前方への移動は単語の最後の文字の直後で停止し、後方への移動は、最初の文字の直前で停止します。

@kindex M-d
@findex kill-word
  @kbd{M-d}
(@code{kill-word})は、ポイントの後ろの単語をkillします。正確に言うと、ポイントから、@kbd{M-f}で移動する位置までのすべてをkillします。したがってポイントが単語の途中にある場合、@kbd{M-d}はポイントの後だけをkillします。ポイントと次の単語の間に区切り文字がある場合、それは単語と一緒にkillされます（次の単語だけをkillして、その前にある区切り文字はkillしたくないときは、@kbd{M-f}で最後まで移動して、@kbd{M-@key{DEL}}で単語を後方にkillします)。@kbd{M-d}は@kbd{M-f}と同様の引数を取ります。

@findex backward-kill-word
@kindex M-DEL
  @kbd{M-@key{DEL}}
(@code{backward-kill-word})は、ポイントの前の単語をkillします。これはポイントから、@kbd{M-b}で移動する位置までのすべてをkillします。たとえばポイントが@w{@samp{FOO,
BAR}}のスペースの後ろにある場合、これは@w{@samp{FOO,
}}をkillします。@samp{FOO}だけをkillして、カンマとスペースは残したい場合は、@kbd{M-@key{DEL}}のかわりに@kbd{M-b
M-d}を使用します。

@c Don't index M-t and transpose-words here, they are indexed in
@c fixit.texi, in the node "Transpose".
@c @kindex M-t
@c @findex transpose-words
  @kbd{M-t}
(@code{transpose-words})は、ポイントの前またはポイントを含む単語を、次の単語と交換します。単語間の区切り文字は移動されません。たとえば@w{@samp{FOO,
BAR}}は、@samp{@w{BAR FOO,}}ではなく、@w{@samp{BAR,
FOO}}に入れ替えられます。入れ替えについては、@ref{Transpose}を参照してください。

@kindex M-@@
@findex mark-word
  リージョンにたいして操作を行う際、単語単位で操作したいときは、コマンド@kbd{M-@@}
(@code{mark-word})を使用します。このコマンドは@kbd{M-f}で移動する位置にマークをセットします。このコマンドにつての詳しい詳細は、@ref{Marking
Objects}を参照してください。

  単語にたいするコマンドが理解する単語境界は、構文テーブル(syntax
table)で制御されます。単語の区切り文字に、(たとえば)任意の文字を使うことができます。@ref{Syntax Tables,, Syntax
Tables, elisp, The Emacs Lisp Reference Manual}を参照してください。

  以上に加えて、リージョンまたはバッファーに含まれる単語数のカウントとリポートを行う@kbd{M-=}
(@code{count-words-region})および@kbd{M-x count-words}コマンドについては、@ref{Position
Info}を参照してください。

@node Sentences
@section Sentences
@cindex sentences
@cindex manipulating sentences

  センテンス(文)とパラグラフ(段落)を操作するEmacsコマンドは、単語を処理するコマンドと同様、ほとんどがMetaキーに割り当てられています。

@table @kbd
@item M-a
センテンスの先頭に、後方へ移動します(@code{backward-sentence})。
@item M-e
センテンスの最後に、前方へ移動します(@code{forward-sentence})。
@item M-k
センテンスの最後まで、前方にkillします(@code{kill-sentence})。
@item C-x @key{DEL}
センテンスの最初まで、後方にkillします(@code{backward-kill-sentence})。
@end table

@kindex M-a
@kindex M-e
@findex backward-sentence
@findex forward-sentence
  コマンド@kbd{M-a} (@code{backward-sentence})および@kbd{M-e}
(@code{forward-sentence})は、センテンスの先頭または最後に移動します。これらのコマンドのバインディングは、行の先頭と最後に移動する@kbd{C-a}と@kbd{C-e}に似せて選ばれました。似ていない点は、@kbd{M-a}または@kbd{M-e}を繰り返すと、センテンス単位で連続して移動することです。

  センテンスにたいして後方に移動すると、ポイントはセンテンスの最初の文字の直前に移動します。前方に移動したときは、センテンスを終了させる区切り文字の直後に移動します。どちらもセンテンスの境界にある空白文字にポイントを移動することはありません。

@kindex M-k
@findex kill-sentence
  @kbd{C-a}と@kbd{C-e}がkillコマンド@kbd{C-k}をもつように、@kbd{M-a}と@kbd{M-e}にも対応するkillコマンドがあります。@kbd{M-k}
(@code{kill-sentence})は、ポイントからセンテンスの最後までをkillします。正の数引数@var{n}を指定すると、次の@var{n}センテンスをkillします。負の数引数@minus{}@var{n}を指定すると、後方に@var{n}番目のセンテンスの先頭までをkillします。

@kindex C-x DEL
@findex backward-kill-sentence
  @kbd{C-x @key{DEL}} (@code{backward-kill-sentence})は、センテンスの先頭までを後方にkillします。

  センテンスのコマンドは、センテンスの最後に2つのスペースを置くというAmericanのタイピストの慣習に、ユーザーが従うと仮定します。つまりセンテンスの最後は@samp{.}、@samp{?}、@samp{!}の後ろに改行または2つのスペースがあると仮定し、その間に任意の個数の@samp{)}、@samp{]}、@samp{'}、@samp{"}が許されます。パラグラフの先頭および最後は、センテンスの先頭および最後でもあります。この慣習にしたがうことにより、Emacsのセンテンスにたいするコマンドがセンテンスの最後のピリオドと、省略形を示すピリオドを区別できるので便利になります。

@vindex sentence-end-double-space
  センテンスの間を1つのスペースにしたい場合は、@code{sentence-end-double-space}を@code{nil}にセットすることにより、センテンスのコマンドが1つのスペースで止まるようになります。しかし、これにはセンテンスの終わりのピリオドと、省略形を示すピリオドを区別できなくなるという欠点があります。したがって便利で信頼できる編集のために、2つのスペースの慣習にしたがうことを推奨します。変数@code{sentence-end-double-space}はフィルにも影響します(@ref{Fill
Commands}を参照してください)。

@vindex sentence-end
  変数@code{sentence-end}は、センテンスの終了を認識する方法を制御します。非@code{nil}の場合、その値は正規表現にすべきで、それはセンテンスの最後の数文字(センテンスの後ろのスペースも含む)とのマッチに使用されます。値が@code{nil}(デフォルト)の場合、Emacsは@code{sentence-end-double-space}の値のような、変数条件に照らしてセンテンスの最後を計算します。

@vindex sentence-end-without-period
  Thaiのようないくつかの言語は、センテンスの最後を示すのにピリオドを使用しません。そのような場合は変数@code{sentence-end-without-period}に@code{t}をセットします。

@node Paragraphs
@section Paragraphs
@cindex paragraphs
@cindex manipulating paragraphs

  パラグラフ(段落)を操作するEmacsコマンドもMetaキーに割り当てられています。

@table @kbd
@item M-@{
前のパラグラフの先頭に、後方へ移動します(@code{backward-paragraph})。
@item M-@}
次のパラグラフの最後に、前方へ移動します(@code{forward-paragraph})。
@item M-h
そのパラグラフ、または次のパラグラフの周囲にポイントとマークを配します(@code{mark-paragraph})。
@end table

@kindex M-@{
@kindex M-@}
@findex backward-paragraph
@findex forward-paragraph
  @kbd{M-@{}
(@code{backward-paragraph})は、カレントのパラグラフ、または前のパラグラフの先頭に移動します(パラグラフの定義は以下を参照してください)。@kbd{M-@}}
(@code{forward-paragraph})は、カレントのパラグラフ、または次のパラグラフの最後に移動します。パラグラフの前に空行がある場合、@kbd{M-@{}はその空行に移動します。

@kindex M-h
@findex mark-paragraph
  パラグラフにたいして操作をしたい場合、@kbd{M-h}
(@code{mark-paragraph})とタイプすることにより、パラグラフの周囲にリージョンがセットされます。たとえば@kbd{M-h
C-w}は、パラグラフの周囲またはポイントの後ろをkillします。@kbd{M-h}は、ポイント位置のパラグラフの先頭にポイントを、最後にマークを配します。ポイントがパラグラフの間(連続する空行の中、または境界)にある場合、@kbd{M-h}はポイントの後ろに続くパラグラフの周囲にリージョンをセットします。パラグラフの最初の行の前に空行がある場合、その空行はリージョンに含まれます。
リージョンがすでにアクティブの場合、このコマンドはポイントを変更せずにマークをセットします。連続する@kbd{M-h}は、マークをパラグラフ単位で先にセットします。

  パラグラフの定義はメジャーモードに依存します。Fundamentalモード、同様にTextモードとそれに関連するモードでは、パラグラフと、その前後のパラグラフを分けるのは１行以上の@dfn{空行}
--- 空の行、スペースとタブだけからなる行、およびそれらに改ページ文字がついた行 ---
です。プログラミング言語に関するモードでは、通常パラグラフは同じような方法で定義されるので、パラグラフがないプログラムなどにたいしても、パラグラフのコマンドを使うことができます。

  Textモードでは、インデントされた行自体では、パラグラフの区切りには@emph{ならない}ことに注意してください。インデントされた行をパラグラフの分割に使用したい場合は、かわりにParagraph-Indent
Textモードを使用します。@ref{Text Mode}を参照してください。

  フィルプレフィクスをセットしている場合、フィルプレフィクスで始まっていないすべての行は、パラグラフの区切りとなります。@ref{Filling}を参照してください。

@vindex paragraph-start
@vindex paragraph-separate
  パラグラフ境界の正確な定義は、変数@code{paragraph-separate}および@code{paragraph-start}により制御されます。@code{paragraph-start}の値には、パラグラフを開始または分割する行にマッチする正規表現を指定します。@code{paragraph-separate}の値には、パラグラフの一部とならないような、パラグラフを分割する行にマッチする正規表現を指定します。新しいパラグラフを開始するパラグラフに含まれる行は、@code{paragraph-start}にはマッチしますが、@code{paragraph-separate}にはマッチしません。たとえばFundamentalモードでは、@code{paragraph-start}は@w{@code{"\f\\|[
\t]*$"}}、@code{paragraph-separate}は@w{@code{"[ \t\f]*$"}}です。

@node Pages
@section Pages

@cindex pages
@cindex formfeed character
  @dfn{改ページ文字}(formfeed character:
@acronym{ASCII}コード12で、@samp{control-L}とも表示されます)でページに分割されているものがあり、Emacsではそれらがエスケープシーケンス@samp{^L}で表示されます(@ref{Text
Display}を参照してください)。伝統的には、そのようなテキストファイルのハードコピーを印刷する場合、各改ページ文字で改ページされます。ほとんどのEmacsコマンドは、この文字をほかの文字と同様に扱うので、@kbd{C-q
C-l}で挿入して、@key{DEL}で削除などができます。それに加えて、Emacsはページ単位の移動や操作を行うコマンドを提供します。

@table @kbd
@item M-x what-page
ポイント位置のページ番号と、ページ内での行番号を表示します。
@item C-x [
前のページ境界にポイントを移動します(@code{backward-page})。
@item C-x ]
次のページ境界にポイントを移動します(@code{forward-page})。
@item C-x C-p
現在のページ(または他のページ)の周囲に、ポイントとマークを配します(@code{mark-page})。
@item C-x l
現在のページの行数を数えます(@code{count-lines-page})。
@end table

@findex what-page
  @kbd{M-x what-page}は、ファイルの先頭から数えたページ数と、そのページの行数をエコーエリアに表示します。

@kindex C-x [
@kindex C-x ]
@findex forward-page
@findex backward-page
  @kbd{C-x [}
(@code{backward-page})コマンドは、前のページ区切りの直後にポイントを移動します。ポイントがすでにページ区切りの直後にある場合は、そのページ区切りをスキップして、その前のページ区切りに移動します。数引数は繰り返し回数を指定します。@kbd{C-x
]} (@code{forward-page})コマンドは、次のページ区切りに前方に移動します。

@kindex C-x C-p
@findex mark-page
  @kbd{C-x C-p}
(@code{mark-page})コマンドは、ポイントを現在のページの先頭(ページの先頭に隣接するページ区切りの後ろ)、マークをページの最後(ページの最後に隣接するページ区切りの後ろ)に配します。

  @kbd{C-x C-p C-w}は、ページを他の場所に移動するためにkillする便利な方法です。@kbd{C-x [}または@kbd{C-x
]}で他のページへ移動して、そこにkillされたページをyankすれば、すべてのページは再び適切に区切られます。@kbd{C-x
C-p}のリージョンに後続のページ区切りだけが含まれるのは、これを確実に行うためです。

  @kbd{C-x
C-p}に数引数を指定すると、現在のページから数えて何ページ目に移動するかを指定します。0は現在のページ、1は次のページ、@minus{}1は前のページを意味します。

@kindex C-x l
@findex count-lines-page
  @kbd{C-x l}
(@code{count-lines-page})コマンドは、ページをどこで2つに分割するかの良い指標になります。これは現在のページの全行数と、カレント行の前にある行数と、後ろにある行数を以下のように表示します。

@example
Page has 96 (72+25) lines
@end example

@noindent
  合計が1少ないのに注意してください。これはポイントが行の先頭にない場合は正しくなります。

@vindex page-delimiter
  変数@code{page-delimiter}は、ページがどこで始まるかを制御します。この値にはページを分割する行の先頭にマッチする正規表現を指定します(@ref{Regexps}を参照してください)。この変数の値は通常@code{"^\f"}で、これは行の先頭の改ページ文字にマッチします。

@node Filling
@section Filling Text
@cindex filling text

  テキストを@dfn{フィル(fill)}するとは、指定した幅に収まるように行を分割することを意味します。Emacsはフィルを2つの方法で行います。Auto
Fillモードでは、自己挿入文字によるテキストの挿入で、自動的にフィルされます。テキストを編集するときに使用できる、明示的なフィルコマンドもあります。

@menu
* Auto Fill::                Auto 
                               Fillモードは長い行を自動的に分割します。
* Fill Commands::            パラグラフの再フィルと行の中央揃えコマンド。
* Fill Prefix::              インデントされていたり、コメントであるパラグラフのフィル。
* Adaptive Fill::            Emacsがフィルプレフィクスを自動的に決定する方法。
@end menu

@node Auto Fill
@subsection Auto Fill Mode
@cindex Auto Fill mode
@cindex mode, Auto Fill

  @dfn{Auto Fill}モードは、行が長くなりすぎたとき、それを自動的に分割する、バッファーローカルなマイナーモードです(@ref{Minor
Modes}を参照してください)。分割は@key{SPC}または@key{RET}をタイプしたときだけ発生します。

@table @kbd
@item M-x auto-fill-mode
Auto Fillモードを有効または無効にします。
@item @key{SPC}
@itemx @key{RET}
Auto Fillモード中は、適切なときに行を分割します。
@end table

@findex auto-fill-mode
  モードコマンド@kbd{M-x auto-fill-mode}は、カレントバッファーのAuto Fillモードを切り替えます。正の数引数はAuto
Fillモードを有効にし、負の引数は無効にします。Lispから@code{auto-fill-mode}が呼び出された場合、引数が省略されているか@code{nil}のときは、Auto
Fillモードを有効にします。特定のメジャーモードでAuto
Fillモードを自動的に有効にするには、モードフックに@code{auto-fill-mode}を追加します(@ref{Major
Modes}を参照してください)。Auto
Fillモードが有効なときは、モードラインにモード指標の@samp{Fill}が表示されます(@ref{Mode Line}を参照してください)。

  Auto
Fillモードは、行が望ましい幅より長くなったとき、空白の位置で自動的に行を分割します。行の分割は、@key{SPC}か@key{RET}をタイプしたときだけ発生します。行の分割をさせずにスペースまたは改行を挿入したいときは、@kbd{C-q
@key{SPC}}または@kbd{C-q C-j}とタイプします。@kbd{C-o}も行の分割を発生させずに改行を挿入します。

  Auto Fillモードが行を分割するときは、@dfn{適応型フィルプレフィクス(adaptive fill
prefix)}にしたがうよう試みます。フィルプレフィクスがカレントパラグラフの最初の１行目、および/または2行目で推論できる場合、そのフィルプレフィクスは新しい行に挿入されます(@ref{Adaptive
Fill}を参照してください)。そうでない場合、新しい行はその行で@key{TAB}をタイプしたかのようにインデントされます(@ref{Indentation}を参照してください)。プログラミング言語に関するモードでは、行がコメントの途中で改行された場合、新しいコメント区切りが適切に挿入されてコメントが分割されます。

  Auto
Fillモードはパラグラフ全体を再フィルしません。これは行の分割はしますが、行のマージはしません。したがって、パラグラフの途中を編集しているときは、適切にフィルされていないパラグラフがあり得ます。これをフィルするには、フィルコマンドを明示的に呼び出してください
@iftex
。これは次のセクションで説明します。
@end iftex
@ifnottex
(@ref{Fill Commands}を参照してください)。
@end ifnottex

@node Fill Commands
@subsection Explicit Fill Commands

@table @kbd
@item M-q
カレントパラグラフをフィルします(@code{fill-paragraph})。
@item C-x f
フィルの列幅をセットします(@code{set-fill-column})。
@item M-x fill-region
リージョンの各パラグラフをフィルします(@code{fill-region})。
@item M-x fill-region-as-paragraph
リージョンを1つのパラグラフとしてフィルします。
@item M-o M-s
行を中央に揃えます。
@end table

@kindex M-q
@findex fill-paragraph
  コマンド@kbd{M-q}
(@code{fill-paragraph})は、カレントのパラグラフを@dfn{フィル}します。このコマンドは特定の最大列幅に適合するような方法で、パラグラフの改行を再配分して、パラグラフの余分なスペースやタブ文字を削除します。

@findex fill-region
  @kbd{M-q}は通常、ポイントがあるパラグラフに作用しますが、ポイントがパラグラフの間にあるときは、ポイントの後ろのパラグラフに作用します。リージョンがアクティブの場合、かわりにリージョンのテキストに作用します。@kbd{M-x
fill-region}を呼び出して、リージョンのテキストを明確にフィルすることもできます。

@findex fill-region-as-paragraph
  @kbd{M-q}および@code{fill-region}は、パラグラフの境界を探すために、通常のEmacsの条件式を使用します。より細かく制御するには、ポイントとマークの間にあるすべてを1つのパラグラフとして再フィルする、@kbd{M-x
fill-region-as-paragraph}を使用することができます。このコマンドはリージョンの空行を削除するので、分割されたテキストブロックは、1つのブロックに結合されます。

@cindex justification
  @kbd{M-q}に数引数を指定した場合、これはテキストのフィルと同時に@dfn{割付(justify)}も指示します。これは行の右端が正確にフィル列になるように、余分なスペースが挿入されることを意味します。余分なスペースを削除するには、引数を指定せずに@kbd{M-q}を使用します(@code{fill-region}と同じ)。

@vindex fill-column
@kindex C-x f
@findex set-fill-column
  フィルのための行の最大幅は、バッファーローカルな変数@code{fill-column}により指定されます。デフォルト値は70です(@ref{Locals}を参照してください)。カレントバッファーの@code{fill-column}をセットする一番簡単な方法は、コマンド@kbd{C-x
f}
(@code{set-fill-column})を使用する方法です。数引数を指定すると、それを新しいフィル列として使用します。@kbd{C-u}だけを指定すると、このコマンドは現在のポイントの水平位置を@code{fill-column}にセットします。

@kindex M-o M-s @r{(Text mode)}
@cindex centering
@findex center-line
  コマンド@kbd{M-o M-s}
(@code{center-line})は、現在のフィル列でカレント行を中央に揃えます。数引数@var{n}を指定すると、@var{n}を中央に揃えた後、ポイントを先に移動します。このバインディングはTextモードのためのもので、利用可能なのはTextモードとそれに関連するモードだけです(@ref{Text
Mode}を参照してください)。

  デフォルトでは、Emacsは2つのスペースまたは改行が後にあるピリオドを、センテンスの終わりと判断します。後に1つのスペースしかないピリオドは、センテンスの終わりではなく、省略形を示します。それに合わせて、フィルコマンドも後に1つのスペースしかないピリオドでは、行を分割しません。変数@code{sentence-end-double-space}を@code{nil}にセットした場合、フィルコマンドは後に1つのスペースしかないピリオドでも行を分割するようになり、各ピリオドの後に1つのスペースを配すようになります。他の効果とこの方法の欠点については、@ref{Sentences}を参照してください。

@vindex colon-double-space
  変数@code{colon-double-space}が非@code{nil}の場合、フィルコマンドはコロンの後に2つのスペースを配します。

@vindex fill-nobreak-predicate
  行分割を許さない場所の条件を追加で指定するには、アブノーマルフック変数@code{fill-nobreak-predicate}をカスタマイズします(@ref{Hooks}を参照してください)。このフックの各関数は、Emacsが行を分割すべきと判断する位置で、引数なしで呼び出されます。関数が非@code{nil}値を返した場合、Emacsはその位置で行を分割しません。このフックに指定できる関数には、@code{fill-single-word-nobreak-p}(センテンスの最初の単語の後ろ、および最後の単語の前では分割しません)、@code{fill-single-char-nobreak-p}(1文字の単語の後ろでは分割しません)、@code{fill-french-nobreak-p}(@samp{(}の後ろ、および@samp{)}、@samp{:}、@samp{?}の前では分割しません)が含まれます。

@node Fill Prefix
@subsection The Fill Prefix

@cindex fill prefix
  @dfn{フィルプレフィクス(fill
prefix)}機能により、フィルされるパラグラフの各行が、特別な文字列(インデントされたパラグラフの行頭につける複数のスペースなど)で開始されるようになります。フィルプレフィクスを明示的に指定することができます。明示的に指定しない場合、Emacsは自動的にそれを推測することを試みます(@ref{Adaptive
Fill}を参照してください)。

@table @kbd
@item C-x .
フィルプレフィクスをセットします(@code{set-fill-prefix})。
@item M-q
現在のフィルプレフィクスで、パラグラフをフィルします(@code{fill-paragraph})。
@item M-x fill-individual-paragraphs
リージョンをフィルします。インデントの変化は、新しいパラグラフの開始と判断されます。
@item M-x fill-nonuniform-paragraphs
リージョンをフィルします。パラグラフを分割する行だけを、新しいパラグラフの開始と判断します。
@end table

@kindex C-x .
@findex set-fill-prefix
  カレントバッファーのフィルプレフィクスを指定するには、使用したいフィルプレフィクスで開始される行に移動して、プレフィクスの最後にポイントを配し、@w{@kbd{C-x
.}}
(@code{set-fill-prefix})とタイプします(@kbd{C-x}の後にピリオドです)。フィルプレフィクスをオフに切り替えるには、ポイントを行の先頭に移動して@w{@kbd{C-x
.}}とタイプして、空のフィルプレフィクスを指定します。

  フィルプレフィクスの効果がある間、フィルコマンドはフィルを行う前にパラグラフの各行のフィルプレフィクスを削除して、フィルを行った後で各行にフィルプレフィクスを挿入します(パラグラフの最初の行は変更されずに残ります。これは他の行と異なるように意図されていることがよくあるからです)。Auto
Fillモードは、新しい行を作成するときにフィルプレフィクスの自動的な挿入も行います(@ref{Auto
Fill}を参照してください)。@kbd{C-o}コマンドは、行の先頭で使用したときは、新しい行を作成してフィルプレフィクスを挿入します。コマンド@kbd{M-^}は逆に、削除する改行の後ろにフィルプレフィクスがあれば、プレフィクスを削除します。

  たとえば@code{fill-column}が50で、フィルプレフィクスが@samp{;;
}の場合、以下のテキストにたいして@kbd{M-q}を行うと、

@example
;; This is an
;; example of a paragraph
;; inside a Lisp-style comment.
@end example

@noindent
結果は以下のようになります:

@example
;; This is an example of a paragraph
;; inside a Lisp-style comment.
@end example

  @kbd{M-q}およびパラグラフのコマンドは、フィルプレフィクスで開始されない行を、パラグラフの開始と判断します。これは、最初の行を除く各行がインデントされている形式のパラグラフにたいして、良い結果を与えます。空行、またはプレフィクスが削除されたインデントされた行も、パラグラフを分割または開始します。これは各行にコメント区切りがある、複数パラグラフにわたるコメントを記述するときに望ましいものです。

@findex fill-individual-paragraphs
  @kbd{M-x
fill-individual-paragraphs}を使用して、各パラグラフに自動的にフィルプレフィクスをセットできます。このコマンドはリージョンをパラグラフに分割して、インデントの変化を新しいパラグラフの開始として扱い、それらのパラグラフをフィルします。したがって1つの``パラグラフ''のすべての行は、同じ量のインデントをもちます。このインデントは、そのパラグラフにたいするフィルプレフィクスの役目を果たします。

@findex fill-nonuniform-paragraphs
  @kbd{M-x
fill-nonuniform-paragraphs}も同様なコマンドですが、別の方法でリージョンをパラグラフに分割します。このコマンドは、(@code{paragraph-separate}で定義される)パラグラフ開始行だけを、新しいパラグラフの開始と判断します。これは1つのパラグラフの各行は異なる量のインデントをもつことを想定しており、パラグラフの中で最小のインデント量をフィルプレフィクスに使用します。このコマンドは最初の行のインデントが、パラグラフの他の行より少なくても多くても、良い結果をもたらします。

@vindex fill-prefix
  フィルプレフィクスは、変数@code{fill-prefix}に保存されます。変数の値は文字列で、フィルプレフィクスがないときは@code{nil}です。これはバッファーごとの変数です。変数の変更はカレントバッファーだけに影響しますが、変更できるデフォルト値も存在します。@ref{Locals}を参照してください。

  テキストプロパティー@code{indentation}は、パラグラフのインデント量を制御する別の方法を提供します。@ref{Enriched
Indentation}を参照してください。

@node Adaptive Fill
@subsection Adaptive Filling

@cindex adaptive filling
  フィルコマンドは、特定なケースでは自動的に適切なフィルプレフィクスを推測できます。空白文字または特定の区切り文字が行の先頭にあり、それがパラグラフの全行に適用されている場合です。

  パラグラフに2行以上の行がある場合は、2行目からフィルプレフィクスが取得されますが、それは1行目にもそれが存在する場合だけです。

  パラグラフに1行しかない場合、フィルコマンドは、その行からフィルプレフィクスを取得する@emph{かも}しれません。この決定は複雑です。なぜならそのような場合に妥当な、3つの選択肢があるからです。

@itemize @bullet
@item
最初の行のプレフィクスを、パラグラフのすべての行に適用します。

@item
後続の行を空白文字でインデントします。これにより最初の行のプレフィクスの下にテキストが並びますが、実際には最初の行からプレフィクスをコピーしません。

@item
2行目以降の行に特別なことは行いません。
@end itemize

  これら3つの書式スタイルは一般的に使用されているものです。そのためフィルコマンドは、そのメジャーモードに出現するプレフィクスにもとづいて、望ましいスタイルを決定しようと試みます。判断基準は以下のとおりです。

@vindex adaptive-fill-first-line-regexp
  最初の行で見つかったプレフィクスが@code{adaptive-fill-first-line-regexp}にマッチするか、それがコメント開始シーケンス(メジャーモードに依存します)の場合、見つかったプレフィクスをパラグラフのフィルに使用しますが、それは後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

  上記以外の場合、見つかったプレフィクスは同じ量のスペースに変換され、それらのスペースは残りの行のフィルプレフィクスとして使用されますが、それは後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

  Textモード、および空行またはページ区切りだけがパラグラフを分割するモードでは、適応型フィルにより選択されるプレフィクスは、パラグラフの開始として振る舞わないので、常にフィルに使用できます。

@vindex adaptive-fill-mode
@vindex adaptive-fill-regexp
  変数@code{adaptive-fill-regexp}は、どのような行開始がフィルプレフィクスの役目を果たすかを決定します。行がこの正規表現にマッチする文字で開始されるとき、プレフィクスとして使用されます。変数@code{adaptive-fill-mode}を@code{nil}にセットした場合、フィルプレフィクスは自動的に選択されません。

@vindex adaptive-fill-function
  変数@code{adaptive-fill-function}に関数をセットすることにより、より複雑な方法で自動的にフィルプレフィクスを選択する方法を指定できます。この関数は行の左端の直後のポイントで呼び出され、その行にもとづいた適切なフィルプレフィクスを返すべきです。この関数が@code{nil}を返した場合、@code{adaptive-fill-regexp}がフィルプレフィクスを見つける機会を与えられます。

@node Case
@section Case Conversion Commands
@cindex case conversion

  Emacsには、1つの単語または任意の範囲のテキストを、大文字または小文字に変換するコマンドがあります。

@table @kbd
@item M-l
後続の単語を小文字に変換します(@code{downcase-word})。
@item M-u
後続の単語を大文字に変換します(@code{upcase-word})。
@item M-c
後続の単語の先頭の文字を大文字に変換します(@code{capitalize-word})。
@item C-x C-l
リージョンを小文字に変換します(@code{downcase-region})。
@item C-x C-u
リージョンを大文字に変換します(@code{upcase-region})。
@end table

@kindex M-l
@kindex M-u
@kindex M-c
@cindex words, case conversion
@cindex converting text to upper or lower case
@cindex capitalizing words
@findex downcase-word
@findex upcase-word
@findex capitalize-word
  @kbd{M-l}
(@code{downcase-word})は、ポイントの後ろの単語を小文字に変換して、その先にポイントを移動します。したがって、@kbd{M-l}を繰り返すと、単語を連続して変換します。@kbd{M-c}
(@code{capitalize-word})は、単語の最初の文字を大文字にして残りを小文字にしますが、@kbd{M-u}
(@code{upcase-word})はすべての文字を大文字に変換します。これらのコマンドはすべて、引数を与えると複数の単語を変換します。これらのコマンドはすべてが大文字の大きなテキストを、これらが混成されたものに変換するとき、特に有用です、なぜなら適切に@kbd{M-l}、@kbd{M-u}、@kbd{M-c}を使い分けて単語を変換しながら移動できるからです(変換が不要なときは@kbd{M-f}を使ってその単語をスキップします)。

  負の引数を与えると。ポイントの前の指定した数の単語にたいして、大文字小文字の変換を適用しますが、ポイントは移動しません。これは大文字小文字を間違えてタイプしたとき有用です。大文字小文字の変換コマンドを実行した後、そのまま編集を続けられるからです。

  単語の途中で単語の大文字小文字を変換するコマンドが与えられた場合、ポイントの後ろに続く単語の一部だけに変換が適用されます(これは@kbd{M-d}
(@code{kill-word})と互換性があります)。負の引数の場合は、ポイントの前にある単語の一部が変換されます。

@kindex C-x C-l
@kindex C-x C-u
@findex downcase-region
@findex upcase-region
  他の大文字小文字の変換コマンドは@kbd{C-x C-u} (@code{upcase-region})と@kbd{C-x C-l}
(@code{downcase-region})で、これらはポイントとマークの間にあるすべてのテキストを大文字または小文字に変換します。ポイントとマークは移動しません。

  リージョンにたいする大文字小文字の変換コマンド@code{upcase-region}および@code{downcase-region}は、通常では無効になっています。これは、これらを使おうと試みたとき、確認を求められることを意味します。確認にたいして同意するとコマンドが有効になり、それ以降は確認を求められなくなることを意味します。@ref{Disabling}を参照してください。

@node Text Mode
@section Text Mode
@cindex Text mode
@cindex mode, Text
@findex text-mode

  Textモードは、人間の言語のテキストファイルを編集するためのメジャーモードです。@file{.txt}という拡張子で終わる名前のファイルは、通常はTextモードで開かれます。明示的にTextモードに切り替えるには、@kbd{M-x
text-mode}とタイプしてください。

  Textモードでは、改行とページ区切りだけがパラグラフを分割します。結果として、パラグラフはインデントすることができ、適応型フィルはパラグラフをフィルするときに、どのインデントが使用されているか決定します。@ref{Adaptive
Fill}を参照してください。

@kindex TAB @r{(Text mode)}
  Textモードでは@key{TAB}
(@code{indent-for-tab-command})コマンドは通常、カレント行をインデントするかわりに、次のタブストップまで空白文字を挿入します。詳細については、@ref{Indentation}を参照してください。

  Textモードは、明示的にそれらを呼び出した場合をのぞき、コメントに間する機能をオフに切り替えます。これは構文テーブル(syntax
table)を変更するので、シングルクォートは単語の一部と判断されます(たとえば@samp{don't}は1つの単語と判断されます))。しかし単語がシングルクォートで開始される場合、それは先頭の文字を大文字にするためのプレフィクスとして扱われます(たとえば@kbd{M-c}により、@samp{'hello'}は@samp{'Hello'}に変換されます)。

@cindex Paragraph-Indent Text mode
@cindex mode, Paragraph-Indent Text
@findex paragraph-indent-text-mode
@findex paragraph-indent-minor-mode
  パラグラフの最初の行をインデントしている場合は、TextモードではなくParagraph-Indent Textモード(@kbd{M-x
paragraph-indent-text-mode})を使用するべきでしょう。このモーででは、パラグラフの間に空行を入れる必要はありません。最初の行のインデントだけでパラグラフの開始を判断するのに充分だからです。しかしパラグラフのすべてのの行がインデントされている場合は、サポートされません。メジャーモードを変更したくないとき(たとえばメール作成時など)は、@kbd{M-x
paragraph-indent-minor-mode}を使って、等価なマイナーモードを有効にしてください。

@kindex M-TAB @r{(Text mode)}
  Textモードでは、@kbd{M-@key{TAB}}が@code{ispell-complete-word}にバインドされます。このコマンドはバッファーのポイントの前にある単語を、スペル辞書を使用して補完します。@ref{Spelling}を参照してください。ウィンドウマネージャーが@kbd{M-@key{TAB}}をウィンドウの切り替えに定義している場合は、かわりに@kbd{@key{ESC}
@key{TAB}}または@kbd{C-M-i}とタイプすることができます。

@vindex text-mode-hook
  Textモードに入ると、モードフック@code{text-mode-hook}が実行されます(@ref{Major Modes}を参照してください)。

  以下のセクションでは、Textモードから@dfn{派生}したいくつかのメジャーモードを説明します。派生したモードは、上記で説明したTextモードのほとんどの機能を継承します。とくに、Textモードから派生したモードは、それら自身のモードフックの前に、@code{text-mode-hook}を実行します。

@node Outline Mode
@section Outline Mode
@cindex Outline mode
@cindex mode, Outline
@cindex invisible lines

@findex outline-mode
@findex outline-minor-mode
@vindex outline-minor-mode-prefix
@vindex outline-mode-hook
  OutlineモードはTextモードから派生したメジャーモードで、アウトライン(outline:
概略、概要、要綱)を編集するために特化したモードです。このモードはアウトライン構造のエントリー間を操作したり、バッファーの一部を一時的に非表示にするコマンドを提供するので、アウトライン構造をより簡単に閲覧することができるでしょう。@kbd{M-x
outline-mode}とタイプすることにより、Outlineモードに切り替わります。Outlineモードに入ることにより、フック@code{text-mode-hook}、およびそれに続けてフック@code{outline-mode-hook}が実行されます(@ref{Hooks}を参照してください)。

  Outlineモードで行を非表示にするコマンド(@ref{Outline
Visibility}を参照してください)を使用した場合、それらの行は画面に表示されなくなります。非表示行の前にある表示された行の後ろには省略記号(3つのピリオド)が表示され、そこに隠れたテキストがあることを示します。連続する複数の行を非表示にした場合も、省略記号は1つだけです。

  @kbd{C-n}や@kbd{C-p}のような、複数の行にたいして操作を行う編集コマンドは、非表示の行のテキストを、その前にある表示された行の一部として扱います。表示された行の最後にある省略記号をkillすると、省略記号に対応する後続のすべての非表示テキストを実際にkillします。

  Outline
minorモードは、メジャーモードであるOutlineモードと同じコマンドを提供する、バッファーローカルなマイナーモードで、他のメジャーモードと合わせて使うことができます。@kbd{M-x
outline-minor-mode}とタイプして、カレントバッファーにたいしてOutline
minorモードを切り替えることができます。ファイルローカル変数のセッティングを使用して、特定のファイルにたいして有効にすることもできます(@ref{File
Variables}を参照してください)。

@kindex C-c @@ @r{(Outline minor mode)}
  メジャーモードのOutlineモードは、@kbd{C-c}プレフィクスで特別なキーバインディングを提供します。Outline
minorモードは、@kbd{C-c
@@}プレフィクスで同様なバインディングを提供します。これは他のメジャーモードの特別なコマンドとの競合を減らすためです(変数@code{outline-minor-mode-prefix}は、使用するプレフィクスを制御します)。

@menu
* Outline Format::           アウトラインのテキストがどのように見えるか。
* Outline Motion::           アウトラインを移動するための特別なコマンド。
* Outline Visibility::       なにを表示するか制御するコマンド。
* Outline Views::            アウトラインと複数ビュー。
* Foldout::                  アウトラインをズームする折り畳み。
@end menu

@node Outline Format
@subsection Format of Outlines

@cindex heading lines (Outline mode)
@cindex body lines (Outline mode)
  Outlineモードは、バッファーの行には2つのタイプがあると仮定します。それは@dfn{ヘッダー行(heading
lines)}と@dfn{ボディー行(body
lines)}です。ヘッダー行はアウトラインのトピックを表します。ヘッダー行は1つ以上のアスタリスク文字(@samp{*})で開始されます。アスタリスクの数はアウトライン構造でのヘッダーの深さを決定します。したがって1つの@samp{*}がついたトピックは、メジャーなトピックになります。このヘッダーと、次の@samp{*}が1つのヘッダーの間にある、@samp{*}が2つのヘッダー行は、そのヘッダーのサブトピックです。ヘッダー行ではないすべての行はボディー行です。ボディー行は、それの前にあるヘッダー行に属します。以下は例です:

@example
* Food
This is the body,
which says something about the topic of food.

** Delicious Food
This is the body of the second-level header.

** Distasteful Food
This could have
a body too, with
several lines.

*** Dormitory Food

* Shelter
Another first-level topic with its header line.
@end example

  ヘッダー行とそれに属するすべてのボディー行を合わせて、@dfn{エントリー(entry)}と呼びます。ヘッダー行と、その配下にあるすべてのヘッダー行、それらすべてのボディー行を、@dfn{サブツリー(subtree)}と呼びます。

@vindex outline-regexp
  ヘッダー行と判別する条件は、変数@code{outline-regexp}をセットすることによりカスタマイズできます(これを行う推奨された方法は、メジャーモードの関数を使うか、ファイルローカル変数を使う方法です)。行の開始がこのregexpにマッチする行は、ヘッダー行と判断されます。(行の左端ではなく)行の途中でのマッチは勘定に入りません。

  テキストにたいするマッチの長さは、ヘッダーのレベルを決定します。長いマッチは、より深くネストされたレベルとなります。@samp{@@chapter}、@samp{@@section}、@samp{@@subsection}というコマンドが、ドキュメントをチャプター、セクション、サブセクションに分割するようなテキストフォーマッターがある場合(訳注:
texinfo形式のこと)、@code{outline-regexp}に@samp{"@@chap\\|@@\\(sub\\)*section"}をセットすることにより、それらの行をヘッダー行と判断させることができます。ここでトリックに注意してください。2つの単語@samp{chapter}と@samp{section}は同じ長さです。しかしregexp@samp{chap}だけにマッチするように定義することによって、チャプターのヘッダーにマッチするテキストの長さを短くすることができるので、Outlineモードはセクションがチャプターの配下であることを知ることができます。これは@samp{@@chap}で始まるコマンドが他にない場合に限り機能します。

@vindex outline-level
  変数@code{outline-level}をセットすることにより、ヘッダー行のレベルを計算するためのルールを明示できに指定できます。@code{outline-level}の値には、引数をとらないカレントヘッダーのレベルを返す関数を指定します。この変数をセットする推奨された方法は、メジャーモードのコマンドを使うか、ファイルローカル変数を使用する方法です。

@node Outline Motion
@subsection Outline Motion Commands

  Outlineモードはヘッダー行を後方または前方に移動する、特別な移動コマンドを提供します。

@table @kbd
@item C-c C-n
ポイントを次の可視なヘッダー行に移動します(@code{outline-next-visible-heading})。
@item C-c C-p
ポイントを前の可視なヘッダー行に移動します(@code{outline-previous-visible-heading})。
@item C-c C-f
ポイントを同じレベルの、次の可視なヘッダー行に移動します(@code{outline-forward-same-level})。
@item C-c C-b
ポイントを同じレベルの、前の可視なヘッダー行に移動します(@code{outline-backward-same-level})。
@item C-c C-u
ポイントを、より低い(より包括的な)レベルの可視のヘッダー行に移動します(@code{outline-up-heading})。
@end table

@findex outline-next-visible-heading
@findex outline-previous-visible-heading
@kindex C-c C-n @r{(Outline mode)}
@kindex C-c C-p @r{(Outline mode)}
  @kbd{C-c C-n}
(@code{outline-next-visible-heading})は、次のヘッダー行へ下に移動します。@kbd{C-c C-p}
(@code{outline-previous-visible-heading})は、同じように後方へ移動します。両方とも数引数で繰り返し回数を指定できます。

@findex outline-up-heading
@findex outline-forward-same-level
@findex outline-backward-same-level
@kindex C-c C-f @r{(Outline mode)}
@kindex C-c C-b @r{(Outline mode)}
@kindex C-c C-u @r{(Outline mode)}
  @kbd{C-c C-f} (@code{outline-forward-same-level})および@kbd{C-c C-b}
(@code{outline-backward-same-level})は、1つのヘッダー行から、アウトライン上で同じ深さの可視なヘッダー行に移動します。@kbd{C-c
C-u} (@code{outline-up-heading})は、より浅くネストされたヘッダー行に後方へ移動します。

@node Outline Visibility
@subsection Outline Visibility Commands

  Outlineモードには、アウトライン構造にもとづいてバッファーの一部を一時的に非表示にしたり可視にするコマンドが、いくつかあります。これらのコマンドはアンドゥ可能ではありません。コマンドの効果は単純にアンドゥメカニズムに記録される訳ではありませんが、それらを実行した直後に限りアンドゥできます(@ref{Undo}を参照してください)。

  これらのコマンドは、``カレント''のヘッダー行に作用します。ポイントがヘッダー行にある場合、それがカレントのヘッダー行です。ポイントがボディー行にある場合、カレントヘッダー行は一番近くの前にあるヘッダー行です。

@table @kbd
@item C-c C-c
カレントヘッダー行のボディーを非表示にします(@code{hide-entry})。
@item C-c C-e
カレントヘッダー行のボディーを可視にします(@code{show-entry})。
@item C-c C-d
カレントヘッダー行の配下のすべて(ヘッダー行自身は含まれません)を非表示にします(@code{hide-subtree})。
@item C-c C-s
カレントヘッダー行の配下のすべて(ボディー、サブヘッダーおよびそのボディーを含む)を可視にします(@code{show-subtree})。
@item C-c C-l
カレントヘッダー行のボディーと、すべてのサブヘッダーを非表示にします(@code{hide-leaves})。
@item C-c C-k
カレントヘッダー行のサブヘッダーをすべてのレベルで可視にします(@code{show-branches})。
@item C-c C-i
カレントヘッダー行の一番近いサブヘッダー(1レベル下)を可視にします(@code{show-children})。
@item C-c C-t
バッファーのすべてのボディー行を非表示にします(@code{hide-body})。
@item C-c C-a
バッファーのすべての行を可視にします(@code{show-all})。
@item C-c C-q
上位@var{n}レベルのヘッダー行を除き、すべてを非表示にします(@code{hide-sublevels})。
@item C-c C-o
ポイントのあるヘッダー行またはボディー行と、そこから最上位までのレベルにあるヘッダーを除き、すべてを非表示にします(@code{hide-other})。
@end table

@findex hide-entry
@findex show-entry
@kindex C-c C-c @r{(Outline mode)}
@kindex C-c C-e @r{(Outline mode)}
  これらのコマンドのうち、カレントヘッダー行に直接続くボディー行を非表示にする@kbd{C-c C-c}
(@code{hide-entry})と、それらを可視にする@kbd{C-c C-e}
(@code{show-entry})が一番簡単なコマンドです。サブヘッダーとそれらのボディーは影響を受けません。

@findex hide-subtree
@findex show-subtree
@kindex C-c C-s @r{(Outline mode)}
@kindex C-c C-d @r{(Outline mode)}
@cindex subtree (Outline mode)
  コマンド@kbd{C-c C-d} (@code{hide-subtree})および@kbd{C-c C-s}
(@code{show-subtree})は、より強力です。これらはカレントヘッダー行の@dfn{サブツリー} ---
つまりカレントヘッダー行のボディーと、すべての直接または間接のサブヘッダーとそのボディー --- に適用されます。

@findex hide-leaves
@findex show-branches
@findex show-children
@kindex C-c C-l @r{(Outline mode)}
@kindex C-c C-k @r{(Outline mode)}
@kindex C-c C-i @r{(Outline mode)}
  コマンド@kbd{C-c C-l}
(@code{hide-leaves})は、カレントヘッダー行のボディーと、サブツリーのボディーをすべて非表示にします(サブヘッダー自身は表示されます)。コマンド@kbd{C-c
C-k} (@code{show-branches})は、(たとえば@kbd{C-c
C-d})などで)前に非表示にされたサブヘッダーを可視にします。コマンド@kbd{C-c C-i}
(@code{show-children})はこれの穏やかなバージョンで、直接的なサブヘッダー(たとえば1レベル下のサブヘッダー)を可視にします。

@findex hide-other
@kindex C-c C-o @r{(Outline mode)}
  コマンド@kbd{C-c C-o}
(@code{hide-other})は、ポイントのあるエントリーと、その祖先(アウトライン構造上でそこから最上位レベルに至るまでのヘッダー)、およびトップレベルのヘッダーを除き、すべてを非表示にします。

@findex hide-body
@findex show-all
@kindex C-c C-t @r{(Outline mode)}
@kindex C-c C-a @r{(Outline mode)}
@findex hide-sublevels
@kindex C-c C-q @r{(Outline mode)}
  残りのコマンドは、バッファー全体に作用するコマンドです。@kbd{C-c C-t}
(@code{hide-body})はすべてのボディー行を非表示にするので、アウトライン構造だけを見ることができます(特別な例外として、ファイルの最初にあるヘッダー行より前の行は、技術的に言うとボディー行ですが、これらは非表示になりません)。@kbd{C-c
C-a} (@code{show-all})はすべての行を可視にします。@kbd{C-c C-q}
(@code{hide-sublevels})は最上位のヘッダーを除き、すべてを非表示にします。数引数@var{n}を指定すると、上位@var{n}レベルのヘッダー行を除き、すべてを非表示にします。

@anchor{Outline Search}
@findex reveal-mode
@vindex search-invisible
  インクリメンタル検索が、Outlineモードにより非表示にされたテキストを検索したとき、検索された部分のバッファーは可視になります。その位置で検索を抜けると、テキストは可視のまま残ります。アクティブなインクリメンタル検索が、非表示のテキストにマッチするかを切り替えるには、@kbd{M-s
i}とタイプします。将来の検索にたいしてデフォルトを変更するには、オプション@code{search-invisible}をカスタマイズします(このオプションは@code{query-replace}、および関連する機能が非表示のテキストを扱う方法に影響を与えます。@ref{Query
Replace}を参照してください)。バッファーローカルなマイナーモードRevealモード(@kbd{M-x
reveal-mode})を使用して、操作にしたがって自動的にテキストを可視にもできます。

@node Outline Views
@subsection Viewing One Outline in Multiple Views

@cindex multiple views of outline
@cindex views of an outline
@cindex outline with multiple views
@cindex indirect buffers and outlines
  1つのアウトラインを同時に2つのビューで、別のウィンドウで表示することができます。これを行うには、@kbd{M-x
make-indirect-buffer}を使ってインダイレクトバッファーを作らなければなりません。このコマンドの最初の引数は既存のアウトラインバッファーの名前で、2番目の引数は新しくインダイレクトバッファーとして使用する名前です。@ref{Indirect
Buffers}を参照してください。

  1度インダイレクトバッファーが作成されると、@kbd{C-x 4
b}や他のEmacsコマンドで、通常のやり方でウィンドウにそれを表示できます。テキストの一部を可視にしたり非表示にするOutlineモードのコマンドは、それぞれのバッファーで独立したエントリーを操作し、それぞれのバッファーは独自のビューをもつことができます。同じアウトラインにたいして2つ以上のビューが欲しいときは、追加でインダイレクトバッファーを作成します。

@node Foldout
@subsection Folding Editing

@cindex folding editing
  Foldoutパッケージは、OutlineモードおよびOutline minorモードを、``フォールディング(folding:
折り畳みの)''コマンドで拡張します。フォールディングのアイデアは、アウトラインのネストされた部分にたいして、それに関連する部分と、より高いレベルが非表示のときに、それにズームインするというものです。

  すべてのテキストと、レベル1より下のレベルが非表示になっているOutlineモードのバッファーを考えてください。それらのヘッダーの下に何が隠れているか見るには、@kbd{C-c
C-e} (@kbd{M-x show-entry})でボディーを可視にするか、@kbd{C-c
C-i}でその子ヘッダー(レベル2)を可視にすることができます。

@kindex C-c C-z
@findex foldout-zoom-subtree
  Foldoutでは、@kbd{C-c C-z} (@kbd{M-x
foldout-zoom-subtree})を使います。これはそのヘッダーのボディーと、その子サブヘッダーを可視にして、バッファーをナローイングするので、@w{レベル1}にヘッダーとボディー、それにレベル2のヘッダーだけが可視になります。そのうちの1つのレベル2ヘッダーの下を見るには、カーソル位置をそのヘッダーに移動して、もう一度@kbd{C-c
C-z}を使用します。これにより、そのレベル2ヘッダーのボディーと、レベル3の子サブヘッダーが可視になり、バッファーが再びナローイングされます。連続して好きなだけサブヘッダーをズームインすることができます。モードラインの文字列には、今どの深さにいるのかが表示されます。

  ヘッダーにズームインしているときに、それらの子サブヘッダーを見るには@kbd{C-u C-c
C-z}のように数引数を指定します。何レベル下の子かを指定することもできます(@kbd{M-x
show-children}に相当します)。たとえば@kbd{M-2 C-c
C-z}は2レベルの子サブヘッダーを可視にします。ボディーを指定するには@kbd{M-- C-c C-z}のように負の引数を指定します。@kbd{C-c
C-s} (@kbd{M-x show-subtree})のようにサブツリー全体を展開するには、@kbd{M-0 C-c
C-z}のように引数に0を指定します。

  ズームインしている時でも、Outlineモードの表示および非表示の関数は、Foldoutに干渉せずに使用できます。バッファーがナローイングされているので、``グローバル''な編集操作は、ズームインされたヘッダーのテキストだけに影響します、これは特定のチャプターやセクションに変更を限定するのに便利です。

@kindex C-c C-x
@findex foldout-exit-fold
  フォールドのズームを取り消す(抜ける)には、@kbd{C-c C-x} (@kbd{M-x
foldout-exit-fold})を使用します。これは最上位レベルのヘッダーの配下のすべてのテキストと、サブヘッダーを非表示にして、バッファーの以前のビューに戻ります。数引数はフォールドを何レベル抜けるかを指定します。0を指定するとすべてのフォールドを抜けます。

  テキストとサブヘッダーを非表示にせずに、フォールドのナローイングを取り消すには、負の引数を指定します。たとえば、@kbd{M--2 C-c
C-x}は2つのフォールドを抜け出し、テキストとサブヘッダーは表示されたままにします。

  Foldoutモードはフォールドへの出入りと、非表示のテキストを表示するためのマウスコマンドも提供します:

@table @asis
@item @kbd{C-M-Mouse-1}でヘッダーをクリックするとズームインします。
@itemize @w{}
@item
シングルクリック: ボディーを可視にします。
@item
ダブルクリック: サブヘッダーを可視にします。
@item
トリプルクリック: ボディーとサブヘッダーを可視にします。
@item
4連クリック: サブツリー全体を可視にします。
@end itemize
@item @kbd{C-M-Mouse-2}でヘッダーをクリックしたときは可視になります
@itemize @w{}
@item
シングルクリック: ボディーを可視にします。
@item
ダブルクリック: サブヘッダーを可視にします。
@item
トリプルクリック: ボディーとサブヘッダーを可視にします。
@item
4連クリック: サブツリー全体を可視にします。
@end itemize
@item @kbd{C-M-Mouse-3}でヘッダーをクリックすると、ヘッダーの配下のテキストを非表示にするか、フォールドを抜けます
@itemize @w{}
@item
シングルクリック: サブツリーを非表示にします。
@item
ダブルクリック: フォールドを抜けてテキストを非表示にします。
@item
トリプルクリック: テキストを非表示にせずにフォールドを抜けます
@item
4連クリック: すべてのフォールドを抜けてテキストを非表示にします。
@end itemize
@end table

@c FIXME not marked as a user variable
@vindex foldout-mouse-modifiers
  @code{foldout-mouse-modifiers}をセットすることにより、(@kbd{@key{Ctrl}-@key{META}-}のかわりに)他の修飾キーを指定できます。すでに@file{foldout.el}ライブラリーがロードされている場合、これが効果をもつために再ロードしなければなりません。

  Foldoutパッケージを使用するには、@kbd{M-x load-library @key{RET} foldout
@key{RET}}とタイプするか、initファイルに以下の行を記述して自動的にこれを行うことができます。

@example
(eval-after-load "outline" '(require 'foldout))
@end example

@node Org Mode
@section Org Mode
@cindex organizer
@cindex planner
@findex Org mode
@findex mode, Org

@findex org-mode
  Orgモードは、Emacsをオーガナイザーおよび／またはオーサリングツールとして使用するための、Outlineモードの変種です。名前が拡張子@file{.org}で終わるファイルは、Orgモードで開かれます(@ref{Choosing
Modes}を参照してください)。明示的にOrgモードに切り替えるには、@kbd{M-x org-mode}とタイプしてください。

  Orgモードでは、Outlineモードのように、各エントリーは1つ以上の@samp{*}文字で始まるヘッダー行をもちます。@ref{Outline
Format}を参照してください。それに加えて、@samp{#}文字で始まる行は、コメントとして扱われます。

@kindex TAB @r{(Org Mode)}
@findex org-cycle
  Orgモードは、簡単にアウトライン構造を眺めたり操作するためのコマンドを提供します。それらのコマンドのうち、一番簡単なのは@key{TAB}
(@code{org-cycle})です。ヘッダー行でこのコマンドを呼び出すと、サブツリーを --- (i)ヘッダー行だけを表示
(ii)ヘッダー行と、(あれば)直接の子ヘッダー行だけを表示 (iii)サブツリー全体を表示 ---
の3つの異なる視点で巡回します。ボディー行にたいして呼び出された場合、@key{TAB}にグローバルにバインドされたコマンドが実行されます。

@kindex S-TAB @r{(Org Mode)}
@findex org-shifttab
  Orgモードのバッファーの任意の場所で、@kbd{S-@key{TAB}}
(@code{org-shifttab})とタイプすることにより、アウトライン構造全体を --- (i) 最上位ㇾベルのヘッダー行だけを表示
(ii)ボディー行を除いたすべてのヘッダー行を表示 (iii) すべてを表示 --- の3つの異なる視点で巡回します。

@kindex M-<up> @r{(Org Mode)}
@kindex M-<down> @r{(Org Mode)}
@kindex M-<left> @r{(Org Mode)}
@kindex M-<right> @r{(Org Mode)}
@findex org-metaup
@findex org-metadown
@findex org-metaleft
@findex org-metaright
  ヘッダー行で@kbd{M-<up>} (@code{org-metaup})または@kbd{M-<down>}
(@code{org-metadown})とタイプすることにより、ボディー行と(あれば)サブツリーを含むバッファー内のエントリー全体を、上または下に移動できます。同様に@kbd{M-<left>}
(@code{org-metaleft})および@kbd{M-<right>}
(@code{org-metaright})で、ヘッダー行を昇格または降格できます。ボディー行で呼び出された場合は、それらのキーにグローバルにバインドされたコマンドが実行されます。

  以下のサブセクションでは、オーガナイザーやオーサリングシステムとしてOrgモードを使用するための基本的な操作方法を解説します。詳細については、@ref{Top,
The Org Mode Manual, Introduction, org, The Org Manual}を参照してください。

@menu
* Org Organizer::            TODOリストとアジェンダの管理。
* Org Authoring::            Orgバッファーをさまざまなフォーマットでエクスポートする。
@end menu

@node Org Organizer
@subsection Org as an organizer
@cindex TODO item
@cindex Org agenda

@kindex C-c C-t @r{(Org Mode)}
@findex org-todo
@vindex org-todo-keywords
  エントリー内のどこかで@kbd{C-c C-t}
(@code{org-todo})とタイプすることにより、そのOrgエントリーを@dfn{TODO}アイテムとして、タグ付けすることができます。これはヘッダー行にキーワード@samp{TODO}を追加します。もう一度@kbd{C-c
C-t}をタイプするとキーワードは@samp{DONE}に切り替わり、さらに@kbd{C-c
C-t}とタイプするとキーワード全体を除去します。@kbd{C-c
C-t}で使用されるキーワードは、変数@code{org-todo-keywords}を通じてカスタマイズすることができます。

@kindex C-c C-s @r{(Org Mode)}
@kindex C-c C-d @r{(Org Mode)}
@findex org-schedule
@findex org-deadline
  エントリーをTODOとして作成する他に、エントリー内で@kbd{C-c C-s}
(@code{org-schedule})とタイプすることにより、日付を割り当てることができます。これはEmacs
Calender(@ref{Calendar/Diary}を参照してください)をポップアップして日付の入力を求め、選択された日付と一緒に、ヘッダー行の下にタグ@samp{SCHEDULED}を追加します。コマンド@kbd{C-c
C-d} (@code{org-deadline})も、タグ@code{DEADLINE}を使う以外は同じ効果をもちます。

@kindex C-c [ @r{(Org Mode)}
@findex org-agenda-file-to-front
@vindex org-agenda-files
  1度Orgファイルに計画されたTODOアイテムをもつと、@kbd{C-c [}
(@code{org-agenda-file-to-front})とタイプすることにより、@dfn{アジェンダファイル(agenda
files)}のリストにそのファイルを追加できます。Orgモードは、たとえばあなたの生活のさまざまな側面をオーガナイズするために、複数のアジェンダファイルを簡単に保守できるようにデザインされています。アジェンダファイルのリストは、変数@code{org-agenda-files}に格納されています。

@findex org-agenda
  アジェンダファイルのアイテムを閲覧するには、@kbd{M-x
org-agenda}とタイプします。このコマンドは何を見たいのか、入力を求めます(今週に行なうすべての事項のリストか、特定のキーワードにマッチするTODOアイテムのリストか、など)。
@ifnottex
詳細は、@ref{Agenda Views,,,org, The Org Manual}を参照してください。
@end ifnottex

@node Org Authoring
@subsection Org as an authoring system
@cindex Org exporting

@findex org-export
@kindex C-c C-e @r{(Org mode)}
  Orgノートを見映えよくフォーマットしたり、エクスポートして公表したいと思うかもしれません。カレントバッファーをエクスポートするには、Orgバッファーのどこかで@kbd{C-c
C-e}
(@code{org-export})とタイプします。このコマンドはエクスポートするフォーマットの入力を求めます。現在サポートされているフォーマットは、HTML、@LaTeX{}、OpenDocument(@file{.odt})、PDFです。PDFのようないくつかのフォーマットは、システムに特定のツールがインストールされている必要があります。

@vindex org-publish-project-alist
  1度に複数のファイルを特定のディレクトリー(ローカルまたはネットワーク越し)にエクスポートするには、変数@code{org-publish-project-alist}にプロジェクトのリストを定義しなければなりません。詳細はOrgのドキュメントを参照してください。

  Orgはエクスポートされたドキュメントのテキストのフォーマットに適用する、シンプルなマークアップの仕組みをサポートします:

@example
- This text is /emphasized/
- This text is *in bold*
- This text is _underlined_
- This text uses =a teletype font=

#+begin_quote
``This is a quote.''
#+end_quote

#+begin_example
This is an example.
#+end_example
@end example

  詳細は、@ref{Exporting,,,org, The Org Manual}、および@ref{Publishing,,,org, The Org
Manual}を参照してください。

@node TeX Mode
@section @TeX{} Mode
@cindex @TeX{} mode
@cindex @LaTeX{} mode
@cindex Sli@TeX{} mode
@cindex Doc@TeX{} mode
@cindex mode, @TeX{}
@cindex mode, @LaTeX{}
@cindex mode, Sli@TeX{}
@cindex mode, Doc@TeX{}
@findex tex-mode
@findex plain-tex-mode
@findex latex-mode
@findex slitex-mode
@findex doctex-mode
@findex bibtex-mode

  Emacsは、@TeX{}およびそれに関連するフォーマットで記述されたファイルを編集するための、特別なメジャーモードを提供します。@TeX{}はDonald
Knuthにより記述された強力なテキストフォーマッターで、GNU
Emacsと同様、フリーなソフトウェアーです。@LaTeX{}は@TeX{}のための簡略化された入力フォーマットで、@TeX{}マクロを使って実装されています。Doc@TeX{}は@LaTeX{}ソースが記述された特別なファイルフォーマットで、ソースとドキュメントが合成されています。Sli@TeX{}は、時代遅れの特別な@LaTeX{}形式です。@footnote{これは@LaTeX{}由来の@samp{slides}ドキュメントクラスにより置き換えられました。}

@vindex tex-default-mode
  @TeX{}には4つの変種があります。それはPlain
@TeX{}モード、@LaTeX{}モード、Doc@TeX{}モード、Sli@TeX{}モードです。これら4つのメジャーモード間の違いはわずかで、4つの異なるフォーマットを編集するためにデザインされています。Emacsはバッファーの内容を調べて適切なモードを選択します(通常これは@TeX{}風なファイルをvisitしたときに自動的に呼び出される@code{tex-mode}コマンドにより行われます。@ref{Choosing
Modes}を参照してください)。ファイル内容がこれを決定するのに不十分な場合、Emacsは@code{tex-default-mode}に指定されたモードを選択します。デフォルト値は@code{latex-mode}です。Emacsが間違った選択をしたときは、コマンド@kbd{M-x
plain-tex-mode}、@kbd{M-x latex-mode}、@kbd{M-x
slitex-mode}、@kbd{doctex-mode}を使用して、正しい@TeX{}モードの変種を選択できます。

  以下のセクションでは、@TeX{}モードとその変種の機能について記述しています。@TeX{}に関連したモードは他にもいくつかありますが、このマニュアルには記述されていません。

@itemize @bullet
@item
Bib@TeX{}モードはBib@TeX{}ファイルのためのメジャーモードで、これは一般的には@LaTeX{}文書の図書目録リファレンスを維持するのに使用されます。詳細については、コマンド@code{bibtex-mode}のドキュメント文字列を参照してください。

@item
Ref@TeX{}パッケージは、図書目録リファレンスを管理する@LaTeX{}モードとして使用されるマイナーモードを提供します。
@ifinfo
@ref{Top,The Ref@TeX{} Manual,,reftex}を参照してください。
@end ifinfo
@ifnotinfo
詳細については、Emacsとともに配布されているRef@TeX{}のInfoマニュアルを参照してください。
@end ifnotinfo

@item
AUC@TeX{}パッケージは、@TeX{}およびそれに関連するフォーマットを編集するための。より先進的な機能を提供します。これにはEmacsバッファーで@TeX{}をプレビューする機能も含まれます。Bib@TeX{}モードやRef@TeX{}パッケージとは異なり、AUC@TeX{}はデフォルトではEmacsとともには配布されません。これはPackageメニュー(@ref{Packages}を参照してください)を通じてダウンロードできます。インストールされた後に、
@ifinfo
@ref{Top,The AUC@TeX{} Manual,,auctex}を参照してください。
@end ifinfo
@ifnotinfo
パッケージに含まれるAUC@TeX{}マニュアルを参照してください。
@end ifnotinfo
@end itemize

@menu
* TeX Editing::              TeXモードで編集するための特別なコマンド。
* LaTeX Editing::            LaTeX入力ファイルのための追加のコマンド。
* TeX Print::                ファイルの一部をTeXで印刷するコマンド。
* TeX Misc::                 TeXモードのカスタマイズと関連する機能。
@end menu

@node TeX Editing
@subsection @TeX{} Editing Commands

@table @kbd
@item "
コンテキストに応じて@samp{``}、@samp{"}、@samp{''}のどれかを挿入します(@code{tex-insert-quote})。
@item C-j
パラグラフの区切り(2つの改行)を挿入して、前のパラグラフのバランスの取れていない大カッコ(braces)やドル記号をチェックします(@code{tex-terminate-paragraph})。
@item M-x tex-validate-region
リージョン内のパラグラフの、バランスのとれていない大カッコやドル記号をチェックします。
@item C-c @{
@samp{@{@}}を挿入して、ポイントをその間に配します(@code{tex-insert-braces})。
@item C-c @}
対応が取れていない、次の閉じ大カッコの後ろに、前方に移動します(@code{up-list})。
@end table

@findex tex-insert-quote
@kindex " @r{(@TeX{} mode)}
  @TeX{}では文字@samp{"}は通常使用されません。かわりに@samp{``}で始まり@samp{''}で終わる引用が使用されます。したがって@TeX{}モードは@kbd{"}キーを@code{tex-insert-quote}コマンドにバインドしています。これは空白文字または開き大カッコの後ろに@samp{``}、バックスラッシュの後に@samp{"}、それ以外の文字の場合は@samp{''}を挿入します。

  特別な例外として、ポイントの前のテキストが@samp{``}か@samp{''}のときに@kbd{"}をタイプすると、Emacsは前のテキストを1つの@kbd{"}で置き換えます。したがって、必要がある時は@kbd{""}とタイプして@samp{"}を挿入できます(@kbd{C-q
"}を使用してこの文字を挿入することもできます)。

  @TeX{}モードでは、@samp{$}は特別な構文コードを持っていて、それは@TeX{}の数式モードの区切りを理解しようと試みます。数式モードを抜けるために@samp{$}を入力した場合、数式モードに入るための対応する@samp{$}の位置が1秒間表示されます。これは閉じ大カッコが挿入されたとき、それに対応する開き大カッコが表示されるのと同じき機能です。しかし@samp{$}が数式モードに入るためなのか、それとも抜けるためなのかを指示する方法はありません。したがって、もし対応するものがある場合、実際にはそれが関係なくても、前の@samp{$}の位置が表示されます。

@findex tex-insert-braces
@kindex C-c @{ @r{(@TeX{} mode)}
@findex up-list
@kindex C-c @} @r{(@TeX{} mode)}
  @TeX{}は大カッコを、対応が取れていなければならない区切りとして使用します。これを1つずつ挿入するより、つねに大カッコの対応が取られている方を好むユーザーもいます。@kbd{C-c
@{}
(@code{tex-insert-braces})を使うと、対になった大カッコを挿入します。これはポイントを2つの大カッコの間に配すので、中のテキストを挿入することができます。その後でコマンド@kbd{C-c
@}} (@code{up-list})を使用すると、前方の閉じ大カッコの先に移動します。

@findex tex-validate-region
@findex tex-terminate-paragraph
@kindex C-j @r{(@TeX{} mode)}
  対応の取れていない大カッコをチェックするコマンドが2つあります。@kbd{C-j}
(@code{tex-terminate-paragraph})は、ポイントの前のパラグラフをチェックして、新しいパラグラフを開始するための2つの改行を挿入します。対応が取れていないものが見つかった場合、エコーエリアにメッセージを出力します。@kbd{M-x
tex-validate-region}はリージョンを、パラグラフごとにチェックします。エラーは@file{*Occur*}バッファーにリストされます。そのバッファーでは、特定のミスマッチをvisitする@kbd{C-c
C-c}などの、通常のOccurモードのコマンドを使用できます(@ref{Other Repeating Search}を参照してください)。

  @TeX{}のEmacsコマンドは大カッコだけではなく、角カッコ(square
brackets)やカッコ(parentheses)などもカウントすることに注意してください。これは@TeX{}構文をチェックする目的としては、厳密に正しいとは言えません。しかしカッコと角カッコはテキストの中で、同じような対応の取れた区切りとして使用され、さまざまな移動コマンドや、対応する区切りの表示が、それらにたいして機能するのは便利なのです。

@node LaTeX Editing
@subsection @LaTeX{} Editing Commands

  @LaTeX{}モードは、plain @TeX{}には適用できない特別な機能をいくつか提供します:

@table @kbd
@item C-c C-o
@LaTeX{}ブロックのための@samp{\begin}と@samp{\end}を挿入して、ポイントをそれらの間の行に配します(@code{tex-latex-block})。
@item C-c C-e
まだ閉じていない一番内側の@LaTeX{}ブロックを閉じます(@code{tex-close-latex-block})。
@end table

@findex tex-latex-block
@kindex C-c C-o @r{(@LaTeX{} mode)}
  @LaTeX{}入力では、テキストをブロック化するのに@samp{\begin}と@samp{\end}のタグが使用されます。ブロックを挿入するには@kbd{C-c
C-o}
(@code{tex-latex-block})とタイプします。これはブロックタイプの入力を求め、適切な対応する@samp{\begin}と@samp{\end}を挿入し、その2行の間に空行を残してポイントをそこに移動します。

@vindex latex-block-names
  @kbd{C-c
C-o}にたいしてブロックタイプを入力するとき、通常の補完コマンドを使用できます(@ref{Completion}を参照してください)。デフォルトの補完リストには、標準的な@LaTeX{}のブロックタイプが含まれています。補完にブロックタイプを追加したい場合は、リスト変数@code{latex-block-names}をカスタマイズしてください。

@findex tex-close-latex-block
@kindex C-c C-e @r{(@LaTeX{} mode)}
@findex latex-electric-env-pair-mode
  @LaTeX{}入力では、@samp{\begin}と@samp{\end}のタグは対応が取れていなければなりません。@kbd{C-c C-e}
(@code{tex-close-latex-block})により、対応が取れていない最後の@samp{\begin}に対応する@samp{\end}を挿入することができます。これは対応する@samp{\begin}に調和するように@samp{\end}をインデントし、ポイントが行の先頭にあるときは@samp{\end}タグの後ろに改行を挿入します。マイナーモード@code{latex-electric-env-pair-mode}は、@samp{\end}か@samp{\begin}の一方をタイプしたとき、自動的に対応する@samp{\end}または@samp{\begin}を挿入します。

@node TeX Print
@subsection @TeX{} Printing Commands

  バッファーの全内容、または一部(たとえば大きなドキュメントの1つのチャプター)にたいして、@TeX{}をEmacsのサブプロセスとして呼び出すことができます。

@table @kbd
@item C-c C-b
カレントバッファー全体にたいして@TeX{}を呼び出します(@code{tex-buffer})。
@item C-c C-r
バッファーのヘッダーとともに、カレントリージョンにたいして@TeX{}を呼び出します(@code{tex-region})。
@item C-c C-f
カレントファイルにたいして@TeX{}を呼び出します(@code{tex-file})。

@item C-c C-v
最後の@kbd{C-c C-r}、@kbd{C-c C-b}、@kbd{C-c
C-f}コマンドの出力をプレビューします(@code{tex-view})。

@item C-c C-p
最後の@kbd{C-c C-b}、@kbd{C-c C-r}、@kbd{C-c C-f}コマンドの出力を印刷します(@code{tex-print})。

@item C-c @key{TAB}
カレントファイルにたいしてBib@TeX{}を呼び出します(@code{tex-bibtex-file})。
@item C-c C-l
@TeX{}出力を表示するウィンドウを再センタリングして、最後の行が見えるようにします(@code{tex-recenter-output-buffer})。
@item C-c C-k
@TeX{}サブプロセスをkillします(@code{tex-kill-job})。
@item C-c C-c
カレントバッファー全体にたいして、他のコンパイルコマンドを呼び出します(@code{tex-compile})。
@end table

@findex tex-buffer
@kindex C-c C-b @r{(@TeX{} mode)}
@findex tex-view
@kindex C-c C-v @r{(@TeX{} mode)}
@findex tex-print
@kindex C-c C-p @r{(@TeX{} mode)}
  カレントバッファーを@TeX{}に渡すには、@kbd{C-c C-b}
(@code{tex-buffer})とタイプします。フォーマットされた出力は、通常@file{.dvi}という一時ファイルに出力されます。その後で@kbd{C-c
C-v}
(@code{tex-view})とタイプして、@command{xdvi}のような外部プログラムを起動して、出力ファイルを閲覧することができます。@kbd{C-c
C-p} (@code{tex-print})とタイプして出力ファイルのハードコピーを印刷することもできます。

@cindex @env{TEXINPUTS} environment variable
@vindex tex-directory
  デフォルトでは@kbd{C-c
C-b}は、カレントディレクトリーで@TeX{}を実行します。@TeX{}の出力もこのディレクトリーに出力されます。@TeX{}を違うディレクトリーで実行するには、変数@code{tex-directory}を望むディレクトリー名に変更します。環境変数@env{TEXINPUTS}に相対ディレクトリーが含まれていたり、ファイルに含まれる@samp{\input}コマンドが相対ファイル名の場合、@code{tex-directory}を@code{"."}に@emph{しないと}、望ましくない結果となるでしょう。そうでない場合は、@code{"/tmp"}などの他のディレクトリーを指定しても安全です。

@vindex tex-run-command
@vindex latex-run-command
@vindex tex-dvi-view-command
@vindex tex-dvi-print-command
  そのバッファーにたいする@TeX{}の変種は、@kbd{C-c C-b}で実際に実行されるシェルコマンドを決定します。Plain
@TeX{}モードでは、これは変数@code{tex-run-command}で指定され、デフォルトは@code{"tex"}です。@LaTeX{}モードでは、これは@code{latex-run-command}で指定され、デフォルトは@code{"latex"}です。@file{.dvi}を閲覧するために@kbd{C-c
C-v}で実行されるシェルコマンドは、@TeX{}の種類に関係なく、変数@code{tex-dvi-view-command}で決定されます。出力を印刷するために@kbd{C-c
C-p}で実行されるシェルコマンドは、変数@code{tex-dvi-print-command}で決定されます。

  Emacsは出力ファイル名に通常、前のパラグラフで説明したシェルコマンド文字列を自動的に追加します。たとえば@code{tex-dvi-view-command}が@code{"xdvi"}のとき、@kbd{C-c
C-v}は@command{xdvi
@var{output-file-name}}を実行します。しかし、ファイル名がコマンドに埋め込まれている必要があるケース、たとえばあるコマンドの引数にファイル名を与えて、そのコマンドの出力をパイプで他のコマンドに渡さなければいけない場合があります。コマンド文字列の@samp{*}で、ファイル名をどこに置くか指定することができます。以下は例です

@example
(setq tex-dvi-print-command "dvips -f * | lpr")
@end example

@findex tex-kill-job
@kindex C-c C-k @r{(@TeX{} mode)}
@findex tex-recenter-output-buffer
@kindex C-c C-l @r{(@TeX{} mode)}
  エラーメッセージを含む@TeX{}からの端末出力は、@file{*tex-shell*}という名前のバッファーに表示されます。@TeX{}でエラーが発生した場合、このバッファーに切り替えて、適切な入力を与えることができます(これはShellモードで機能します。@ref{Interactive
Shell}を参照してください)。このバッファーに切り替えなくても、これをスクロールできるので、@kbd{C-c
C-l}とタイプして最後の行を表示することができます。

  これ以上の出力が有用でないと判断した時は、@kbd{C-c C-k}
(@code{tex-kill-job})とタイプして@TeX{}プロセスをkillします。@kbd{C-c C-b}および@kbd{C-c
C-r}の使用するときも、@TeX{}がまだ実行中の時はkillします。

@findex tex-region
@kindex C-c C-r @r{(@TeX{} mode)}
  @kbd{C-c C-r}
(@code{tex-region})とタイプして、任意のリージョンを@TeX{}に渡すことができます。しかし、これはトリッキーです。なぜならほとんどの@TeX{}入力ファイルは、先頭にパラメーターをセットしたりマクロを定義するコマンドを含んでいるからです。この問題を解決するために、@kbd{C-c
C-r}では、必須のマクロを含むファイル部分を指定することができます。指定したリージョンの前にそれを含めて、@TeX{}の入力の一部とします。ファイルの必須と指定された部分を@dfn{ヘッダー}と呼びます。

@cindex header (@TeX{} mode)
  Plain @TeX{}モードでヘッダーの境界を示すには、ファイルに2つの特別な文字列を挿入します。これはヘッダーの前に@samp{%**start
of header}、ヘッダーの後ろに@samp{%**end of
header}を記述します。これらの文字列は1行に全体を記述しなければなりませんが、文字列の前または後ろに他のテキストがあっても構いません。この2つの文字列を含む行はヘッダーの中に含まれます。@samp{%**start
of header}がバッファーの先頭100行にない場合、@kbd{C-c C-r}はヘッダーがないとみなします。

  @LaTeX{}モードでは、ヘッダーは@samp{\documentclass}または@samp{\documentstyle}で始まり、@samp{\begin@{document@}}で終わります。いかなる場合でも@LaTeX{}がこれらを要求するので、ヘッダーを識別するのに特別なことをする必要はありません。

@findex tex-file
@kindex C-c C-f @r{(@TeX{} mode)}
  コマンド(@code{tex-buffer})および(@code{tex-region})は、すべてを一時ディレクトリーで処理します。そして@TeX{}でクロスリファレンスのために必要となる補助的なファイルは利用不可です。一般的にこれらのコマンドは、すべてのクロスリファレンスが正しい必要がある最終コピーのために実行するのには適していません。

  クロスリファレンスのための補助的なファイルを使いたいときは、@kbd{C-c C-f}
(@code{tex-file})を使用します。これはカレントバッファーのファイルにたいして、そのファイルのディレクトリーで@TeX{}を実行します。@TeX{}を実行する前に、変更されたバッファーを保存するか確認が求められます。一般的には、クロスリファレンスを正しく取得するために、2回(@code{tex-file})を使用する必要があります。

@vindex tex-start-options
  変数@code{tex-start-options}の値は、@TeX{}を実行するためのオプションを指定します。

@vindex tex-start-commands
  変数@code{tex-start-commands}の値は、@TeX{}を開始する@TeX{}コマンドを指定します。デフォルト値は@TeX{}をノンストップモードで実行します。対話的に@TeX{}を実行するときは、変数に@code{""}をセットします。

@vindex tex-main-file
  大きなサイズの@TeX{}ドキュメントは複数のファイル --- 1つはメインファイルで、他はサブファイル ---
に分割されているときがあります。サブファイルにたいして@TeX{}を実行しても通常は動作しません。メインファイルにたいして実行する必要があるのです。サブファイルを編集するのに@code{tex-file}を使えるようにするには、変数@code{tex-main-file}にメインファイルの名前をセットします。その後は@code{tex-file}はそのファイルにたいして@TeX{}を実行します。

  @code{tex-main-file}を使用する一番簡単な方法は、各サブファイルのローカル変数リストにそれを指定する方法です。@ref{File
Variables}を参照してください。

@findex tex-bibtex-file
@kindex C-c TAB @r{(@TeX{} mode)}
@vindex tex-bibtex-command
  @LaTeX{}ファイルにたいしては、Bib@TeX{}を使用してカレントバッファーのファイルのための補助的なファイルを処理できます。Bib@TeX{}はデータベースの図書目録の引用(bibliographic
citations)を探して、図書目録のセクション(bibliography section)のための引用文献(cited
references)を準備します。コマンド@kbd{C-c @key{TAB}}
(@code{tex-bibtex-file})は、カレントバッファーのファイルにたいする@samp{.bbl}ファイルを生成するためにシェルコマンド(@code{tex-bibtex-command})を実行します。一般的に、@samp{.aux}ファイルを生成するために一度@kbd{C-c
C-f} (@code{tex-file})を行う必要があります。その後@kbd{C-c @key{TAB}}
(@code{tex-bibtex-file})を行ってから、さらなるクロスリファレンスを正しく取得するために@kbd{C-c C-f}
(@code{tex-file})を2回行います。

@findex tex-compile
@kindex C-c C-c @r{(@TeX{} mode)}
  カレントの@TeX{}バッファーで、他のコンパイルプログラムを呼び出すには、@kbd{C-c C-c}
(@code{tex-compile})をタイプします。このコマンドは@file{pdflatex}、@file{yap}、@file{xdvi}、@file{dvips}を含む、多くの一般的なプログラムに渡す引数を知っています。標準の補完キーを使用して望ましいコンパイルプログラムを選択できます(@ref{Completion}を参照してください)。

@node TeX Misc
@subsection @TeX{} Mode Miscellany

@vindex tex-shell-hook
@vindex tex-mode-hook
@vindex latex-mode-hook
@vindex slitex-mode-hook
@vindex plain-tex-mode-hook
  @TeX{}モードの変種に入ると、フック@code{text-mode-hook}および@code{tex-mode-hook}を実行します。その後、@code{plain-tex-mode-hook}、@code{latex-mode-hook}、@code{slitex-mode-hook}のうち、適切なものを実行します。@TeX{}シェルを開始すると、フック@code{tex-shell-hook}を実行します。@ref{Hooks}を参照してください。

@findex iso-iso2tex
@findex iso-tex2iso
@findex iso-iso2gtex
@findex iso-gtex2iso
@cindex Latin-1 @TeX{} encoding
@cindex @TeX{} encoding
  コマンド@kbd{M-x iso-iso2tex}、@kbd{M-x iso-tex2iso}、@kbd{M-x
iso-iso2gtex}、@kbd{M-x
iso-gtex2iso}はLatin-1でエンコードされたファイルと、@TeX{}でエンコードされた等価なファイルの変換に使用できます。

@node HTML Mode
@section SGML and HTML Modes
@cindex SGML mode
@cindex HTML mode
@cindex mode, SGML
@cindex mode, HTML
@findex sgml-mode
@findex html-mode

  SGMLおよびHTMLのためのメジャーモードは、インデントのサポートとタグを操作するコマンドを提供します。HTMLモードはSGMLモード少しカスタマイズした変種です。

@table @kbd
@item C-c C-n
@kindex C-c C-n @r{(SGML mode)}
@findex sgml-name-char
対話的に特殊文字を指定して、その文字に対応するSGMLの@samp{&}コマンドを挿入します(@code{sgml-name-char})。

@item C-c C-t
@kindex C-c C-t @r{(SGML mode)}
@findex sgml-tag
対話的にタグとタグの属性を指定します(@code{sgml-tag})。このコマンドはタグ名と属性値を尋ね、開始タグと終了タグの両方を挿入し、ポイントをその間に置きます。

プレフィクス引数@var{n}を指定すると、このコマンドはバッファーのポイントの後ろにある@var{n}個の単語の周囲にタグを配します。リージョンがアクティブなときは、タグをリージョンの周辺に配します(Transient
Markモードがオフのときは、引数に@minus{}1を与えることにより、これを行います)。

@item C-c C-a
@kindex C-c C-a @r{(SGML mode)}
@findex sgml-attributes
対話的にカレントタグの属性値を挿入します(@code{sgml-attributes})。

@item C-c C-f
@kindex C-c C-f @r{(SGML mode)}
@findex sgml-skip-tag-forward
対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)をスキップします(@code{sgml-skip-tag-forward})。数引数は繰り返し回数として振る舞います。

@item C-c C-b
@kindex C-c C-b @r{(SGML mode)}
@findex sgml-skip-tag-backward
対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を後方にスキップします(@code{sgml-skip-tag-backward})。数引数は繰り返し回数として振る舞います。

@item C-c C-d
@kindex C-c C-d @r{(SGML mode)}
@findex sgml-delete-tag
ポイント位置またはポイントの後ろのタグを削除し、それに対応するタグも削除します(@code{sgml-delete-tag})。ポイントの後のタグが開始タグの場合は、終了タグも削除します。終了タグの場合は、開始タグも削除します。

@item C-c ? @var{tag} @key{RET}
@kindex C-c ? @r{(SGML mode)}
@findex sgml-tag-help
タグ@var{tag}の意味の説明を表示します(@code{sgml-tag-help})。引数@var{tag}が空のときは、ポイント位置のタグを説明します。

@item C-c /
@kindex C-c / @r{(SGML mode)}
@findex sgml-close-tag
一番内側の終了されていないタグの終了タグを挿入します(@code{sgml-close-tag})。タグまたはコメントの中で呼び出されたときは、終了タグを挿入するかわりにそれを終了させます。

@item C-c 8
@kindex C-c 8 @r{(SGML mode)}
@findex sgml-name-8bit-mode
挿入したLatin-1文字を、その文字自身ではなく、その文字を表すSGMLコマンドを挿入するマイナーモードを切り替えます(@code{sgml-name-8bit-mode})。

@item C-c C-v
@kindex C-c C-v @r{(SGML mode)}
@findex sgml-validate
カレントバッファーをSGMLとして評価するシェルコマンド(指定しなければならない)を実行します(@code{sgml-validate})。

@item C-c @key{TAB}
@kindex C-c TAB @r{(SGML mode)}
@findex sgml-tags-invisible
バッファーの既存のタグの可視・不可視を切り替えます。これは簡単なプレビューとして使用できます(@code{sgml-tags-invisible})。
@end table

@cindex nXML mode
@cindex mode, nXML
@findex nxml-mode
@cindex XML schema
  XMLドキュメントを編集するためのメジャーモードはnXMLモードと呼ばれます。このモードは多くの既存のXMLスキーマを認識することができ、@kbd{M-@key{TAB}}を通じてXMLエレメントの補完、同様にエラーをハイライトする``オンザフライ''なXMLの妥当性検証を提供します。既存のバッファーでnXMLモードを有効にするには、@kbd{M-x
nxml-mode}とタイプするか、@kbd{M-x
xml-mode}とタイプしても同じです。Emacsは@file{.xml}という拡張子をもつファイルにたいしてnXMLモードを使用します。@file{.xhtml}という拡張子をもつXHTMLファイルにたいしては、デフォルトでEmacsはHTMLモードを使用します。変数@code{auto-mode-alist}をカスタマイズすることによりnXMLモードを使用させることができます(@ref{Choosing
Modes}を参照してください)。
@ifinfo
nXMLモードについては、それ自身のマニュアルで説明されています: @ref{Top, nXML Mode,,nxml-mode, nXML
Mode}を参照してください。
@end ifinfo
@ifnotinfo
nXMLモードについては、Emacsとともに配布されているInfoマニュアルで説明されています。
@end ifnotinfo

@vindex sgml-xml-mode
  XMLはSGMLの厳格なサブセットなので、XMLを編集するのに、それほど強力ではないSGMLモードの使用を選択することもできます。既存のバッファーでSGMLモードを有効にするには、@kbd{M-x
sgml-mode}とタイプします。SGMLを有効にするとき、EmacsはバッファーがXMLかどうかを検証します。もしXMLの場合、変数@code{sgml-xml-mode}に非@code{nil}値をセットします。これにより上述したSGMLモードのタグ挿入コマンドは、常に明示的に終了タグを挿入するようになります。

@node Nroff Mode
@section Nroff Mode

@cindex nroff
@findex nroff-mode
@vindex nroff-mode-hook
  NroffモードはTextモードから派生した、nroffファイル(たとえばUnixのman)の編集に特化したメジャーモードです。@kbd{M-x
nroff-mode}とタイプすることによりこのモードにはいります。Nroffモードに入ることにより、フック@code{text-mode-hook}、その後で@code{nroff-mode-hook}が実行されます(@ref{Hooks}を参照してください)。

  Nroffモードでは、nroffコマンド行はパラグラフの区切りとして扱われ、ページは@samp{.bp}で区切られ、コメントはバックスラッシュとダブルクォートで始まります。これは以下のコマンドも定義します:

@findex forward-text-line
@findex backward-text-line
@findex count-text-lines
@kindex M-n @r{(Nroff mode)}
@kindex M-p @r{(Nroff mode)}
@kindex M-? @r{(Nroff mode)}
@table @kbd
@item M-n
nroffコマンドではない次の行の先頭に移動します(@code{forward-text-line})。引数は繰り返し回数です。
@item M-p
@kbd{M-n}と同様ですが上に移動します(@code{backward-text-line})。
@item M-?
エコーエリアにリージョンの、(nroffコマンドではない)テキストの行数を表示します(@code{count-text-lines})。
@end table

@findex electric-nroff-mode
  Electric
Nroffモードはバッファーローカルなマイナーモードで、Nroffモードとともに使うことができます。このマイナーモードを切り替えるには、@kbd{M-x
electric-nroff-mode}とタイプします(@ref{Minor
Modes}を参照してください)。このモードがオンのとき、グループ化を行う種類のnroffコマンドを含む行を@key{RET}をタイプして終端すると、グループ化を閉じるnroffコマンドが自動的に後続の行に挿入されます。

  NroffモードとともにOutline minorモード(@ref{Outline
Mode}を参照してください)を使用する場合、ヘッダー行は@samp{.H}の後に数字(ヘッダーレベル)が続く形式の行です。

@node Enriched Text
@section Enriched Text
@cindex Enriched mode
@cindex mode, Enriched
@cindex enriched text
@cindex WYSIWYG
@cindex word processing
@cindex text/enriched MIME format

  Enriched(多くの刺激を含む、豊かにした)は、フォーマットされたテキストファイルをWYSIWYG(``what you see is what
you
get'')な方法で編集するためのマイナーモードです。Enrichedモードが有効な場合、フォントやカラーなどのさまざまなフォーマットプロパティーを、バッファーのテキストに適用できます。バッファーを保存するときは、それらのプロパティーはテキストとともに、MIME形式@samp{text/enriched}のファイルフォーマットを使用して保存されます。

  Enrichedモードは通常、Textモードとともに使用されます(@ref{Text
Mode}を参照してください)。これは多くのメジャーモード(構文のハイライトのためにFont
Lockモードを使用するほとんどのプログラミング言語関連のモードを含む)で使用される、Font
Lockモードとの互換性は@emph{ありません}。Enrichedモードとは異なり、Font
Lockモードはカレントバッファーの内容にもとづいて、テキストのプロパティーを自動的に割り当てます。これらのプロパティーはディスクには保存されません。

  Emacsの@code{data-directory}のファイル@file{enriched.txt}は、Enrichedモードの機能例として役に立ちます。

@menu
* Enriched Mode::            Enrichedモードの開始と終了。
* Hard and Soft Newlines::   改行には2つの種類があります。
* Editing Format Info::      テキストプロパティーの編集方法。
* Enriched Faces::           太字、斜体、下線、など。
* Enriched Indentation::     左余白と右余白の変更。
* Enriched Justification::   テキストの中央揃え、左揃え、右揃え、など。
* Enriched Properties::      特別なテキストプロパティーサブメニュー。
@end menu

@node Enriched Mode
@subsection Enriched Mode

  Enrichedモードは、バッファーローカルなマイナーモードです(@ref{Minor
Modes}を参照してください)。@samp{text/enriched}フォーマットで保存されたファイルをvisitすると、Emacsは自動的にEnrichedモードを有効にし、ファイル内のフォーマット情報をバッファーのテキストに適用します。Enrichedモードが有効なときにバッファーを保存すると、ファイルはフォーマット情報を含む@samp{text/enriched}フォーマットで保存されます。

@findex enriched-mode
  フォーマットされたテキストで新しいファイルを作成するには、存在しないファイルをvisitして@kbd{M-x
enriched-mode}とタイプします。このコマンドは実際にEnrichedモードを切り替えます。プレフィクス引数を指定した場合、引数が正のときはEnrichedモードを有効にし、それ以外はEnrichedモードを無効にします。Enrichedモードを無効にすると、Emacsは@samp{text/enriched}フォーマットでバッファーを保存しなくなります。バッファーに追加されたフォーマットプロパティーはバッファーに残りますが、ディスクには保存されません。

@vindex enriched-translations
  Enrichedモードは、すべてのEmacsのテキストプロパティーを保存しません。変数@code{enriched-translations}に指定されたものだけを保存します。これにはフォント、カラー、インデント、行端揃えのプロパティーが含まれます。

@findex format-decode-buffer
  ファイルをvisitしたとき、ファイルが@samp{text/enriched}フォーマットだとEmacsが認識できなかった場合は、@kbd{M-x
format-decode-buffer}とタイプします。このコマンドはファイルフォーマットの入力を求め、そのフォーマットでファイルを再読み込みします。@samp{text/enriched}フォーマットを指定することにより、自動的にEnrichedモードが有効になります。

  @samp{text/enriched}ファイルをraw形式(フォーマットされたテキストではなく、マークアップタグを伴う通常テキスト)として閲覧するには、@kbd{M-x
find-file-literally}を使用します(@ref{Visiting}を参照してください)。

  Emacsが@samp{text/enriched}のようなファイルフォーマットを認識・変換する方法については、@ref{Format
Conversion,, Format Conversion, elisp, the Emacs Lisp Reference
Manual}を参照してください。テキストプロパティーについての詳細は、@ref{Text Properties,,, elisp, the Emacs
Lisp Reference Manual}を参照してください。

@node Hard and Soft Newlines
@subsection Hard and Soft Newlines
@cindex hard newline
@cindex soft newline
@cindex newlines, hard and soft

@cindex use-hard-newlines
  Enrichedモードでは、Emacsは2つの異なる改行、@dfn{ハード}改行と@dfn{ソフト}改行を区別します。@kbd{M-x
use-hard-newlines}とタイプすることにより、他のバッファーにたいしてこの機能を有効または無効にできます。

  ハード改行は、パラグラフを分割したりテキストがフィルされる方法に関らず行区切りが必要な場所で使用され、ソフト改行はフィルで使用されます。@key{RET}
(@code{newline})および@kbd{C-o} (@code{open-line})コマンドはハード改行を挿入します。Auto
Fill(@ref{Auto
Fill}を参照してください)を含むフィルコマンドは、ソフト改行だけを挿入し、削除もソフト改行だけでハード改行は削除せずに残します。

@c FIXME: I don't see 'unfilled' in that node.  --xfq
  したがってEnrichedモードで編集するときは、フィルされたパラグラフの途中で行を分けるのに@key{RET}や@kbd{C-o}を使うべきではありません。かわりにAuto
Fillモード、または明示的なフィルコマンド(@ref{Fill
Commands}を参照してください)を使用します。テーブルやリストのように、行区切りを常に残したい場所で@key{RET}や@kbd{C-o}を使用します。そのような行では、行端揃えスタイル(justification
style)も@code{unfilled}にしたいと思うかもしれません(@ref{Enriched Justification}を参照してください)。

@node Editing Format Info
@subsection Editing Format Information

  プロパティーを変更する一番簡単な方法は、@samp{Text Properties}メニューです。このメニューは、メニューバー(@ref{Menu
Bar}を参照してください)の@samp{Edit}メニュー、または@kbd{C-Mouse-2}(@ref{Menu Mouse
Clicks}を参照してください)で取得することができます。@samp{Text
Properties}メニューのコマンドのいくつかを、以下にリストします(@kbd{M-x})で呼び出すこともできます):

@table @code
@findex facemenu-remove-face-props
@item Remove Face Properties
リージョンからフェイスプロパティーを削除します(@code{facemenu-remove-face-props})。

@findex facemenu-remove-all
@item Remove Text Properties
リージョンからフェイスプロパティーを含む、すべてのテキストプロパティーを削除します(@code{facemenu-remove-all})。

@findex describe-text-properties
@cindex text properties of characters
@cindex overlays at character position
@cindex widgets at buffer position
@cindex buttons at buffer position
@item Describe Properties
ポイントの後ろにある文字の、すべてのテキストプロパティーと他の情報をリストします(@code{describe-text-properties})。

@item Display Faces
定義されたフェイスのリストを表示します(@code{list-faces-display})。@ref{Faces}を参照してください。

@item Display Colors
定義されたカラーのリストを表示します(@code{list-colors-display})。@ref{Colors}を参照してください。
@end table

@noindent
他のメニューエントリーについては、以下のセクションで説明します。

@node Enriched Faces
@subsection Faces in Enriched Text

  以下のコマンドは、フェイスを追加または削除するのに使用することができます(@ref{Faces}を参照してください)。マークがアクティブのときは、リージョンのテキストに適用され、マークが非アクティブのときは、次の自己挿入文字に適用されます。プレフィクス引数を指定すると、これらのコマンドはリージョンがアクティブな場合でも、次の自己挿入文字に適用されます。

@table @kbd
@kindex M-o d @r{(Enriched mode)}
@findex facemenu-set-default
@item M-o d
すべての@code{face}プロパティーを削除します(@code{facemenu-set-default})。

@kindex M-o b @r{(Enriched mode)}
@findex facemenu-set-bold
@item M-o b
@code{bold}(太字)フェイスを適用します(@code{facemenu-set-bold})。

@kindex M-o i @r{(Enriched mode)}
@findex facemenu-set-italic
@item M-o i
@code{italic}(斜体)フェイスを適用します(@code{facemenu-set-italic})。

@kindex M-o l @r{(Enriched mode)}
@findex facemenu-set-bold-italic
@item M-o l
@code{bold-italic}(太字斜体)フェイスを適用します(@code{facemenu-set-bold-italic})。

@kindex M-o u @r{(Enriched mode)}
@findex facemenu-set-underline
@item M-o u
@code{underline}(下線)フェイスを適用します(@code{facemenu-set-underline})。

@kindex M-o o @r{(Enriched mode)}
@findex facemenu-set-face
@item M-o o @var{face} @key{RET}
フェイス@var{face}を適用します(@code{facemenu-set-face})。

@findex facemenu-set-foreground
@item M-x facemenu-set-foreground
カラーの入力を求め(@pxref{Colors})、それをフォアグラウドカラーに適用します。

@findex facemenu-set-background
@item M-x facemenu-set-background
カラーの入力を求め、それをバックグラウンドカラーに適用します。
@end table

@noindent
これらのコマンドは、Text Propertiesメニューからも利用可能です。

  自己挿入文字は通常、フェイスプロパティー(および他のほとんどのテキストプロパティー)を、そのバッファーの前の文字から継承します。次の自己挿入文字にたいして上記のコマンドを指定した場合、その文字は前の文字からフェイスプロパティーは継承しませんが、他のテキストプロパティーは継承します。

  Enrichedモードは、他の追加のフェイス@code{excerpt}および@code{fixed}を定義します。これらはtext/enrichedファイルフォーマットで使われるコードに対応します。@code{excerpt}フェイスは引用のために使用されることを意図されており、デフォルトでは@code{italic}と同じように表示されます。@code{fixed}フェイスは固定幅テキストを指定し、デフォルトでは@code{bold}と同じように表示されます。

@node Enriched Indentation
@subsection Indentation in Enriched Text

  Enrichedモードでは、パラグラフまたはパラグラフの一部の、右余白または左余白に異なる量のインデントを指定できます。これらの余白は@kbd{M-q}
(@ref{Filling}を参照してください)のようなフィルコマンドにも影響します。

  IndentationサブメニューのTextプロパティーは、インデントを指定するコマンドを提供します:

@table @code
@kindex C-x TAB @r{(Enriched mode)}
@findex increase-left-margin
@item Indent More
リージョンを4列ずつインデントします(@code{increase-left-margin})。Enrichedモードでは、このコマンドは@kbd{C-x
@key{TAB}}でも利用可能です。数引数を指定した場合、何列を余白に追加するかを指定します(負の引数は余白を何列縮めるかを指定します)。

@item Indent Less
リージョンから4列のインデントを削除します。

@item Indent Right More
右端から4列インデントすることにより、テキストを狭くします。

@item Indent Right Less
右端からのインデントを4列削除します。
@end table

@vindex standard-indent
  変数@code{standard-indent}は、これらのコマンドがインデントを追加または減少させる列数を指定します。デフォルトは4です。Enrichedにたいするデフォルトの右余白は、通常のように@code{fill-column}により制御されます。

@kindex C-c [ @r{(Enriched mode)}
@kindex C-c ] @r{(Enriched mode)}
@findex set-left-margin
@findex set-right-margin
  @kbd{C-c [} (@code{set-left-margin})または@kbd{C-c ]}
(@code{set-right-margin})とタイプしても、左余白または右余白をセットできます。数引数で余白の幅を指定できます。指定しない場合、これらのコマンドはミニバッファーを通じて値の入力を求めます。

  それに加えてフィルプレフィクスがある場合は、指定されたパラグラフのインデントに使用されます。@kbd{C-x
.}は、フィルプレフィクスにたいして指定された、新しい値の中の空白文字は含めません。フィルコマンドは各行のインデントの後ろにフィルプレフィクスを探します。@ref{Fill
Prefix}を参照してください。

@node Enriched Justification
@subsection Justification in Enriched Text
@cindex justification style

  Enrichedモードでは、以下のコマンドを使って、フィルのためにさまざまな@dfn{行端揃えスタイル(justification
styles)}を指定できます。これらのコマンドは。ポイントを含むパラグラフ、またはリージョンがアクティブの場合は、リージョンと重なるすべてのパラグラフに適用されます。

@table @kbd
@kindex M-j l @r{(Enriched mode)}
@findex set-justification-left
@item M-j l
行を左余白に揃えます(@code{set-justification-left})。

@kindex M-j r @r{(Enriched mode)}
@findex set-justification-right
@item M-j r
行を右余白に揃えます(@code{set-justification-right})。

@kindex M-j b @r{(Enriched mode)}
@findex set-justification-full
@item M-j b
行の途中にスペースを挿入することにより、行を両端の余白に揃えます(@code{set-justification-full})。

@kindex M-j c @r{(Enriched mode)}
@kindex M-S @r{(Enriched mode)}
@findex set-justification-center
@item M-j c
@itemx M-S
両端の余白の間で行を中央に揃えます(@code{set-justification-center})。

@kindex M-j u @r{(Enriched mode)}
@findex set-justification-none
@item M-j u
フィルを完全にオフに切り替えます(@code{set-justification-none})。このセッティングにより、フィルコマンドはテキストに何も行わなくなります。それでも左余白はインデントすることができます。
@end table

@vindex default-justification
  Text
PropertiesメニューのJustificationサブメニューを使用して、行端揃えスタイルを指定することもできます。デフォルトの行端揃えスタイルはバッファーごとの変数@code{default-justification}により指定されます。この変数の値はシンボル@code{left}、@code{right}、@code{full}、@code{center}、または@code{none}のうちの1つです。シンボルの意味は上述したコマンドに対応します。

@node Enriched Properties
@subsection Setting Other Text Properties

  Text PropertiesメニューのSpecial Propertiesサブメニューには、3つのテキストプロパティー ---
@code{read-only}(テキストの変更を不可にします)、@code{invisible}(テキストを非表示にします)、@code{intangible}(テキスト内でのポイントの移動を不可にします)
--- を、追加または削除するエントリーがあります。@samp{Remove
Special}メニューアイテムは、リージョン内のテキストにたいする、これらの特別なプロパティーを削除します。

  プロパティー@code{invisible}および@code{intangible}は保存されません。

@node Text Based Tables
@section Editing Text-based Tables
@cindex table mode
@cindex text-based tables

  @code{table}パッケージは、テキストベースのテーブルを簡単に編集するコマンドを提供します。以下は、そのようなテーブルがどのように見えるかの例です:

@smallexample
@group
+-----------------+--------------------------------+-----------------+
|     Command     |          Description           |   Key Binding   |
+-----------------+--------------------------------+-----------------+
|  forward-char   |Move point right N characters   |       C-f       |
|                 |(left if N is negative).        |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+
|  backward-char  |Move point left N characters    |       C-b       |
|                 |(right if N is negative).       |                 |
|                 |                                |                 |
+-----------------+--------------------------------+-----------------+
@end group
@end smallexample

  このようなテキストがテーブルだとEmacsが認識した場合(@ref{Table
Recognition}を参照してください)、テーブルのセル内容を編集すると、内容が大きくなってセルに収まらなくなったときは、テーブルのセルを自動的にサイズ変更します。以下のセクションで説明されている、テーブルのレイアウトを操作したり編集するコマンドを使用することができます。

@findex table-fixed-width-mode
  @kbd{M-x table-fixed-width-mode}とタイプすることにより、自動的なテーブルのサイズ変更を切り替えることができます。

@menu
* Table Definition::         テキストベースのテーブルとは何か。
* Table Creation::           テーブルを作成する方法。
* Table Recognition::        テーブルをアクティブまたは非アクティブにする方法。
* Cell Commands::            テーブルのセル指向のコマンド。
* Cell Justification::       セル内容の位置調整。
* Table Rows and Columns::   行と列の追加と削除。
* Table Conversion::         プレーンテキストとテーブルの変換。
* Table Misc::               テーブル、その他。
@end menu

@node Table Definition
@subsection What is a Text-based Table?
@cindex cells, for text-based tables

  @dfn{テーブル(table)}は矩形のテキスト領域からなり、それらは@dfn{セル(cells)}に分割されます。セルは少なくとも1文字分の幅と高さをもち、それにボーダーラインは含まれません。セルは複数のセルに分割できますが、それらは重なることはできません。

  セルのボーダーラインは、以下の変数で指定された3つの特別な文字で描画されます:

@table @code
@vindex table-cell-vertical-char
@item table-cell-vertical-char
垂直ラインに使用される文字です。デフォルトは@samp{|}です。

@vindex table-cell-horizontal-chars
@item table-cell-horizontal-chars
水平ラインに使用される文字です。デフォルトは@samp{"-="}です。

@vindex table-cell-intersection-char
@item table-cell-intersection-char
水平ラインと垂直ラインの交点に使用される文字です。デフォルトは@samp{+}です。
@end table

@noindent
以下は@emph{無効}なテーブルの例です:

@example
   +-----+       +--+    +-++--+
   |     |       |  |    | ||  |
   |     |       |  |    | ||  |
   +--+  |    +--+--+    +-++--+
   |  |  |    |  |  |    +-++--+
   |  |  |    |  |  |    | ||  |
   +--+--+    +--+--+    +-++--+
      a          b          c
@end example

@noindent
左から順に説明します:

@enumerate a
@item
重なったセル、または非矩形のセルは許されません。
@item
ボーダーは矩形でなければなりません。
@item
セルは最小でも1文字分の幅と高さがなければなりません。
@end enumerate

@node Table Creation
@subsection Creating a Table
@cindex create a text-based table
@cindex table creation

@findex table-insert
  テキストベースのテーブルをスクラッチから作成するには、@kbd{M-x
table-insert}とタイプします。このコマンドはテーブルの列数、テーブルの行数、セルの幅と高さの入力を求めます。セルの幅とセルの高さに、セルのボーダーは含まれません。これらは1つの整数で指定するか(これは各セルの幅と高さが同じになることを意味します)、スペースまたはカンマで区切られた整数のシーケンス(これはテーブルの左から右の列、上から下の行の個別のセルにたいして幅と高さを指定します)です。その後、指定されたテーブルはポイント位置に挿入されます。

  @kbd{M-x
table-insert}で挿入されたテーブルは、Emacsにそれをテキストベースのテーブルとして特別に扱うように指示する、特別なテキストプロパティーを含みます。そのバッファーをファイルに保存して、後で再びvisitすると、それらのプロパティーは失われ、Emacsにとってテーブルは普通のテキストとして判断されます。これをテーブルに変換する方法については、次のセクションを参照してください。

@node Table Recognition
@subsection Table Recognition
@cindex table recognition

@findex table-recognize
@findex table-unrecognize
  バッファーに既存のテーブルがあり、そのテーブルから@kbd{M-x
table-insert}で適用された特別なテキストプロパティーが失われているとき、それはテーブルとして特別に扱われなくなります。これにテキストプロパティーを適用するには、@kbd{M-x
table-recognize}とタイプします。このコマンドはカレントバッファーをスキャンして、有効なテーブルセルを@dfn{認識}して、適切なテキストプロパティーを適用します。反対に、@kbd{M-x
table-unrecognize}とタイプすることにより、特別なテキストプロパティーを削除して、テーブルをプレーンテキストに変換して、カレントバッファーのすべてのテーブルを認識しなくなります。

  以下のコマンドを使って、選択的にテーブルを認識したり認識させなくすることもできます:

@table @kbd
@findex table-recognize-region
@item M-x table-recognize-region
カレントリージョンのテーブルを認識します。

@findex table-unrecognize-region
@item M-x table-unrecognize-region
カレントリージョンのテーブルを認識しなくします。

@findex table-recognize-table
@item M-x table-recognize-table
ポイント位置のテーブルを認識してアクティブにします。

@findex table-unrecognize-table
@item M-x table-unrecognize-table
ポイント位置のテーブルを非アクティブにします。

@findex table-recognize-cell
@item M-x table-recognize-cell
ポイント位置のセルを認識してアクティブにします。

@findex table-unrecognize-cell
@item M-x table-unrecognize-cell
ポイント位置のセルを非アクティブにします。
@end table

  テーブルを認識する他の方法については、@ref{Table Conversion}を参照してください。

@node Cell Commands
@subsection Commands for Table Cells

@findex table-forward-cell
@findex table-backward-cell
  コマンド@kbd{M-x table-forward-cell}および@kbd{M-x
table-backward-cell}は、ポイントをカレントセルから隣接するセルに移動します。その順番は巡回的です。ポイントがテーブルの最後のセルにあるとき、@kbd{M-x
table-forward-cell}はポイントを最初のセルに移動します。同様に、ポイントが最初のセルにあるとき、@kbd{M-x
table-backward-cell}はポイントを最後のセルに移動します。

@findex table-span-cell
  @kbd{M-x table-span-cell}は方向 --- 右、左、上、下 ---
の入力を求め、カレントセルをその方向の隣接するセルにマージします。マージした結果が不正なセルのレイアウトになる場合、このコマンドはエラーをシグナルします。

@findex table-split-cell
@findex table-split-cell-vertically
@findex table-split-cell-horizontally
@cindex text-based tables, splitting cells
@cindex splitting table cells
  @kbd{M-x
table-split-cell}は、ミニバッファーを使って分割する方向の入力を求め、カレントセルを垂直(vertically)または水平(horizontally)に分割します。特定の方向に分割するには、@kbd{M-x
table-split-cell-vertically}と@kbd{M-x
table-split-cell-horizontally}を使います。垂直に分割する場合、古いセルの内容は自動的に2つの新しいセルに分割されます。水平に分割する場合、セルが空でない場合は、セル内容をどのように分割するか入力を求めます。オプションは@samp{split}(内容をポイント位置で分割)、@samp{left}(すべての内容を左のセルへ)、@samp{right}(すべての内容を右のセルへ)です。

  以下のコマンドは、セルを拡大または縮小します。デフォルトでは、1行または1列ずつサイズ変更します。数引数が与えられた場合、それはサイズ変更を何行または何列単位で行うかを指定します。

@table @kbd
@findex table-heighten-cell
@item M-x table-heighten-cell
カレントセルを垂直方向に拡大します。

@findex table-shorten-cell
@item M-x table-shorten-cell
カレントセルを垂直方向に縮小します。

@findex table-widen-cell
@item M-x table-widen-cell
カレントセルを水平方向に拡大します。

@findex table-narrow-cell
@item M-x table-narrow-cell
カレントセルを水平方向に縮小します。
@end table

@node Cell Justification
@subsection Cell Justification
@cindex justification in text-based tables

  コマンド@kbd{M-x
table-justify}は、テキストベーステーブルの1つ以上のセルにたいして、@dfn{位置調整(justification)}を行います。位置調整は、セルのテキストがセルの外枠にたいして、どのように位置合わせされるかを決定します。テーブルの各セルは個別に位置調整できます。

@findex table-justify
  @kbd{M-x
table-justify}は、最初に何の位置調整をするかの入力を求めます。オプションは@samp{cell}(カレントセルのみ)、@samp{column}(テーブルのカレント列のすべてのセル)、@samp{row}
(テーブルのカレント行のすべてのセル)です。その後、コマンドは位置調整のスタイルの入力を求めます。オプションは@code{left}、@code{center}、@code{right}、@code{top}、@code{middle}、@code{bottom}、または@code{none}(垂直方向の位置調整を行わないことを意味します)です。

  水平および垂直方向の位置調整スタイルは独立して指定され、2つのタイプは同時に適用できます。たとえば@kbd{M-x
table-justify}を2回呼び出して、1回目は位置調整に@code{right}を指定して、2回目は位置調整に@code{bottom}を指定することにより、セルの内容を右下に位置調整することができます。

@vindex table-detect-cell-alignment
  位置調整スタイルは、テキストプロパティーとしてバッファーに格納され、バッファーをkillするかEmacsを終了すると失われます。@kbd{M-x
table-recognize}(@ref{Table
Recognition}を参照してください)のようなテーブルの認識コマンドは、セルの内容を確認して各セルの位置調整スタイルの決定と再適用を試みます。この機能を無効にするには、変数@code{table-detect-cell-alignment}を@code{nil}に変更してください。

@node Table Rows and Columns
@subsection Table Rows and Columns
@cindex inserting rows and columns in text-based tables

@findex table-insert-row
  @kbd{M-x
table-insert-row}は、テーブルのカレント行の前にセル行を挿入します。カレント行とポイントは、新しい行の下になります。テーブル最下にある最後の行の後ろに行を挿入するには、ポイントをテーブルの最下線の直下にポイントを移動して、このコマンドを呼び出します。数引数を指定することにより2つ以上の行を挿入できます。

@c A numeric prefix argument specifies the number of rows to insert.

@findex table-insert-column
  同様に、@kbd{M-x
table-insert-column}は、テーブルのカレント列の左にセル列を挿入します。右端の最右列の右に列を挿入するには、ポイントを最右線の右(テーブルの外)に移動して、このコマンドを呼び出します。数引数は挿入する列の数を指定します。

@cindex deleting rows and column in text-based tables
  @kbd{M-x table-delete-column}は、ポイントがあるセルの列を削除します。同様に、@kbd{M-x
table-delete-row}は、ポイントがあるセルの行を削除します。どちらのコマンドも数引数により削除する列または行の数を指定します。

@node Table Conversion
@subsection Converting Between Plain Text and Tables
@cindex text to table
@cindex table to text

@findex table-capture
  コマンド@kbd{M-x table-capture}は、プレーンテキストをリージョンにキャプチャーして、それをテーブルに変換します。@kbd{M-x
table-recognize}(@ref{Table
Recognition}を参照してください)とは異なり、元のテキストはテーブルの体裁をとる必要はありません。テーブル的な論理構造もつことだけが必要です。

  たとえば以下の数字があったとして、これらは3つの行と、カンマで水平方向に分割されます:

@example
1, 2, 3, 4
5, 6, 7, 8
, 9, 10
@end example

@noindent
このテキストにたいして@kbd{M-x table-capture}を呼び出すと、以下のテーブルが生成されます:

@example
+-----+-----+-----+-----+
|1    |2    |3    |4    |
+-----+-----+-----+-----+
|5    |6    |7    |8    |
+-----+-----+-----+-----+
|     |9    |10   |     |
+-----+-----+-----+-----+
@end example

@findex table-release
  @kbd{M-x table-release}は逆のことを行います。これはテーブルを元のプレーンテキストに戻し、セルのボーダーを削除します。

  この2つのコマンドの1つの用途としては、テキストをレイアウトで編集することです。以下の3つのパラグラフを見てください(後者の2つはヘッダー行にインデントされています):

@example
table-capture is a powerful command.
Here are some things it can do:

Parse Cell Items   Using row and column delimiter regexps,
                   it parses the specified text area and
                   extracts cell items into a table.
@end example

@noindent
上記のテキストを含むリージョンに@code{table-capture}を適用して、列と行を区切るregexpsに空文字列を指定すると、以下のような1つのセルからなるテーブルが作成されます。

@smallexample
@group
+----------------------------------------------------------+
|table-capture is a powerful command.                      |
|Here are some things it can do:                           |
|                                                          |
|Parse Cell Items   Using row and column delimiter regexps,|
|                   it parses the specified text area and  |
|                   extracts cell items into a table.      |
+----------------------------------------------------------+
@end group
@end smallexample

@noindent
その後でセル分割コマンド(@ref{Cell
Commands}を参照してください)を使って、各パラグラフが1つのセルを占めるようにテーブルを分割できます。

@smallexample
+----------------------------------------------------------+
|table-capture is a powerful command.                      |
|Here are some things it can do:                           |
+-----------------+----------------------------------------+
|Parse Cell Items | Using row and column delimiter regexps,|
|                 | it parses the specified text area and  |
|                 | extracts cell items into a table.      |
+-----------------+----------------------------------------+
@end smallexample

@noindent
これで各セルは他のセルのレイアウトに影響を与えることなく、独立して編集することができるようになりました。終了したら@kbd{M-x
table-release}を呼び出して、テーブルをプレーンテキストに戻します。

@node Table Misc
@subsection Table Miscellany

@cindex table dimensions
@findex table-query-dimension
  コマンド@code{table-query-dimension}は、テーブルのレイアウトとポイント位置のテーブルセルをレポートします。以下は出力の例です:

@smallexample
Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5
@end smallexample

@noindent
これはカレントセルの幅が21文字、高さが6行で、テーブルの幅が67文字、高さが16行で、2列3行で5つのセルがあることを示します。

@findex table-insert-sequence
  @kbd{M-x table-insert-sequence}は文字列を各セルに挿入します。各文字列はシーケンス --- たとえば一連の増加する数字
--- の一部です。

@cindex table for HTML and LaTeX
@findex table-generate-source
  @kbd{M-x
table-generate-source}は、特定のマークアップ言語にフォーマットされたテーブルを生成します。このコマンドは言語(これは@code{html}、@code{latex}、@code{cals}のどれか1つでなければなりません)と、結果を出力するバッファー、テーブルの表題を尋ね、生成されたテーブルを指定したバッファーに出力します。デフォルトの出力バッファーは@code{table.@var{lang}}で、@var{lang}は指定された言語です。

@node Two-Column
@section Two-Column Editing
@cindex two-column editing
@cindex splitting columns
@cindex columns, splitting

  2C-two-column(2列)モードは、横に並んだテキストの列を、簡単に編集できるようにします。これは横に並んだ2つのウィンドウを使って、それぞれのウィンドウは自身のバッファーを表示します。2Cモードに入るには3つの方法があります。

@table @asis
@item @kbd{@key{F2} 2}または@kbd{C-x 6 2}
@kindex F2 2
@kindex C-x 6 2
@findex 2C-two-columns
カレントバッファーを左に、カレントバッファーの名前にもとづいた名前のバッファーを右にして、2Cモードに入ります。右側のバッファーがまだ存在しない場合、そのバッファーは空で開始されます。カレントバッファーの内容は変更されません。

このコマンドは、カレントバッファーが空か1列だけしか含まなくて、それに別の列を追加したいときに適しています。

@item @kbd{@key{F2} s}または@kbd{C-x 6 s}
@kindex F2 s
@kindex C-x 6 s
@findex 2C-split
2列のテキストを含むカレントバッファーを2つのバッファーに分割して、それを横に並べて表示します(@code{2C-split})。カレントバッファーは左側のバッファーになりますが、右側の列のテキストは、右側のバッファーに移動します。カレント列は分割ポイントを指定します。分割はカレント行からバッファーの最後まで続きます。

このコマンドはすでに2列になったテキストを含むバッファーがあり、一時的にそれを列に分割したいときに適しています。

@item @kbd{@key{F2} b @var{buffer} @key{RET}}
@itemx @kbd{C-x 6 b @var{buffer} @key{RET}}
@kindex F2 b
@kindex C-x 6 b
@findex 2C-associate-buffer
カレントバッファーを左側のバッファー、バッファー@var{buffer}を右側のバッファーにして2Cモードに入ります(@code{2C-associate-buffer})。
@end table

  @kbd{@key{F2} s}または@kbd{C-x 6
s}は、列の区切りを探します。区切りは各行に出現する2列の間にある文字列です。区切りの幅は、@kbd{@key{F2}
s}への数引数で指定することができます。これはポイントの前の指定した文字数文を区切り文字とします。デフォルトでは幅が1なので、ポイントの前の文字が列区切りになります。

  行が適切な位置で分割された場合、@kbd{@key{F2}
s}は区切りの後ろのテキストを右側のバッファーに移動して、区切りを削除します。適切な位置に列区切りをもたない行は、分割されずに残ります。分割されない行は左側のバッファーに残り、右側のバッファーの対応する行は空になります(これは``2Cモードで2列にまたがる''行を書くときの方法で、そのような行は左側のバッファーに記述して、右側のバッファーは空の行にします)。

@kindex F2 RET
@kindex C-x 6 RET
@findex 2C-newline
  コマンド@kbd{C-x 6 @key{RET}} または@kbd{@key{F2} @key{RET}}
(@code{2C-newline})は、2つのバッファーの対応する位置にそれぞれ改行を挿入します。これは2列のテキストを分割されたバッファーで編集するときに、新しい行を追加する一番簡単な方法です。

@kindex F2 1
@kindex C-x 6 1
@findex 2C-merge
  望みどおりに両方のバッファーを編集し終えたら、@kbd{@key{F2} 1}または@kbd{C-x 6 1}
(@code{2C-merge})で、それらをマージします。これは右側のバッファーからテキストを、もう一方のバッファーの2列目にコピーします。2列編集に戻るには、@kbd{@key{F2}
s}を使用します。

@kindex F2 d
@kindex C-x 6 d
@findex 2C-dissociate
  @kbd{@key{F2} d}または@kbd{C-x 6 d}は、バッファーをそのままにして、2つのバッファーを分割します。@kbd{@key{F2}
d}とタイプしたとき、カレントではないバッファーが空の場合、@kbd{@key{F2} d}によりそのバッファーはkillされます。
